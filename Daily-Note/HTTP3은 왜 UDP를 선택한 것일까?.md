### 날짜 : 2022-11-18 18:06
### 주제 : #네트워크 #HTTP3 

---- 

### 메모 : 
- HTTP 작업 그룹의 의장 마크 노팅엄 

- TCP의 신뢰성 : 
	- 전송되는 데이터 패킷들의 순서, 패킷 유실 여부 
	- 송신 측이 보낸 데이터가 수신 측에 온전하게 전달될 수 있느냐 
- 그런데 이렇게 신뢰성을 보장하는 방식으로 수행하다보면, 레이턴시가 생길 수 밖에 없었다. 
	- 레이턴시를 줄일 수 있겠지만, 이런 방법을 도입하는 것은 너무 많은 영역을 뜯어고쳐야하고, 또 그 업데이트에 따라서 개인 컴퓨터 이용자들이 os를 업데이트해주어야하는데, 그것 또한 많은 제한이 따른다. 

- 이 글에서는 TCP의 문제점을 2가지로 설명하고 있다. 
	- 3-way-handshake때문에 연결 수립 속도가 느리다 
	- HOLB 가 있다. 

- UDP
	- 애초에 각각의 패킷 간의 순서가 존재하지 않는 독립적인 패킷을 사용한다. 
	- 목적지만 정해져 있으면 중간 경로는 어딜 타든 신경쓰지 않는다. 종단 간 연결 설정 또한 하지 않는다. 
	- 결론적으로 UDP가 신뢰성을 확보하기 위해서 하던 많은 작업들을 하지 않는다. 
		- 그래서 더 빠르다. 

- UDP를 사용하면서 뭐가 더 좋아진걸까? 
	- HTTP + TCP + TLS를 사용했던 방법보다 더 좋아졌다. 
	- 연결 설정 시 레이턴시 감소 
		- TCP는 기본 1RTT + TLS를 이용한 암호화까지 하면 + 2RTT가 필요하다 => 3 RTT 
		- QUIC은 1RTT만 소요된다. 
			- 첫번째 핸드쉐이크 때, 연결 설정에 필요한 정보와 함께 데이터도 다 보낸다. 
			- TCP + TLS는 데이터를 보내기 전에 신뢰성있는 연결과 암호화에 필요한 모든 정보를 교환하고 유효성을 검사한 뒤에 데이터를 교환한다. 
			- QUIC은 냅다 데이터부터 꽂아버린다. 
			- 클라이언트가 첫 요청을 보낼 때는 서버의 세션키를 모른다. 때문에 목적지 서버의 Connection Id를 사용하여 생성한 Initial Key를 사용해서 통신을 암호화한다. 
				- 한번 연결에 성공했으면 서버는 그 설정을 캐싱한다. 때문에 다음부터는 0 RTT가 가능해진다. 

- TCP가 사용하는 손실감지 방법 
	- Stop and Wait ARQ 
	- 송신 측이 패킷을 보낸 후 타이머를 사용하여 시간을 재고, 일정 시간이 경과해도 수신 측이 적절한 답변을 주지 않는다면 패킷이 손실된 것으로 판단. 
		- 이때 기다리는 시간은 어떻게 계산하는가? 이 시간은 동적으로 계산된다. 
		- 한번 패킷을 보낸 후 잘 받았다는 응답을 받을 때 걸렸던 시간들을 측정해서 동적으로 타임 아웃을 설정한다. 
- QUIC이 패킷 손실을 감지하는 방법 
	- 헤더에 별도의 패킷 번호 공간을 부여 
	- 이 번호는 전송 순서 자체만을 나타낸다. 
		- 재전송시 동일한 번호가 전송되는 시퀀스 번호와는 다르다. 
		- 매 전송마다 모노토닉하게 패킷 번호가 증가한다. 
			- 때문에 패킷의 전송 순서를 명확하게 파악할 수 있다. 
			- 모노토닉하다는게 무슨 말일까?
				- ㅑ

### 내 생각과 정리 : 


### 출처(참고문헌) : 


### Link : 
