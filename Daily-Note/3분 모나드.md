### 날짜 : 2022-11-11 12:00
### 주제 : #함수형프로그래밍 #모나드 

---- 

### 메모 : 

> 어떤 타입 M에 대해 아래의 두 함수, pure와 compose가 존재할 때, M은 모나드입니다. 

```javascript
type Pure = <A>(a: A) => M<A>; 
type Compose = <A, B, C>(f : (a:A)) => M<B>, g: (a : B) => M<C>) => (a : A) => M<C>;
```
- 이것이 프로그래밍에서의 모나드의 정의라고 한다. 
	- 생각보다 간단하지 않냐고 묻는데 나에게는 그렇게 간단해 보이지는 않는다. 

```javascript
type Maybe<A> = A | null;

function pure<A>(value : A) : Maybe<A> {
	return value;
}

function compose<A,B,C>(f : (a:A) => Maybe<B>, g : (a : B) => Maybe<C>) : (a: A) => Maybe<C> {
	return (a : A) => Maybe<C> => {
		const ma = f(a);

		if(ma === null) return null;
		else g(ma);
	}
}
```


- 이런 형식과 정의를 가진 모나드는 어떤 의의를 가지는가? 

- 프로그램을 작성할 때 중요한 개념 중 하나가 '연산'이다. 
	- 프로그램은 어쩌면 '연산의 명세'라고 볼 수 있다. 
	- 하지만 종종 개발자들은 '값'만 우대하곤 한다. '값'을 모델링하긴 하지만, '연산'을 어떻게 모델링할 지는 생각하지 않는다는 것이다. 
	- 여기서 말하는 모델링은 추상화한다는 것이다. 
		- 추상화의 한 방식으로 분류라는 방식이 존재한다. 
		- 어떤 카테고리를 나눈다는 행위자체가 추상화의 작업이라고 할 수 있다. 
			- 우리는 '값'뿐만이 아니라, '연산'도 분류를 나누어 생각해볼 수 있다. 
			- 그 연산 중에서도 '실패할 수 있는 연산'도 하나의 분류로 생각해볼 수 있다. 


### 내 생각과 정리 : 


### 출처(참고문헌) : 


### Link : 
