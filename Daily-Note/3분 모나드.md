### 날짜 : 2022-11-11 12:00
### 주제 : #함수형프로그래밍 #모나드 #제네릭 #추상화 

---- 

### 메모 : 

> 어떤 타입 M에 대해 아래의 두 함수, pure와 compose가 존재할 때, M은 모나드입니다. 

```javascript
type Pure = <A>(a: A) => M<A>; 
type Compose = <A, B, C>(f : (a:A)) => M<B>, g: (a : B) => M<C>) => (a : A) => M<C>;
```
- 이것이 프로그래밍에서의 모나드의 정의라고 한다. 
	- 생각보다 간단하지 않냐고 묻는데 나에게는 그렇게 간단해 보이지는 않는다. 

```javascript
type Maybe<A> = A | null;

function pure<A>(value : A) : Maybe<A> {
	return value;
}

function compose<A,B,C>(f : (a:A) => Maybe<B>, g : (a : B) => Maybe<C>) : (a: A) => Maybe<C> {
	return (a : A) => Maybe<C> => {
		const ma = f(a);

		if(ma === null) return null;
		else g(ma);
	}
}
```


- 이런 형식과 정의를 가진 모나드는 어떤 의의를 가지는가? 

- 프로그램을 작성할 때 중요한 개념 중 하나가 '연산'이다. 
	- 프로그램은 어쩌면 '연산의 명세'라고 볼 수 있다. 
	- 하지만 종종 개발자들은 '값'만 우대하곤 한다. '값'을 모델링하긴 하지만, '연산'을 어떻게 모델링할 지는 생각하지 않는다는 것이다. 
	- 여기서 말하는 모델링은 추상화한다는 것이다. 
		- 추상화의 한 방식으로 분류라는 방식이 존재한다. 
		- 어떤 카테고리를 나눈다는 행위자체가 추상화의 작업이라고 할 수 있다. 
			- 우리는 '값'뿐만이 아니라, '연산'도 분류를 나누어 생각해볼 수 있다. 
			- 그 연산 중에서도 '실패할 수 있는 연산'도 하나의 분류로 생각해볼 수 있다. 
				- 이것은 어떻게 정의내릴 수 있을까? 조금 더 명확하고 구체적인 언어가 필요하다. 
				- 우리는 의미론이라는 것을 활용해 연산에 대한 충분히 명확하고 구체적인 정의를 내린다. 
					- 다양한 의미론 중에서 범주 의미론이라는 것이 있다. 
					- 카테고리 이론, 즉 범주론은 집합론의 반대에 해당하는 개념이다. '요소' 대신 '요소들 간의 관계'에 주목하는 것이다. 
					- 중요한 것은 모나드가 이 이론의 개념이다. 유지니오 모기라는 컴퓨터 과학자가 범주 의미론에서 모나드로 연산을 정의하고 추상화할 수 있다는 것을 발견했다. 
- 이 지점에서 모나드의 의의를 이해할 수 있다. 
	- 모나드는 연산을 정의하고, 추상화하기 위해서 사용되는 것이다. 
	- 하지만 어떤 연산을 정의한다는 것일까? 모나드로 연산을 정의하면 무엇이 좋은 것일까? 

- 왜 연산을 추상화하는 것일까? 
	- 제네릭을 아는가? 제네릭은 여러 데이터들에 대해 일반적인, 즉, 유연한 코드를 작성함으로써 재사용성을 끌어올리는 방식이다. 

```javascript
class List<T>{
	public readonly head : T;
	public readonly tail? : List<T>;

	constructor(head : T, tail?: List<T>){
		this.head = head;
		this.tail = tail;
	}
}
```
- 모든 타입에 대해서 리스트가 담고 있는 값은 다를지언정, 리스트 자체의 구조는 같다. 
	- 앞 부분과 뒷 부분이 있다는 것이다. 
	- 위 코드는 제네릭의 예시가 된다. 
	- 이렇게 함으로써 이런 데이터 구조를 가진 것들에 대해서 재사용성을 높일 수 있다. 
	- 여기서 또 유추해볼 수 있는 것은 데이터구조로 인한 재사용성의 향상이다. 

- 이와 같은 방식으로 데이터 뿐만이 아니라, 연산도 추상화할 수 있다면 어떨까? 
	- 코드의 재사용성이 증폭될 것이다. 
	- 어떤 연산이 범주 의미론에서 모나드로 추상화된다면 그 연산은 '합칠 수 있음'이 보장된다. 
		- 이 문장이 무슨 말인지 모르겠다. 
	- 수학적으로, 모나드의 성질이 바로 '합칠 수 있음'이다. 
	- 즉, 모나드는 '합칠 수 있는 연산'을 정의하고 추상화하기 위해 쓴다고 할 수 있다. 
		- 연산이 합쳐진다는 것은 어떤 의미를 가지고 있는 것일까? 
		- 이것은 어떤 가치를 가지는 것일까? 

- 모든 프로그램은 연산이다. 
	- 부 프로그램이란, 곧 함수를 말한다. 
	- 프로그램은 부프로그램들로 이루어져있다. 즉, 함수들로 이루어져있다는 것이다. 
	- 모나드로 정의된 연산은 합쳐질 수 있다??? 
		- 이 문장이 가장 이해가 안되는 것 같다. 
	- 어떤 연산이 모나드로 정의된다면, 그 연산에 해당하는 모든 프로그램들은 합쳐질 수 있다. 


> 모든 이야기를 종합하자면 모나드의 속뜻, 즉, 어떤 것이 모나드임이 시사하는 바는 그것이 합성될 수 있는 연산이라는 것입니다. 


> 어떤 타입 M에 대해 두 함수, pure과 compose가 존재할 때, M은 모나드이다. 

- 타입 M 부터 살펴보자. 
	- 타입 M은 연산 M을 의미한다. 타입 `M<A>`는 A타입의 연산 M을 의미한다. 
		- `M<number>`는 number 타입의 값을 만드는 연산 M을 의미한다.
		- 타입M은 연산과 어떤 관계가 있는 것일까? 
	- 타입 M이 연산을 대표하는 이유는 모든 프로그램을 A타입의 값을 받아 연산 M을 수행하여 B 타입의 값을 내놓는 함수라고 볼 수 있다는 점에서 그렇다. (오.. 확실히 연산이라는 것을 추상화시킨 것 같다.)
		- 모든 일차방정식이 `ax + b = 0`으로 표현될 수 있는 것처럼, 모든 프로그램 또한 `A => M<B>` 타입으로 표현될 수 있다. 
		- 여기서 타입 A와 B는 항상 중복되기 때문에 각 프로그램의 차이는 연산을 나타내는 타입 M으로부터 비롯됨을 알 수 있다. 
			- 타입 M이 곧 다른 프로그램과의 차이점을 만들어낸다는 것이다. 
- 이제 compose 에 대해서 알아보자. 
	- compose 함수의 시그니처는 `<A,B,C>(f : (a:A) => M<B>, g : (a:B) => M<C> => (a : A) => M<C>` 이다. 
		- 같은 연산을 하는 두 프로그램을 받아 하나로 합치는 형태이다. 
		- 모나드가 '합성할 수 있는 연산'을 정의하며 추상화하는 도구라는 점을 잊지 말아야 한다. 
		- 바로 이 compose함수가 모나드의 연산인 합성 가능성을 보장하는 함수다. 
		- 모나드가 되려면 이 함수를 구현해야 한다. 
			- 때문에 모나드인 모든 연산은 합성할 수 있다고 말하는 것이다. 
		- 즉, compose함수는 합성 가능한 연산들만이 모나드가 될 수 있게 하기 위해 존자하는 제한이다. 
	
- 마지막으로 pure 함수의 의미에 대해 알아보자. 
	- pure 함수는 일반적인 값을 연산 M이 적용된 값인 것처럼 꾸며주는 함수다. 
		- pure(1)은 1을 결과로 하는 연산 M을 나타낸다. 
		- 이 함수의 쓸모를 이야기하려면 id라고 불리는 함수에 대해 알아야 한다. 

```javascript
function id<A>(a : A): A{
	return a; 
}
```
- 이 함수는 함수형에서 가장 중요한 함수다. 
	- 가장 쉬운 사용 사례로는 함수의 몸집 키우기가 있다. 
	- 임의의 튜플 [A, B]의 각 요소에 함수를 적용하는 함수, bimap이 있다 가정해보자
	
```javascript
function bimap<A, B, C, D>([a, b] : [A, B], f : (a : A) => C, g : (b : B) => D) : [C,D]{
	return [f(a), g(b)];
}
```

- 만약 이런 함수가 주어졌을 때, 주어진 튜플의 2번째 요소에만 함수를 적용하는 함수를 만든다고 한다면, id함수 없이는 부분적으로 중복되는 코드를 처음부터 작성해야한다. 

```javascript 
function fmap<A,B,C>([a,b] : [A, B], f: (b:B) => C):[A,C]{
	return [a, f(b)]
}
```

하지만 id함수를 사용하면 간단하게 필요한 함수를 만들 수 있다. 

```javascript 
function fmap2<A,B,C>(pair : [A, B], f(b:B) => C):[A,C]{
	return bimap(pair, id, f)
}
```

- 이렇게 id 함수는 작은 함수들을 조립해 큰 함수를 만들 때, 별 다른 기능 없이 단순히 특정 자리를 채워 몸집만을 불리고 싶은 경우에 사용할 수 있다. 


- 직접 모나드인 연산과 모나드를 나루는 함수들을 보면서, 모나드의 가치를 체험해보자. 
- 입출력 연산부터 살펴보자. 
	- 입출력 연산은 외부 세계를 조작하는 연산이다. 이것은 외부 세계를 나타내는 값의 타입 RealWorld와 입출력 연산 결과의 타입 A를 통해, 외부 세계를 받아 수정된 외부 세계와 결과값을 내놓는 함수들의 타입, RealWorld => [A, Realworld]로 표현될 수 있다. 

```javascript
type RealWorld = never;
type IO<A> = (realWorld : RealWorld) => [A, RealWorld];
```

pure 함수를 정의해보자. 
```javascript
function pure<A> (a: A): IO<A> {
	return realWorld => [a, realWorld];
}
```
주어진 값을 그대로 반환하는 id함수와 근본적인 아이디어가 같다고 할 수 있다. 

이제 두 입출력 연산을 합쳐 줄 compose함수를 정의하도록 하겠다. 
```javascript
function compose<A,B,C>(f : (a:A) => IO<B>, g : (a: B) => IO<C>): (a:A) => IO<C> {
	return a => realWorld => {
		const [prevResult, prevRealWorld] = f(a)(realWorld);

	return g(prevResult)(prevRealWorld);
	}
}

```


모나드인 연산들을 다루는 함수를 정의해보자. bind라고 불리는 함수로, 연산의 결과에 연산을 적용하는 함수이다. 
```javascript
interface Monad<M>{
	pure<A>(a : A): M<A>;
	compose<A,B,C>(f : (a:A) => M<B>, g: (a:B) => M<C>) : (a:A) => M<C>
}

function bind<A,B,M>(m : Monad<M>, ma: M<A>, f : (a: A) => M<B>) : M<B>{
	return m.componse(() => ma, f);
}

```


```javascript
declare const IOMonad : Monad<IO>;
declare function print(message : string) : IO<void>;
declare function get(message : string, defaultValue: string): IO<string>;
declare function unsafePerformIO<A>(ioA:IO<A>):A;

const main = bind(
	IOMonad, 
	print('Welcome to monadic world'),
	_ => bind(
		IOMonad,
		get('What\'s your name?', 'anonymous user'),
		username => print(`Hi, ${username}`)
	)
)

unsafePerformIO(main)
```

- 모나드의 정의 
	- 겉뜻 : 모나드인 타입이 나타내는 것이 합성 가능한 연산임을 보장하기 위한 요소들로 구성되어있다. 
	- 속뜻 : 합성할 수 있는 연산을 정의하고 추상화할 수 있다는 데에 있다. 
- 모나드란, 합성할 수 있는 연산이다. 


### 내 생각과 정리 : 
- 기가막히는 설명들이다. 특히 연산을 추상화한다는 개념이 너무나 재미있게 다가왔다. 
- 특정 개념들을 분류하는 범주론. 어떤 사물을 분류하는 범주와, 특정 행동을 분류하는 범주가 있을 수 있다. 프로그래밍에서도 값을 분류하는 범주와, 연산을 분류하는 범주가 있을 수 있다. 그 중에서 연산을 분류하는 범주에 모나드가 속한다. 모나드는 연산을 추상화했다. 

- 연산을 추상화한다는 것은 어떤 유익이 있는 것인가? 프로그래밍에서 무언가를 추상화한다는 것은 그것의 재사용성이 늘어난다는 의미가 된다. 함수형 프로그래밍에서 순수함수를 다루고, 함수를 잘게 쪼개는 지향성은 함수의 재사용성에 있다. 이 글에서 연산을 추상화함으로써, 재사용성을 늘린다는 이야기를 듣고, 역시 일관된 지향성을 가지는구나를 생각했다. 모나드는 어떤 측면에서 재사용성을 늘려줄 수 있다는 것이다. 

- 내용 중에서 잠깐 언급된 부분이긴 하지만, 제네릭의 의미에 대해서도 조금 더 깊이 이해할 수 있는 시간이 되기도 했다. 제네릭은 '일반적인'의 의미를 가지고 있다. 이것은 특정한 의미를 더욱 추상화시킨다는 것이다. 이것을 함수형 자바스크립트 책에서는 '승급'이라는 단어로 사용하기도 했다. '승급'은 영어로는 lifting이라고 부른다. 특정 대상을 승급 시킨다는 것은 그 대상을 더욱 일반적인 대상으로 끌어올린다는 의미가 된다.
	- 이런 의미는 오브젝트 책에서 자주 읽었던  상위정책, 하위정책 등의 단어와도 일맥상통한다고 생각한다. 하위 정책에 해당하는 녀석을 승급시켜서, 상위정책으로 만들면 해당 대상은 더욱 일반적인 대상이 된다. 
		- 예를 들어서, 생일 할인, 금액할인과 같이 할인의 구체적인 정책, 하위정책에 해당하는 녀석들을 승급 시키면, 말 그대로 '할인정책'이 되어버린다. 이제 이 할인 정책은 훨씬 더 추상적인 대상이 되었고, 일반적인 대상이 되었고, 재사용가능한 대상이 되었다. 이것은 생일 할인에서 승급된 대상이다. 

- identity 함수의 쓸모에 대해서도 언급되고 있다.


### 출처(참고문헌) : 
[3분 모나드](https://overcurried.com/3%EB%B6%84%20%EB%AA%A8%EB%82%98%EB%93%9C/)


### Link : 
[[모나드란 무엇인가? - Naver D2]]
[[JS개발자는 아직도 모나드를 모르겠어요]]

