### 날짜 : 2022-11-10 01:10
### 주제 : #알고리즘 #정렬알고리즘 

---- 

### 메모 : 
 - 삽입정렬의 시간복잡도는 O(n2)이다
	 - 특정한 케이스에서는 선택정렬, 버블 정렬에 비해서 가장 빠른 알고리즘이 될 수도 있다.  
 - 각 숫자를 적절한 위치에 삽입하는 방법으로 문제를 해결하게 된다. 다른 정렬 방식은 무조건 위치를 바꾸는 방식이었지만, 삽입 정렬은 필요할 때만 위치를 바꾸게 된다. 

- j가 끝나고 나면 tmp를 삽입해줘야한다. 그런데 이 tmp를 어디에다가 삽입할까? 
	- j가 끝난지점 바로 뒤쪽에다가 넣어준다. 

5 7 11 6 10 9 

이런 순자가 존재한다. 지금은 4번째 순서까지 왔다. 
- 6이라는 숫자를 들고 뒤로가면서 확인한다. 
	- 11은 6보다 크다. 이 숫자를 3번째 자리에 위치하도록 만든다. 
	- 7은 6보다 크다. 이 숫자를 2번재 자리에 위치하도록 만든다. 
	- 5는 6보다 작다. 때문에 조건문이 일치하지 않게 된다. for문이 break된다. 
	- 그러면 j는 0번째에서 멈추게 된다. 
		- 그리고 j가 멈춘 그 자리 뒤편에다가 tmp를 넣어줘라고 했다. 
		- 그러면 6을 1번째 자리에 넣어주는 것이다. 그래서 아래와 같은 숫자가 되었다. 

5 6 7 11 10 9 

- 10 같은 경우도 마찬가지다. 
	- 10을 들고 11과 비교한다. 11이 더 크기 때문이 이 숫자를 10이 원래 있던 자리에 넣는다. 
	- 그리고 10을 7과 비교해봤더니, 10이 더 크다. 그러면 이 지점에서 break된다. 
	- j가 멈춘지점은 2 였기 때문에 2+1을 해서 3의 자리에 tmp를 넣어준다. 그 결과 아래와 같은 숫자 배열이 되었다. 

5 6 7 10 11 9

- 9 의 경우. 
	- 마찬가지로 2 위치에서 멈춘다. 




### 내 생각과 정리 : 
- 삽입 정렬은 선택한 수의 알맞은 자리를 찾아서 정렬을 하기 때문에 삽입 정렬이라고 부르게 되었다. 
- 삽입정렬은 2번째 수부터 시작하게 된다. 그래서 본인의 앞에 있는 수와 비교해서, 앞에 있는 수가 더 큰 경우에는 본인의 자리와 교체하게 된다. 
	- 그 다음으로는 3,4,5,6 순서대로 정렬을 시작한다. 



### 출처(참고문헌) : 



### Link : 
