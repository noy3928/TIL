### 날짜 : 2022-12-13 14:27
### 주제 : 

---- 

### 메모 : 

- cors의 효용성 : 
	- cors라는 방어막이 존재하기 때문에 우리가 이 곳 저 곳에서 가져오는 리소스가 안전하다는 최소한의 보장을 받을 수 있다. 

- sop(same-origin-policy)
	- 같은 출처에서만 리소스를 공유할 수 있다. 
	- 하지만 오픈 스페이스 환경에서 다른 출처에 있는 리소스를 가져와서 사용하는 일은 굉장히 흔한 일이다. 때문에 몇 가지 예외 조항을 두고 이 조항에 해당하는 리소스 요청은 출처가 달라도 허용하기로 했다. 그 중 하나가 CORS 정책을 지킨 리소스 요청이다. 
	- 다른 출처의 리소스를 사용한다면 애초에 SOP를 어긴 것이다. 
		- 거기에 CORS까지 지키지 않는다면 해당 리소스는 사용할 수 없는 리소스가 된다. 

- 다른 출처의 리소스를 가져와 사용할 때 발생할 수 있는 문제점 : 
	- 특히나 웹의 경우 사용자의 공격에 너무나 취약하다. 
	- 난독화가 되었다고 해서 암호화가된 것은 아니다. 
	- CSRF나 XSS와 같은 방법을 사용하여 사용자의 정보를 탈취하기가 너무 쉬워진다. 

- 같은 출처를 구분하는 기준 : 
	- `Scheme` , `Host` , `Port`
	- `https://`  - `Scheme` 
	- `evan-moon.github.io` - `Host`
	- `:80` - `Port`

- 출처를 비교하는 로직이 위치에 해 있는 곳 : 브라우저 
	- 해당 로직은 서버에서 구현되어있지 않고, 브라우저에 구현되어 있는 스펙이다. 
	- 특정 리소스를 요청한다고 할 때, 서버 측에서는 그냥 정상적으로 응답을 보낸다.(일반적으로는. 서버가 동일 출처를 검증하는 로직을 가지고 있는 경우는 예외)
	- 응답받는 리소스를 분석해서 CORS 정책 위반이라고 판단되면 해당 응답을 사용하지 않고 그냥 버린다. 


- CORS의 동작 원리 : 
	- 클라이언트가 다른 출처의 리소스를 요청 할 때는 HTTP 프로토콜을 사용하여 요청을 보낸다. 이 때 브라우저는 `Origin` 이라는 필드에 요청을 보내는 출처를 함께 담아서 보낸다. `Origin: https://evan-moon.github.io` 
	- 이후 서버가 응답을 할 때 응답 헤더의 `Access-Control-Allow-Origin` 이라는 값에 '이 리소스를 접근하는 것이 허용된 출처'를 내려준다. 
		- 이후 브라우저는 자신이 보냈던 요청의 `Origin`과 `Access-Control-Allow-Origin` 을 비교해 본 후 이 응답이 유효한 응답인지를 결정한다. 

- CORS 동작의 세 가지 시나리오 : 
	- Preflight Request : 
		- 일반적으로 가장 많이 마주칠 수 있는 시나리오이다. 
		- 이 시나리오에서 브라우저는 요청을 한번에 보내지 않는다. 예비 요청과 본 요청으로 나누어서 서버로 전송한다. 
		- 이때 예비 요청으로 보내는 것은 Preflight라고 부른다. 
			- 이 예비 요청에는 HTTP 메서드 중에서 `OPTIONS`  메서드가 사용된다.
			- 이 예비 요청의 역할은 브라우저 스스로 이 요청을 보내는 것이 안전한지 확인하는 것이다. 
			- ![[스크린샷 2022-12-13 오후 2.50.49.png]]
			- 우리가 fetch API를 사용해 브라우저에게 리소스를 받아오라는 명령을 내린다면, 브라우저는 서버에게 예비 요청을 먼저 보내고, 서버는 이 예비 요청에 대한 응답으로 무엇을 허용하고, 어떤 것들을 금지하고 있는지에 대한 정보를 응답헤더에 담아서 브라우저에 보내준다. 
			- 

### 내 생각과 정리 : 

- cors는 리소스의 안정성을 보장하기 위한 정책이라고 할 수 있다. 
- 다른 출처의 리소스를 가져옴으로써 발생할 수 있는 문제는 무엇인가? 
- 

### 출처(참고문헌) : 


### Link : 
