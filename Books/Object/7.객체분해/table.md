- 인지 과부화를 줄이기 위해선 정보의 양을 조절해야 한다.
- 추상화 :
  - 정보의 양을 줄이고 핵심만 남기는 작업이 곧 추상화이다.
- 분해 :
  - 큰 문제를 작은 문제로 쪼개는 것
- 이 두가지는 인간의 인지능력의 한계를 적절히 조절하고, 효율적으로 문제를 해결할 수 있게 해준다.
  - 이것이 가장 잘 적용된 분야가 바로, 소프트웨어 분야다.

## 01.프로시저 추상화와 데이터 추상화

- 모든 프로그래밍 패러다임은 추상화와 분해의 관점에서 설명할 수 있다.
- 크게 2가지 추상화 메커니즘이 있다.

  - 프로시저 추상화 : 소프트웨어가 무엇을 해야하는지를 추상화한다.
  - 데이터 추상화 : 소프트웨어가 무엇을 알아야 하는지를 추상화한다.

- 패러다임 :

  - 적절한 추상화의 윤곽을 따라 시스템을 어떤 식으로 나눌 것인지를 결정하는 원칙과 방법의 집합이다.
  - 다시 말하면 각각의 나름대로 추상화와 분해의 방법을 설명한다.
    - 프로시저 추상화는 그 나름대로,
    - 데이터 추상화는 그 나름대로.

- 2가지 패러다임 중 선택을 해야한다. 각 선택에는 차이점이 존재한다.

  - 프로시저 : 기능 분해의 길
  - 데이터 추상화 : 2가지 길이 또 존재한다.
    - 추상 데이터 타입 : 타입 추상화
    - 객체지향 : 데이터를 중심으로 프로시저를 추상화

- 프로그래밍 언어의 관점에서 객체지향의 정의 :

  - 데이터를 중심으로 데이터 추상화와 프로시저 추상화를 통합한 객체
  - 이것을 위해 클래스라는 도구를 사용한다.

  <br>

정리 :

1파트에서는 앞으로 나올 내용들의 개요를 말하는 듯 했다.  
효과적으로 프로그래밍을 해나가기 위해서 추상화와 분해 2가지를 적절히 활용해야한다.  
그것을 적절히 활용하는 패러다임이 존재하는데, 1파트에서는 3가지가 소개되었다.  
프로시저 추상화와 데이터 추상화 중에서도, 추상 데이터 타입과 객체지향이다.  
이후의 챕터에서는 프로시저 추상화 -> 추상 데이터 타입 -> 객체 지향의 순서대로 내용들을 소개하고 있다.

먼저 프로시저 추상화를 통해 프로그램을 작성하고 그것의 단점을 파악한다.  
그리고 거기서 어떻게하면 더 좋은 설계가 될 수 있는지 확인한다.  
그 다음으로 추상 데이터 타입을 설명한다.  
추상 데이터 타입을 적용하여 어떻게 똑같은 프로그램을 설계할 수 있는지 설명한다.  
마지막으로, 또 그것을 가지고 객체지향의 방법으로 다시 설계를 진행한다.

이런 과정을 통해서 각 패러다임의 장단점을 파악할 수 있는 시간이 된다.

<br>

## 02.프로시저 추상화와 기능 분해

- 프로시저 :

  - 반복적으로 실행되거나 거의 유사하게 실행되는 작업들을 하나의 장소에 모아 놓음으로써 로직을 재사용하고 중복을 방지할 수 있는 추상화 방법
  - 인터페이스만 알면 내부구현을 몰라도 사용할 수 있기 때문에, 추상화의 한 방법으로 불린다.
  - 프로시저는 정보은닉의 가능성을 제시한다. 하지만, 한계가 존재한다. 한계는 뒤에서 살펴볼 것이다.

- 하나의 메인 함수 :
  - 프로시저 방법으로 시스템을 바라보면, 시스템 전체를 하나의 메인 함수로 바라보게 된다.
  - 그리고 이 거대한 함수를 더 작은 함수로 쪼개는 작업을 진행해 나가는 것이다.

<br>

### 하향식 접근법 :

- 정의 :
  - 시스템을 구성하는 가장 최상위 기능을 정의하고, 이 최상위 기능을 좀 더 작은 단계의 하위 기능으로 분해해 나가는 방법을 말한다.
  - 가장 작은 단위의 함수까지 분해한다.
  - 각 세분화 단계는 더 구체적이게 되어야 한다.

### 급여 관리 시스템 :

```
직원의 급여를 계산한다
    사용자로부터 소득세율을 입력받는다.
        "세율을 입력하세요: "라는 문장을 화면에 출력한다.
        키보드를 통해 세율을 입력받는다.
    직원의 급여를 계산한다.
        전역 변수에 저장된 직원의 기본급 정보를 얻는다
        급여를 계산한다
    양식에 맞게 결과를 출력한다
        "이름 : {직원명}, 급여 : {계산된 금액}" 형식에 따라 출력 문자열을 생성한다
```

- 하나의 메인 함수에서 기능을 분해해 나간다.
- 기능분해방법 :
  - 기능을 중심으로 필요한 데이터를 결정한다.
  - 기능 분해라는 무대의 주연은 기능이며 데이터는 기능을 보조하는 조연의 역할에 머무른다.

이런 방법에는 어떤 문제점이 있을까?

### 하향식 기능분해의 문제점 :

1. 하나의 메인 함수라는 비현실적인 아이디어 :
   - 대부분의 시스템에서 하나의 메인 기능이란 개념은 존재하지 않는다.
   - 현대적인 시스템은 동등한 수준의 다양한 기능으로 구성된다.
2. 메인 함수의 빈번한 재설계 :
   - 새로운 기능이 추가될 때마다 매번 메인 함수를 수정해야 한다.
   - 기존의 코드를 수정하는 것은 항상 새로운 버그를 만들어낼 확률을 높인다.
3. 비지니스 로직과 사용자 인터페이스의 결합 :
   - 코드 안에서 비지니스 로직과 사용자 인터페이스 로직이 밀접하게 결합된다.
   - 인터페이스는 비교적 자주 변경되고, 비지니스 로직은 비교적 덜 변경된다.
   - 둘이 결합되어 있다는 것은, 하나가 자주 변경되면, 다른 요소도 같이 변경될 가능성이 크다는 것이다.
   - 문제는 둘 다 main 함수에 결합되어 있다.
4. 성급하게 결정된 실행순서 :
   - 시작부터 어떻게에 집중하게 만든다. 시스템이 무엇을 해야하는지에 집중하지 못하게 만든다.
   - 하향식은 계속해서 실행 순서에 주목하게 만든다. 그것을 결정하지 않는 한, 기능 분해를 진행할 수 없기 때문이다.
   - 제어구조도 자주 변경해줘야 한다.
   - 함수들은 재사용하기도 어렵다.
     - 상위 함수가 강요하는 문맥 안에서만 본인은 의미를 가진다.
     - 재사용은 본질적으로 일반성의 특징을 가진다.
       - 특정 상황에 결합되어있다면, 일반성을 띄기 어렵다.
   - 결국 문제는 결합도의 이야기다.
     - 문맥에 강하게 결합되는 것이 문제이며,
     - 시간에 강하게 결합되는 것이 문제다.
5. 데이터 변경으로 인한 파급효과 :
   - 어떤 데이터를 어떤 함수가 사용하고 있는지를 추적하기 어렵다.
     - 모든 함수를 열어 데이터를 사용하고 있는지 확인해야 한다.
   - 데이터의 변경은 참조하는 모든 함수에 퍼져나갈 것이다.
   - 데이터 변경으로 인해 발생하는 함수에 대한 영향도를 파악하는 것이 생각보다 쉽지 않다.

이렇게 단점을 듣다보니, 하향식은 정말 쓰레기처럼 느껴진다.  
하향식에는 단점만 있느냐?!
아니다. 장점도 있다. 언제 하향식 분해가 유용할까?

### 하향식 분해가 유용한 때 :

- 설계의 다양한 측면을 논리적으로 설명하고 문서화하기에 용이하다.
  - 하지만, 문서화하기 좋다는 것이 좋은 구조를 설계할 수 있는 방법과 동일한 것은 아니다.

정리하자면, 하향식 분해 설계가 문제가 되는 점은,  
결합도와 의존성이다.  
그렇다면 맨 처음으로 이것을 관리할 수 있도록 제시된 방법은 무엇이었을까?  
바로 모듈이다.

<br>

## 03. 모듈

### 정보 은닉과 모듈 할당하라

- 변경의 최소화를 위해 우선적으로 선택한 전략. 모듈화.
- 함께 변경되는 부분을 하나의 구현단위로 묶고 퍼블릭 인터페이스를 통해서만 접근하도록 만드는 것이다.

  - 변경의 방향에 맞춰서 시스템을 분해하는 것.
  - 기능을 기반으로 시스템을 분해하는 것이 아니다.

- 정보은닉 :

  - 시스템을 모듈 단위로 분해하기 위한 기본 원리
  - 자주 변경되는 부분을 인터페이스 뒤로 감춰야 한다는 것이 핵심
  - 이것이 모듈 분할의 원리다.

- 모듈은 무엇을 감추는가? :

  - 복잡성 : 추상화된 간단한 인터페이스를 제공해 모듈의 복잡성을 낮춘다.
  - 변경 가능성 : 변경가능한 것들은 내부에 감추어야 한다. 쉽게 변경되지 않을 인터페이스를 제공한다.

- 일반적으로 감추는 비밀은 무엇인가?
  - 데이터
  - 그러나 데이터만이 비밀의 대상이 되는 것은 아니다.
    - 복잡한 로직, 변경 가능성이 큰 자료구조도 비밀의 대상이 된다.

<br>

### 모듈의 장점은 무엇인가?

1. 모듈 내부가 변경되어도, 변경의 영향이 모듈 내부에 머물러 있다.
   - 데이터 변경으로 인한 파급효과를 제어할 수 있다.
   - 코드를 수정하고 디버깅하기가 더 용이하다.
2. 비즈니스 로직과 사용자 인터페이스에 대한 관심사를 분리한다.
3. 네임스페이스의 오염을 방지한다.

### 모듈의 단점은 무엇인가?

- 인스턴스의 개념을 제공하지 않는다.
  - 데이터를 독립적인 단위로 다루기가 어려워진다.
  - 이를 위해서 추상 데이터 타입이 등장했다.

<br>

## 04. 데이터 추상화와 추상 데이터 타입

### 추상 데이터 타입

- 타입 :

  - 변수에 저장할 수 있는 내용물의 종류와 변수에 적용될 수 있는 연산의 가짓수

- 추상 데이터 타입 :

  - 추상 객체의 클래스를 정의한 것으로 추상 객체에 사용할 수 있는 오퍼레이션을 이용해 규정된다.
  - 추상 데이터 객체를 사용할 때 프로그래머는 오직 객체가 외부에 제공하는 행위에만 관심을 가지며 행위가 구현되는 세부적인 사항에 대해서는 무시한다.

- 리스코프의 업적 :

  - 추상화의 수준을 한 단계 높였다.
  - 커다란 절차를 통해 사고하기 보다, 개념을 떠올린 후 그것에 알맞는 절차를 생각하도록 도왔다.

- 추상 데이터 타입을 설계하기 위한 질문 :

  - 어떤 데이터를 감추기 위해, 특정 데이터에 대한 추상화가 필요한가?

- 이렇게 추상 데이터 타입을 통해서 추상화를 진행하면, 조금 더 개념적으로 사고방식에 가까운 추상화를 진행할 수 있다.

- 하지만,

  - 데이터를 이용해 기능을 구현하는 핵심로직은 추상 데이터 타입 외부에 존재한다.
  - 예제의 경우 main에 들어가있다.
  - 여전히 데이터와 기능을 분리하는 절차적인 설계다.

- 추상데이터 타입의 기본 의도 :
  - 타입처럼 동작하는 사용자 정의 타입을 추가할 수 있게 하는 것이다.

<br>

## 05 클래스

### 클래스는 추상 데이터 타입인가?

- 명확한 의미에서 둘은 다르다.
- 핵심적인 차이 :

  - 클래스는 상속과 다형성을 지원한다.
  - 이것을 기준으로 2가지로 나뉜다.
    - 객체지향 프로그래밍
    - 객체기반 프로그래밍

- 추상 데이터 타입 :
  - 타입을 추상화한 것
- 클래스 :

  - 절차를 추상화한 것

- 추상 데이터 타입의 경우

  - 직원의 타입에 따라서 오퍼레이션이 달라진다.
  - Employee 타입은 구체적인 직원 타입을 외부에 캡슐화하고 있다.
  - 하나의 대표적인 타입이 다수의 세부적인 타입을 감추기 때문에 이를 타입 추상화라고 한다.
  - 오퍼레이션을 기준으로 타입을 묶는다.

- 객제지향의 경우
  - 타입을 기준으로 오퍼레이션을 묶는다.
  - 정규 직원과 알바 라는 두 개의 타입을 명시적으로 정의한다.
  - 결과적으로 정규 직원과 알바 각각에 대한 클래스를 정의하고, 각 클래스들이 calculatePay와 monthlyBasePay를 적절하게 구현하게 될 것이다.
  - 공통로직은 부모 클래스에 정의한다.
  - 부모클래스에 의해 메시지를 전송하면, 실제 클래스가 무엇인가에 따라 적절한 절차가 실행된다.
  - 두 인스턴스는 동일하게 보인다.
    - 실제로 내부에서 수행되는 절차는 다르다.
    - 다시 말해 절차 추상화이다.

<br>

### 변경을 기준으로 선택하라

- 타입을 기준으로 절차를 추상화하지 않았다면 그것은 객체지향 분해가 아니다.
- 객체지향인지 구분하는 방법 :

  - 클래스 내부에 인스턴스의 타입을 표현하는 변수가 있는지 살펴보는 것
  - 메서드 내에서 타입을 구분하는 방식은 객체지향이 아니다.

- 객체지향에선 조건문을 다형성으로 대체한다.
  - 클라이언트가 객체의 타입을 확인한 후 적절한 메서드를 호출하는 것이 아니라 객체가 메시지를 처리할 적절한 메서드를 선택한다.
  - 조건문 사용을 기피하는 이유는 변경 때문이다.
    - 추상 데이터 타입을 기반으로 한 Employee에 새로운 직원 타입을 추가하기 위해선, 클라이언트의 조건문을 하나씩 다 찾아 수정해야한다.
    - 객체지향의 경우 새로운 로직을 추가하기 위해 클라이언트의 코드를 수정할 필요가 없다.
- 개방폐쇄 원칙 :
  - 기존 코드에 아무런 영향도 미치지 않고 새로운 객체 유형과 행위를 추가할 수 있는 객체지향의 특성
  - 이것이 객체지향이 확장에 쉬운 구조를 가지는 이유다.
  - 객체지향은 클라이언트의 코드를 수정할 필요가 없다.
