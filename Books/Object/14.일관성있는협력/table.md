## 서문 : 

- 객체는 협력을 위해 존재한다. 
- 협력은 객체가 존재하는 이유와 문맥을 제공한다. 
- 객체지향의 목표 : 
	- 적절한 책임을 수행하는 객체들의 협력을 기반으로 결합도가 낮고 재사용 가능한 코드 구조를 창조하는 것이다. 
- 이번 장이 제시하는 문제점 : 
	- 유사한 요구사항을 계속 추가해야 하는 상황에서 각 협력이 서로 다른 패턴을 따를 경우, 전체적인 설계의 일관성이 무너진다. 
- 객체지향은 설계를 재사용할 수 있다. 
	- 하지만, 재사용을 위해선 객체들의 협력 방식을 일관성 있게 만들어야 한다. 
	- 일관성 있는 설계의 유익
		- 설계에 드는 비용 감소 
		- 코드를 이해하기 쉬워짐 
			- 특정한 문제를 유사한 방법으로 해결하고 있다는 사실을 알면 문제를 이해하는 것만으로도 코드 구조를 예상할 수 있게 된다. 

- 이번 장의 지침 : 
	- 가능하면 유사한 기능을 구현하기 위해 유사한 협력 패턴을 사용하라. 


- 이번 장을 읽기 전 내 머릿속에 떠오르는 질문 : 
	- 일관성 있는 설계란 무엇인가? 
	- 일관성 있는 설계를 해야하는 이유는 무엇인가?
	- 일관성 있는 설계를 할 때의 어려움은 무엇인가? 
	- 일관성 있는 설계를 했을 때 단점은 무엇인가? 
	- 프론트엔드에서 일관성 있는 설계를 해야하는 시점은 언제일까?
	- 프론트엔드에서 어떻게 일관성 있는 설계를 해야할까? 



## 01 핸드폰 과금 시스템 변경하기 

1번째 파트에서는 기존에 핸드폰 과금 시스템을 변경하고, 어떻게 변경되었는지에 대한 설명을 하고 있다. 


### 구간별 방식 구현하기 

- 단순히 구현을 해놓았을 때는 보이지 않던 문제가, 함께 모아놓으면 보이기 시작한다. 
	- 이 클래스들이 유사한 문제를 해결하고 있음에도 불구하고 설계에 일관성이 없다는 것이다. 
- 비일관성이 발목을 잡는 경우 
	- 새로운 구현을 추가해야 하는 상황 
		- 새로운 구현을 추가할 수록, 일관성이 계속해서 사라진다. 
	- 기존의 구현을 이해해야 하는 상황 

- 유사한 기능을 서로 다른 방식으로 구현해서는 안 된다. 
- 객체지향에서 기능을 구현하는 유일한 방법은 객체 사이의 협력을 만드는 것 뿐이다. 
	- 때문에 유지보수 가능한 시스템을 구축하는 첫걸음은 협력을 일관성 있게 만드는 것이다. 



## 02 설계에 일관성 부여하기 

- 일관성 있는 설계를 만드는 데 가장 훌륭한 조언 : 
	- 다양한 설계 경험을 익히라 
		- 풍부한 설계 경험을 가진 사람은 어떤 변경이 중요한지, 그리고 그 변경을 어떻게 다뤄야 하는지에 대한 통찰력을 가지게 된다. 
			- 어떤 위치에서 일관성을 보장해야 할 지, 일관성을 제공하기 위해 어떤 방법을 사용해야 하는지를 직관적으로 결정할 수 있다. 
	- 널리 알려진 디자인 패턴을 학습하고 변경이라는 문맥 안에서 디자인 패턴을 적용해보라 
		- 디자인 패턴은 특정한 변경에 대해 일관성 있는 설계를 만들 수 있는 경험 법칙을 모아놓은 일종의 설계 템플릿이다. 


- 협력을 일관성 있게 만들기 위해 따라야 할 기본 지침 : 
	- 변하는 개념을 변하지 않는 개념으로부터 분리하라 
	- 변하는 개념을 캡슐화하라 


> 애플리케이션에서 달라지는 부분을 찾아내고, 달라지지 않는 부분으로부터 분리시킨다. 이것은 여러 설계 원칙 중에서 첫 번째 원칙이다. 즉, 코드에서 새로운 요구사항이 있을 때마다 바뀌는 부분이 있다면 그 행동을 바뀌지 않는 다른 부분으로부터 골라내서 분리해야 한다는 것을 알 수 있다. 이 원칙은 다음과 같은 식으로 생각할 수 있다. 
> "바뀌는 부분을 따로 뽑아서 캡슐화한다. 그렇게 하면 나중에 바뀌지 않는 부분에는 영향을 미치지 않은 채로 그 부분만 고치거나 확장할 수 있다. "



- 나의 질문 : 
	- 변하는 개념을 어떻게 포착할 것인가? 실제로 나의 프로젝트 중에서 변하는 개념과 변하지 않는 개념을 어떻게 추려낼 것인지가 궁금하다. 
		- 내 생각에는 우선 프로젝트가 해결하고자 하는 문제가 무엇인지 파악하는 것이 먼저인 것 같다. 그래서 높은 수준에서 프로젝트가 가지고 있는 도메인이 무엇인지 설계를 해놓는다면, 변하는 것과 변하지 않는 것의 차이를 이해할 수 있을 것 같다. 


### 조건 로직 대 객체 탐색 

- 조건에 따라 분기되는 어떤 로직들이 있다면 이 로직들이 바로 개별적인 변경이라고 볼 수 있다. 
	- 변하는 개념을 포착하는 방법 : if else 문을 유심히 관찰하기. 조건에 따라 분기되는 로직을 찾기. 

- 객체지향에선 이런 if-else로 조건을 분기해야 하는 경우, 다형성을 통해서 처리한다. 
```java
public class Movie {
	private DiscountPolicy discountPolicy;

	public Money calculateMovieFee(Screening screening){
		return fee.minus(discountPolicy.calculateDiscountAmount(screening));
	}
}
```

- 이렇게 다형적으로 구현하기 위해서는 discountPolicy가 구체적인 객체로 변경되어야 한다. 
	- 다시 말하면, discountPolicy에 들어올 객체는 discountPolicy의 서브타입이어야 한다는 말이다. 
	- 그러니까, 이 말이 곧 리스코프치환원칙을 지킨다는 말이 되는 것이고, 리스코프 치환 원칙이 지켜질 때, 다형성을 적용할 수 있다는 말이 된다. 


- 클래스를 분리하는 기준 : 
	- 클래스는 명확히 단 하나의 이유에 의해서만 변경되어야 한다. 
	- 클래스 안의 모든 코드는 함께 변경되어야 한다. 
	- 단일 책임 원칙을 따르도록 클래스를 분리해야 한다. 

- 캡슐화의 품질 : 
	- 핵심은 훌륭한 추상화를 찾아 추상화에 의존하도록 만드는 것이다. 
	- 추상화에 대한 의존은 결합도를 낮추고 결과적으로 대체 가능한 역할로 구성된 협력을 설계할 수 있게 해준다. 



### 캡슐화 다시 살펴보기 

- 많은 사람들이 캡슐화를 생각하면 데이터 은닉을 생각한다. 하지만 캡슐화는 데이터 은닉 이상의 개념이다. 

> 설계에서 무엇이 변화될 수 있는지 고려하라. 이 접근법은 재설계의 원인에 초점을 맞추는 것과 반대되는 것이다. 설계에 변경을 강요하는 것이 무엇인지에 대해 고려하기보다는 재설계 없이 변경할 수 있는 것이 무엇인지 고려하라. 여기서의 초점은 많은 디자인 패턴의 주체인 변화하는 개념을 캡슐화하는 것이다. [GoF의 디자인 패턴]

- 캡슐화란 단순히 데이터를 감추는 것이 아니다. 
	- 소프트웨어 안에서 변할 수 있는 모든 '개념'을 감추는 것이다. 

> 캡슐화란 변하는 어떤 것이는 감추는 것이다. 


- 캡슐화의 대표적인 예 : 
	- 객체의 퍼블릭 인터페이스와 구현을 분리하는 것이다. 


- 협력을 일관성 있게 만들기 위해 가장 일반적으로 사용하는 방법 : 
	- 서브타입 캡슐화와 객체 캡슐화를 조합하는 것 


- 현재까지의 글의 흐름 : 
	- 서문에서 이 장에서 다룰 것이 무엇인지 설명했다. 
	- 1파트에서 기존에는 어떤 문제가 있는지를 설명했다. 
	- 2파트에서는 현재 겪고 있는 문제를 해결하기 위해서 어떤 개념이 필요한지, 그 개념을 이론적으로 이해하기 위한 설명을 했다. 
	- 3파트에서는 문제 해결을 위한 개념으로 기존의 문제점을 해결한 사례를 보여준다. 


## 03 일관성 있는 기본 정책 구현하기 


### 변경 분리하기 

- 변하는 개념과 변하지 않는 개념을 분리하기 


### 변경 캡슐화하기 

- 규칙은 변하지 않는 것 
- 적용 조건은 변하는 것 


### 추상화 수준에서 협력 패턴 구현하기 

- 추상화 수준에 해당하는 요소만으로도 요금 계산에 필요한 전체적인 협력 구조를 설명할 수 있다. 
	- 변하는 것은 추상화 뒤에 캡슐화되어 숨겨져 있기 때문에 전체적인 협력의 구조에 영향을 미치지 않는다. 


### 구체적인 협력 구현하기 

- 변하는 부분을 변하지 않는 부분으로부터 분리했기 때문에, 변하지 않는 부분을 재사용할 수 있다. 
- 새로운 기능을 추가하기 위해 오직 변하는 부분만 구현하면 되기 때문에 원하는 기능을 쉽게 완성할 수 있다. 
- 일관성이 없을 때는 기존의 코드를 이해한 것이 다른 유사한 문제를 해결하는 코드를 이해하는 데에 도움을 주지 않았다. 
	- 하지만, 일관성 있는 협력으로 설계가 이루어지고 나서는 기존의 코드를 이해한 것만으로도, 다른 코드를 이해하는데 시간이 매우 단축된다. 


### 패턴을 찾아라 

- 지금까지 살펴본 것처럼 일관성 있는 협력의 핵심은 변경을 분리하고 캡슐화하는 것이다. 
- 변경을 캡슐화하는 방법이 협력에 참여하는 객체들의 역할과 책임을 결정한다. 
	- 이렇게 결정된 협력이 코드의 구조를 결정한다. 
	- 훌륭한 설계자가 되는 첫걸음은 변경의 방향을 파악할 수 있는 날카로운 감각을 기르는 것이다. 


> 객체지향 설계는 객체의 행동과 그것을 지원하기 위한 구조를 계속 수정해 나가는 작업을 반복해 나가면서 다듬어진다. 객체, 역할, 책임은 계속 진화해 나가는 것이다. 협력자들 간에 부하를 좀 더 균형 있게 배분하는 방법을 새로 만들어내면 나눠줄 책임이 바뀌게 된다. 만약 객체들이 서로 통신하는 방법을 개선해냈다면 이들 간의 상호작용은 재정의돼야 한다. 이 같은 과정을 거치면서 객체들이 자주 통신하는 경로는 더욱 효율적이게 되고, 주어진 작업을 수행하는 표준 방안이 정착된다. 협력 패턴이 드러나는 것이다 












