- 프로토타입 기반 언어에서는 어떤 객체를 원형(prototype)으로 삼고 이를 복제(참조) 함으로써 상속과 비슷한 효과를 얻는다. 


## 01 프로토타입의 개념 이해 

- 생성자 함수를 new 연산자와 함께 호출할 때 일어나는 일 : 
	- Constructor에서 정의된 내용을 바탕으로 새로운 인스턴스가 생성된다. 
	- 이때 Instance에는 `__proto__`라는 프로퍼티가 자동으로 부여되는데, 
	- 이 프로퍼티는 Constructor 의 prototype이라는 프로퍼티를 참조한다. 
- 프로토타입의 핵심 : 
	- prototype이라는 프로퍼티와 `__proto__`의 관계 
	- `__proto__`는 객체다.

```javascript
const Person = function(name){
	this._name = name;
}

Person.prototype.getName = function(){
	return this._name;
}

const suzi = new Person('Suzi')
suzi._proto_.getName(); // undefined

Person.prototype === suzi.__proto__ // true
```

- this는 왜 undefined가 나오는걸까? 
- this가 바인딩하는 대상이 잘못 지정되었기 때문이다. 
- getName 함수 내부에서의 this는 thomas가 아니라 thomas._proto_라는 객체가 되는 것이다. 

- `__proto__`를 생략하고 호출하기 
	-  `__proto__`를 생략하지 않으면 this는 suzi._proto_를 가리키지만, 이를 생략하면 suzi를 가리킨다. 

- `__proto__` 프로퍼티는 생략 가능하도록 구현돼 있기 때문에 생성자 함수의 Prototype에 어떤 메서드나 프로퍼티가 있다면 인스턴스에서도 마치 자신의 것처럼 해당 메서드나 프로퍼티에 접근할 수 있게 된다. 

### 6.1.2 constructor 프로퍼티 

- 생성자 함수의 프로퍼티인 prototype 객체 내부에는 constructor라는 프로퍼티가 있다. 
	- 이 프로퍼티는 단어 그대로 원래의 생성자 함수(자기 자신)를 참조한다. 
	- 이런 프로퍼티를 가지고 있는 이유는 무엇일까? 
		- 인스턴스로부터 그 원형이 무엇인지 알 수 있는 수단이 된다. 
	
```javascript
const arr = [1,1]
arr.constructor === Array // true 
```

- constructor를 변경하더라도 참조하는 대상이 변경될 뿐 이미 만들어진 인스턴스의 원형이 바뀐다거나 데이터 타입이 변하는 것은 아니다. 
	- 어떤 인스턴스의 생성자 정보를 알아내기 위해서 constructor 프로퍼티에 의존하는 게 항상 안전하지는 않다. 


## 프로토타입 체인 

### 6.2.1 메서드 오버라이드 

- 오버라이드 : 메서드 위에 메서드를 덮어씌웠다. 
	- 원본을 제거한 그림 x. 원본이 그대로 있는 상태에서 다른 대상을 그 위에 얹는 이미지를 떠올리면 정확하다. 
	- 교체의 그림이 아니라는 사실을 기억하기. 교체하게 되면 원본에는 더 이상 접근할 수 없는 형태가 된다. 하지만 원본은 유지한 상태에서 그 위에 덮어쓴 상태이기 때문에 원본에 접근할 수 있는 방법도 존재하는 것이다. 

### 6.2.2 프로토타입 체인 

어떤 데이터의 `__proto__`프로퍼티 내부에 다시 `__proto__` 프로퍼티가 연쇄적으로 이어진 것을 프로토타입 체인이라고 하고, 이 체인을 따라가며 검색하는 것을 프로토타입 체이닝이라고 한다. 


### 6.2.3 객체 전용 메서드의 예외사항 

어떤 생성자 함수를 사용하던지, prototype은 반드시 객체이기 때문에 Object.prototype이 언제나 프로토타입 체인의 최상단에 존재하게 된다. 따라서 객체에서만 사용할 메서드는 다른 여느 데이터 타입처럼 프로토타입 객체 안에 정의할 수가 없다. 

때문에 Object안에서 스태틱한 방식으로 정의된 메서드들은 일반적인 방식인 `instance.freeze()`처럼 사용할 수 없다. 왜냐하면 이 Object 생성자 함수와 인스턴스 사이에 this를 연결할 수 없기 때문이다. 그래서 결국에 Object에서만 사용할 수 있도록 정의된 메서드들은(스태틱 메서드) `Object.freeze(instance)` 와 같이 인스턴스를 인자로 넘겨주는 방식을 통해서 사용하게 된다. 


---

## 질문 : 

- 정적 메서드란 무엇인가? (p155)
- 프로토타입이란 무엇인가? 
	- 프로토타입이란 일종의 객체이다. 그런데 이 객체가 담당하는 일이란 공통된 속성을 부여할 수 있는 템플릿 같은 역할을 하는 것이다.  
- 프로토타입체인이란 무엇인가? 이것은 어떻게 동작하는가? 
- 프로토타입 체인시 가장 가까운 메서드를 호출하는 이유는 무엇인가? 
	- 프로토타입 체인이 동작하는 방식 때문에 그렇다. 프로토타입 체인은 메서드나 프로퍼티에 접근하려고 할 때, 접근된 인스턴스로부터 해당 프로퍼티가 존재하는지 확인 후, 존재하지 않으면 상위 프로토타입에는 존재하는지 찾아올라가는 방식으로 이루어진다. 그래서 최상단에 존재하는 프로토타입에 접근하기 전에 해당 메서드가 정의되어있는 경우라면, 그 메서드를 호출하고, 존재하지 않는다면 최상단의 프로토타입에 존재하는 메서드를 호출한다. 그런데 만약 최상단의 프로토타입에도 존재하지 않는다면 그때는 undefined를 반환한다. 

- 자바스크립트에서는 왜 모든 것이 객체로 연결되어 있을까? 객체와 연결되도록 설계한 이유?
	- 값을 처리하는 방법에 있어서 일관된 방법을 제공하기 위해서이다. 모든 값에서 공통적으로 사용할 수 있는 메서드를 제공함으로써, 처리방식의 일관성을 더할 수 있게 되었다. 예를 들어서, `toString()`같은 메서드를 생각해 볼 수 있는데, 해당 메서드를 타입의 종류와 관계없이 사용할 수 있다는 점에서 일관성을 유지하는데에 도움이 된다. 
- 객체 한정 메서드들을 Object.prototype이 아닌 Object에 직접 부여할 수 밖에 없었던 이유는 무엇인가? 
	- Object.prototype이 여타의 참조형 데이터뿐 아니라 기본형 데이터조차 `__proto__`에 반복 접근함으로써 도달할 수 있는 최상위 존재이기 때문이다. 이것이 문제가 되는 것은 기본형 데이터에서 참조형의 메서드를 사용하는 것이 잘못된 사용법이 될 수 있는 가능성이 생기기 때문이다. 
- [[js는 왜 프로토타입 시스템을 선택한 것일까?]] 
- [[프로토타입과 dunder 프로토는 어떤 차이가 있는가?]]
- [[Object.create()를 통해서 새로운 객체를 생성하는 것과, constructure 함수를 통해서 생성하는 것은 어떤 차이가 존재하는가?]]
- [[new 키워드를 통해서 인스턴스를 생성할 때 일어나는 일은 무엇인가?]] 