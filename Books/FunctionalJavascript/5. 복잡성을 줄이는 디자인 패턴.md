
- 함수형은 에러도 깔끔하게 잘 처리한다. 
- functor : 함수 매핑이 가능한 단순 자료형을 생성한다. 
- monad : 다양한 방식으로 에러를 처리하는 로직이 들어있다. 
	- 수학분야의 범주론에서 비롯된 결과물이다. 
	- 이 책에선 범주론에 대해서는 다루지 않을 것이다. 


## 5.1 명령형 에러 처리의 문제점 

- 명령형은 대부분 try-catch 구문으로 예외를 처리한다. 
- try 영역에는 에러가 발생할 가능성이 있는 구문을 넣어둔다. 

### 5.1.2 함수형 프로그램은 왜 예외를 던지지 않을까? 

예외를 던지는 함수의 특징 : 
- 다른 함수형 장치처럼 합성이나 체이닝을 할 수 없다.
- 예외를 던지는 행위는 함수 호출에서 빠져나갈 수멍을 찾는 것이므로 단일한, 예측 가능한 값을 지향하는 참조 투명성 원리에 위배된다. 
- 예기치 않게 스택이 풀리면 함수 호출 범위를 벗어나 전체 시스템에 영향을 미치는 부수효과를 일으킨다. 
- 에러를 조치하는 코드가 당초 함수를 호출한 지점과 동떨어져 있어서 비지역성 원리에 위배된다. 


### 5.1.3 null 체크라는 고질병 

- 함수가 null을 반환하면 받는 함수는 null을 체크해야하는 부담을 떠안는다. 
- 더 나은 방법은 없을까? 



## 5.2 더 나은 방안 : 함수자 (Functor)

- 기본 아이디어 : 잠재적으로 위험한 코드 주위에 안정망을 설치하는 것 
- 위험한 코드를 감싼다는 개념은 그대로 가져간다. 
	- try-catch 블록을 제거할 수 있다. 
		- 이것이 명령형과의 차이점이다. 

### 5.2.1 불안전한 값을 감쌈 

- 값을 감싸는 행위는 함수형 프로그래밍의 기본 디자인 패턴이다. 
	- 값을 안전하게 다루고 프로그램의 불변성이 지켜지도록 직접적인 접근을 차단하는 것이다. 
- 이렇게 감싼 값에 접근하는 유일한 방법은 연산을 컨테이너에 매핑하는 것이다. 
	- 예시 :
		- 맵을 배열에 적용할 때, 배열이 바로 값을 감싼 컨테이너에 해당한다. 
		- 배열이 아니더라도 컨테이너가 될 수 있는 것은 많다. 

- 함수형에서 맵은 함수 그 이상, 이하도 아니다. 
- 함수는 반드시 동일한 입력을 동일한 결과에 매핑해야 한다.
	- 참조투명성의 사상

```javascript
class Wrapper {
	constructor(value){
	this._value = value;
	}

	// map :: (A->B) -> A -> B
	map(f){
		return f(this._value);
	}

	toString(){
		return 'Wrapper (' + this._value + ')'
	}
}

// wrap :: A -> Wrapper(A)
const wrap = (val) => new Wrapper(val);
```

- 요점 : 
	- 에러가 날지 모를 값을 래퍼 객체로 감싼다는 것 
		- 에러가 날지 모르는 값을 왜 래퍼로 감싸는 것일까? 
	- 컨테이너에 값이 들어가면 절대 그 값을 직접 조회/변경할 수 없다. 
		- 값을 얻기 위해서는 identity 함수를 사용해야한다. 

```javascript
const wrapperValue = wrap('Get Functional')
wrappedValue.map(R.identity); // 'Get Functional'
```

- 이런 단순한 아이디어 덕분에 컨테이너 안에 보호된 값을 얻고 싶은 코드는 무조건 Wrapper.map 을 통해서만 값을 얻도록 만들 수 있다. 
	- to be able to reach into the container 
- 예제에서 볼 수 있듯이 어떤 콘텍스트로 감싼, 보호된 값을 얻으려면 반드시 어떤 함수를 이 콘텍스트에 적용할 수 밖에 없다. 
	- 직접 함수를 호출하지는 못한다. 그래서 설사 에러가 나더라도 그 뒷일은 구체화한 래퍼 형식에 넘길 수 있다. 즉, 함수를 호출하기 전에 null, 빈 문자열, 음수 등을 체크할 수 있다. 
		- 이런 이유로 래퍼를 감싼다는 것인 것 같다. 

- fmap 함수 
```javascript
fmap :: (A -> B) -> Wrapper[A] -> Wrapper[B]
fmap(f){
	return new Wrapper(f(this._value)) //  변환된 값이 호출부에 반환되기 전에 컨테이너로 감싸준다.
}
```
- fmap은 주어진 함수를 콘텍스트로 감싼 값에 적용하는 방법이 구현된 함수이다.
	- 먼저 컨테이너를 열고 그 안에 보관된 값에 주어진 함수를 적용한 다음, 그 결과를 동일한 형식의 새 컨테이너에 ㄷ넣고 


---

## 내 생각 정리 : 

- 에러가 날지 모르는 값을 래퍼로 감싼다는 말이 잘이해가 안되었다.(165p)
	- 해당 내용에 대해서 166페이지에 나와있었던 것 같다. 
	- 말인즉, 에러가 날지 모르는 값은 래퍼로 감싸져 있기 때문에 해당 값에 직접 접근할 수 있는 방법이 없다. 만약 그 값에 접근해서 해당 값으로 함수를 호출하고 싶으면 그 함수를 래퍼에 넘겨주어야 한다. 덕분에 이 함수가 호출되기 전에, null, 빈문자열, 음수등을 체크할 수 있게 되는 것이다. 

