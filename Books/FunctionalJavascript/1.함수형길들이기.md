# 1.함수형 길들이기

> 객체지향은 가동부를 캡슐화하여 코드의 이해를 돕는다.
> 함수형 프로그래밍은 가동부를 최소화하여 코드의 이해를 돕는다.

- 자바스크립트는 조금만 시간이 지나도 관리하기가 힘들어진다.
- 질문해봐야 할 어플리케이션의 설계요소 :
  - 확장성 : 추가 기능을 지원하기 위해 계속 코드를 리팩터링해야 하는가?
  - 모듈화 용이성 : 파일 하나를 고치면 다른 파일도 영향을 받는가?
  - 재사용성 : 중복이 많은가?
  - 테스트성 : 함수를 단위 테스트하기 어려운가?
  - 헤아리기 쉬움 : 체계도 없고 따라가기 어려운 코드인가?
- 1장에선 FP가 무엇인지, 왜 중요한지를 설명하겠다.

## 1.1 함수형 프로그래밍은 과연 유용한가?

- FP는 요즘 각광받고 있다.
- 자바스크립트에 FP를 도입하기에도 적합하다.
- JS를 FP로 작성하면 많은 문제가 해결된다.
- 함수형은 프레임워크나 도구가 아니다.
  - 함수형은 사고방식이다.

## 1.2 함수형 프로그래밍이란?

- 함수형 프로그래밍이란 :
  - 함수 사용을 강조하는 소프트웨어 개발 스타일이다.
  - 단순히 함수를 사용하는 것과는 다른 문제이다.
- 진정한 목표 :
  - 부수효과를 방지한다.
  - 상태 변이를 감소시킨다.
    - 이를 위해 데이터의 제어 흐름과 연상을 추상화한다.

```javascript
document.querySelector("#msg").innerHTML = "<h1>Hello World</h1>"
```

- 이 예제는 하드코딩되어있다.
  - 달라지는 부분만 매개변수로 만들어보자.

```javascript
function printMessage(elementId, format, message) {
  document.querySelector(
    `#${elementId}`
  ).innerHTML = `<${format}>${message}</${format}>`
}

printMessage("msg", "h1", "Hello World")
```

- 더 나아지긴 했지만, 재사용 가능하진 않다.
- 함수를 매개변수화하는 다른 차원의 과정을 떠올려야 한다.

```javascript
var printMessage = run(addToDom("msg"), h1, echo)

printMessage("Hello World")
```

- 작은 함수들을 재료로 새로운 함수를 만들어낸다.
- 함수형이 따르는 기본 원리 :
  - 재사용성과 믿음성이 좋은 더 작은 조각들로 프로그램을 나눈다.
  - 전체적으로 헤아리기 쉬운 형태의 프로그램으로 다시 조합한다.
- 함수형의 기본 개념
  - 선언적 프로그래밍
  - 순수함수
  - 참조 투명성
  - 불변성

### 1.2.1 함수형 프로그래밍은 선언적

- 함수형 프로그래밍은 선언적 프로그래밍 패러다임에 속한다.
- 내부적으로 코드를 어떻게 구현했는지, 데이터는 어떻게 흘러가는지 밝히지 않은 채 연산/작업을 표현하는 사상이다.
- 명령형 프로그래밍
  - 컴퓨터에게 원하는 작업을 어떻게 하는지 상세히 알려준다.
- 선언적 프로그래밍
  - 서술부와 평가부를 분리한다.
  - 제어 흐름이나 상태 변화를 특정하지 않고도 프로그램 로직이 무엇인지를 표현식으로 나타낸다.
- 람다표현식 : 익명함수를 말하는 것 같다.
- 함수형 프로그래밍이 지향하는 것
  - 무상태성, 불변성
  - 상태를 두지 않으려면 부수효과와 상태변이를 일으키지 않는 순수함수를 사용해야 한다.

<br>

### 1.2.2 순수함수와 부수효과

- 순수함수의 특성 :
  - 주어진 입력에만 의존할 뿐, 평가 도중 또는 호출 간 변경될 수 있는 숨겨진 값이나 외부 상태와 무관하게 작동한다.
  - 전역 객체나 레퍼런스로 전달된 매개변수를 수정하는 등 함수 스코프 밖에서 어떠한 변경도 일으키지 않는다.
- 명령형에서는 변수가 다른 구분에서 값이 변하는게 일반적이다.

```javascript
let counter = 0
function increment() {
  return ++counter
}
```

- 이 함수는 외부 변수 counter를 읽고 수정하므로 불순하다.

- 부수효과가 발생하는 다양한 상황 :

  - 전역 범위에서 변수, 속성, 자료구조를 변경
  - 함수의 원래 인수 값을 변경
  - 사용자 입력을 처리
  - 예외를 일으킨 해당 함수가 붙잡지 않고 그대로 예외를 던짐
  - 화면 또는 로그 파일에 출력
  - HTML 문서, 브라우저 쿠키, DB에 질의

- 함수형 프로그래밍은 모든 상태 변이를 근절하자는 것이 아니다.
  - 상태 변이를 줄이고 관리할 수 있는 프레임워크를 제공하여 순수/불순 함수를 구분하자는 것이다.

```javascript
function showStudent(ssn) {
  let student = db.find(ssn)
  if (student !== null) {
    document.querySelector(
      `#${elementId}`
    ).innerHTML = `${student.ssn},${student.firstName},${student.lastname}`
  } else {
    throw new Error("학생을 찾을 수 없습니다!")
  }
}

showStudent("444-44-4444")
```

- 위 코드를 분석해보자.

  - 변수 db를 통해 데이터에 접근한다. 이는 외부변수다. 이 변수가 변경되면 호출단계마다 결괏값이 달라질 것이다. 프로그램의 무결성이 깨어지게 될 것이다.
  - elementId 값이 언제라도 변할 수 있는 전역 변수다.
  - HTML 요소를 직접 고친다. DOM은 전역변수다.

- 순수함수는 서명에 정규 매개변수를 빠짐없이 명시하므로 코드를 이해하고 사용하기가 쉽다.

- 위 코드를 개선해보자. 우선 2가지만.
  - 긴 함수를 하나의 목적을 가진 짧은 함수로 각각 분리한다.
  - 함수가 해야 할 작업에 필요한 인수를 모두 명시하여 부수효과 개수를 줄인다.

```javascript
let find = curry((db, id) => {
  let obj = db.find(id)
  if (obj === null) {
    throw new Error("객체를 찾을 수 없습니다!")
  }
  return obj
})

let csv = student => `${student.ssn}, ${student.firstname}, ${student.lastname}`
let append = curry((selector, info) => {
  document.querySelector(selector).innerHTML = info
})
```

- 개선된 코드를 살펴보자.

  - 재사용 가능한 컴포넌트가 3개로 나뉘어 코드가 훨씬 더 유연해졌다.
  - 잘게 나뉜 함수를 재사용하면 신경써서 관리할 코드크기가 줄어든다.
  - 고수준 단계별로 명확하게 보여주는 선언적 스타일을 따르므로 코드 가독성이 향상된다.
  - HTML 객체와의 상호작용을 자체 함수로 빼내어 순수하지 않은 로직을 순수함수에서 배제했다.

- 참조투명성 :
  - 함수가 일관된 반환값을 보장하게 하는 것
  - 이것이 순수함수 본연의 특징이다.

<br>

### 1.2.3 참조 투명성과 치환성

- 순수성 :
  - 함수의 인수와 결괏값 사이의 순수한 매핑 관계를 의미한다.
- 어떤 함수가 동일한 입력을 받았을 때 동일한 결과를 내면 이를 참조 투명한 함수라고 한다.

```javascript
let counter = 0
function increment() {
  return ++counter
}

let increment = counter => counter + 1
```

- 이런 함수는 테스트하기도 쉽다. 그리고 전체 로직을 파악하는 것도 쉽다.

- 만약 [func1, func2, func3, ...] 이 함수들이 모두 순수함수면 이들이 내는 결과를 바꾸지 않고,
- [val1, val2, val3, ...]과 같이 나열할 수 있다.

```javascript
let input = [80, 90, 100]
let average = arr => divide(sum(arr), size(arr))
average(input) // -> 90
```

- sum과 size는 둘 다 참조 투명한 함수이기 때문에 이 표현식은 다음과 같이 입력값을 넣어 쉽게 바꿀 수 있다.

```javascript
let average = divide(270, 3) // -> 90
```

```javascript
let sum = (total, current) => total + current
let total = arr => arr.reduce(sum)
let size = arr => arr.length
let divide = (a, b) => a / b
let average = arr => divide(total(arr), size(arr))
average(input) // -> 90
```

- 순수함수형 프로그래밍의 밑바탕에는 수학적 사고방식이 내재되어 있다.
- 부수효과가 있는 함수라면 이런 일이 가능하지 않다.

<br>

### 1.2.4 불변 데이터 유지하기

- 배열이나 객체는 불변이 아니기 때문에, 부수효과의 여지가 남아있다.

```javascript
const sortDesc = arr => {
  arr.sort((a, b) => b - a)
}
```

- 위 코드는 언뜻보면 좋은 코드같다.
- 하지만, Array.sort는 원본 레퍼런스가 가리키는 배열의 원소를 정렬하는 부수효과를 일으킨다.
- 함수형 프로그래밍의 기본 원리들에 대한 정의 :

  - 함수형 프로그래밍은, 외부에서 관찰 가능한 부수효과가 제거된 불변 프로그램을 작성하기 위해 순수함수를 선언적으로 평가하는 것이다.

- 함수를 순수 연산의 관점에서 데이터를 절대 변경하지 않는 고정된 작업 단위로 바라본다면, 확실히 잠재적인 버그는 줄어들게 될 것이다.
  - 작업단위.

<br>

## 1.3 함수형 프로그래밍의 좋은 점

- 이 장에서는 함수형 인지력을 향상시키기 위한 핵심 기법 몇 가지를 소개한다.
- 함수형으로 개발하면 좋은 점 :
  - 간단한 함수들로 작업을 분해한다.
  - 흐름 체인으로 데이터를 처리한다.
  - 리액티브 패러다임을 실현하여 이벤트 중심 코드의 복잡성을 줄인다.

<br>

### 1.3.1 복잡한 작업을 분해하도록 유도

- 함수형 프로그래밍을 고수준에서 보면 다음과 같다.
  - 분해, 합성간의 상호작용이다.
  - 분해 : 프로그램을 작은 조각들로 쪼갬
  - 합성 : 작은 조각들을 다시 합침
- 이런 duality 덕분에 함수형은 모듈적으로 효율적으로 동작한다.
- 작업 단위는 곧 함수 자신이다.

<br>

**분해(모듈화, 단일화) :**

- 함수형 사고를 시작하는 법

  - 어떤 작업을 논리적 하위작업으로 분행하는 행위부터 시작하기.

- 필요하면 나뉘어진 하위 작업을 더 단순한 순수함수로 분해할 수 있다.
- 함수형에서 모듈화는 단일성의 원리와 밀접한 관련이 있다.
  - 모름지기 함수는 저마다 한 가지 목표만 바라봐야 한다는 사상이다.
    - 이것은 객체지향에서 높은 응집도와 비슷한 개념이라고 볼 수 있을까? 객체지향에서 높은 응집도를 가진 객체는 단 하나의 변경의 이유를 갖는다. 이와 비슷하게 단일성의 원리에 의해서 함수는 한 가지 목표만 바라본다.

**합성 :**

- run은 이 책에서 가장 중요한 합성이라는 기법을 구현한 함수다.
  - 두 함수를 합쳐 새로운 결과를 다음 함수에 밀어넣는 새로운 함수.

```
f*g = f(g(x))
```

- compose 함수는 함수형 어플리케이션의 모듈성과 재사용성을 학습하는데 매우 각별한 의미를 지닌다.
- compose 는 다른 함수를 인수로 받기 때문에 고계함수다.

<br>

### 1.3.2 데이터를 매끄럽게 체이닝하여 처리

- 체인은 같은 객체를 반환하는 순차적인 함수 호출이다.

```javascript
const enrollment = [
  { enrolled: 2, grade: 100 },
  { enrolled: 2, grade: 80 },
  { enrolled: 1, grade: 89 },
]

//아래는 명령형

let totalGrades = 0
let totalStudentsFound = 0
for (let i = 0; i < enrollment.length; i++) {
  let student = enrollment[i]
  if (student !== null) {
    if (student.enrolled > 1) {
      totalGrades += student.grade
      totalStudentsFound++
    }
  }
}
let average = totalGrades / totalStudentsFound // -> 90
```

이것을 분해해보자.

- 자료집합을 적절히 선택한다.
- 학생의 점수를 얻는다.
- 평균 점수를 계산한다.

- 함수 체인은 필요한 시점까지 실행을 미루는 느긋한 평가를 수행한다.

```javascript
_.chain(enrollment)
  .filter(student => student.enrolled > 1)
  .pluck("grade")
  .average()
  .value() // -> 90
```

## 1.4 마치며

- 순수함수를 사용한 코드는 전역 상태를 바꾸거나 깨뜨릴 일이 전혀 없으므로 테스트, 유지보수가 더 쉬운 코드를 개발하는 데 도움이 된다.
- 함수형 프로그래밍은 코드를 선언적으로 작성하므로 헤아리기 쉽고 전체 어플리케이션의 가독성 역시 향상된다.
  - 또 함수와 람다 표현식을 조합하여 깔끔하게 코딩할 수 있습니다.
- 여러 원소로 구성된 컬렉션 데이터는 map, reduce 같은 연산을 함수 체인으로 연결하여 물 흐르듯 매끄럽게 처리할 수 있다.
- 함수형 프로그래밍은 함수를 기본적인 구성 요소로 취급한다.
  - 이는 일급/고계함수 개념에 기반을 두며 코드의 모듈성, 재사용성을 높인다.
- 리액티브/함수형 프로그래밍을 융합하면 이벤트 기반 프로그램 특유의 복잡성을 줄일 수 있다.
