## 객체지향은 인간지향이다 

- 객체지향이 현실 세계를 반영한다는 말의 증거는 바로 "객체"이다. 
	- 기존에는 함수의 단위로 분할해 로직을 수행했다. 
	- 그 다음으로 나온 것이 객체지향이다. 온 우주는 객체들의 합으로 이루어져있다. "우리가 주변에서 사물을 인지하는 방식대로 프로그래밍을 할 수 있지 않겠는가" 하는 것이 객체지향의 출발이다. 
	- 객체지향이전에는 속성 따로, 메서드 따로의 형식으로 프로그램을 작성했었다. 하지만 이후에는 속성과 메서드를 함께 가지고 있는 객체를 중심으로 프로그램을 작성하게 되었다. 


## 객체지향의 4대 특성 - 캡! 상추다 

- 캡 : 캡슐화 Encapsulation
- 상 : 상속 Inheritance 
- 추 : 추상화 Abstraction
- 다 : 다형성 Polymorphism 

이 4가지가 객체지향의 4대 특성이다. 이것을 잘 이해하고, 기억하고 설명할 수 있다면 객체지향에 대해서 잘 이해한 것이라고 말할 수 있을 것이다. 


## 클래스 vs 객체 = 붕어빵틀 vs 붕어빵?? 


- 클래스는 뷴류의 개념이지 실체가 아니다. 객체는 실체다. 

```
클래스 : 객체 = 펭귄 : 뽀로로 = 사람 : 김연아 
```


## 추상화 : 모델링 

- 추상화의 대가는 누구일까? 일반인들에게는 피카소와 몬드리안이다. 
	- 피카소는 사람을 그대로 그린 것이 아니라, 마음속에 느껴지는 사람의 본질을 그림으로 그렸다. 
- 고대 이집트의 벽화도 상당히 추상화된 형태의 그림이다. 

> 추상 : 여러 가지 사물이나 개념에서 공통되는 특성이나 속성 따위를 추출하여 파악하는 작용 


### 추상화는 모델링이다 

- 추상화란 구체적인 것을 분해해서 관찰자가 관심 있는 특성만 가지고 재조합한 것이라고 정리할 수 있다. 

객체의 사전적 정의 : 

> 1. 전체나 집단에 상대하여 하나하나의 낱개를 이르는 말. 
> 2. <생물> 하나의 독립된 생물체, 살아가는 데에 필요한 독립적인 기능을 갖고 있다. 
> 3. <철학> 단일하고 독립적인 통일적 존재, 철학 사상의 발전 과정에서 이 통일성은 물질적, 양적 측면, 또는 정신적, 질적 측면 따위의 여러 관점에서 고찰되었다. 

필자가 내린 객체의 또 다른 정의 : 

> 객체 : 세상에 존재하는 유일무이한 사물 

> 클래스 : 분류, 집합, 같은 속성과 기능을 가진 객체를 총칭하는 개념 


- 인스턴스 : 클래스를 이용해 객체를 만들었다는 것을 강조할 때는 객체라는 표현보다는 클래스의 인스턴스(instance)라는 표현을 사용한다. 
- 객체지향의 클래스와 추상화는 어떤 연관성이 있을까? 
	- 사람이라는 클래스를 만들기 위해서는 주변에서 보이는 실체들, 즉 사람 객체들을 관찰해서 사람 객체들이 가진 공통된 특성을 찾게 된다. 
- 컨텍스트(어플리케이션의 경계) : 클래스의 특징을 어디까지 나열하고 정리해야할까에 대한 의문으로부터 나온 개념이다. 이것의 경계를 알기 위해서 던져야하는 질문은 다음과 같다. 
	- 내가 창조하려는 세상은 어떤 세상인가? => 내가 만들고자 하는 애플리케이션은 어디에서 사용될 것인가? 
	- 병원 어플리케이션을 만들고 있다면, 사람이라는 추상적인 개념을 환자라는 조금 더 구체적인 대상으로 바꾸어 사용할 수 있을 것이다. 그리고 그에 맞게 클래스에 대한 설계도 바뀌어야 할 것이다. 
	- 때문에 어플리케이션의 경계를 어떻게 설정하느냐에 따라 클래스의 설계도 달라지는 것이다. 
- 추상화의 정의 중 중요한 부분은 "관심 영역에 대한 특성만을 가지고 재조합하는 것" 이다. 
	- it용어를 이용해 바꾼 것 : 추상화란 구체적인 것을 분해해서 관심 영역에 있는 특성만 가지고 재조합하는 것이다. 
	- 모델은 실제 사물을 정확히 복제하는 것이 아니라 목적에 맞게 관심 있는 특성만을 추출해서 표현하는 것이다. 바로 모델은 추상화를 통해 실제 사물을 단순하게 묘사하는 것이다. 

- 중요한 내용 다시 정리 
	- OOP의 추상화는 모델링이다. 
	- 클래스 : 객체 = 펭귄 : 뽀로로 
	- 클래스 설계에서 추상화가 사용된다. 
	- 클래스 설계를 위해서는 애플리케이션 경계부터 정해야 한다. 
	- 객체 지향에서 추상화의 결과는 클래스이다. 
- 추상화의 넓은 개념 
	- 상속을 통한 추상화, 구체화 
	- 인터페이스를 통한 추상화 
	- 다형성을 통한 추상화 
- 자바가 객체 지향의 추상화를 지원하는 방법 : 
	- class 키워드를 통해서 지원하고 있다. 
	- 추상화 = 모델링 = 자바의 class 키워드 


### 추상화와 T 메모리 

쥐를 추상화하여 설계해보자. 

```java 
public class Mouse {
	public String name; 
	public int age;
	public int countOfTail; 

	public void sing() {}
}
```

```java
public class MouseDriver {
	public static void main(String[] args){
		Mouse mickey = new Mouse();
		mickey.name = "미키";
		mickey.age = 85;
		mickey.countOfTail = 1;

		mickey.sing();

		micky = null;

		Mouse jerry = new Mouse();

		jerry.name = "제리";
		jerry.age = 73;
		jerry.countOfTail = 1;

		jerry.sing();
	}
}
```

- static 영역 : 
	- java.lang 패키지와 모든 클래스들(Mouse, MouseDriver)이 스태틱 영역에 배치된다. 
	- 근데 Mouse에서 name, age, countOfTail의 변수 저장 공간은 없다. 왜냐하면 이 세 개의 속성은 Mouse 클래스에 속한 속성이 아니라, Mouse 객체에 속한 속성이기 때문이다. 객체가 생성되어야만 속성의 값을 저장하기 위한 메모리 공간이 스태틱이 아닌 힙 영역에 할당된다. 

```java
Mouse mickey = new Mouse();
```
- `Mouse mickey` : Mouse 객체에 대한 참조변수 mickey를 만든다. 
- `new Mouse()` : Mouse 클래스의 인스턴스를 하나 만들어 힙에 배치한다. 
- `대입문` : Mouse 객체에 대한 주소를 참조 변수 mickey에 할당한다. 
- mickey에 null을 할당했을 때 : 
	- 그러면 이제 mickey라는 변수에서 참조하고 있던 Mouse 라는 객체의 주소값이 제거된다. 때문에 Mouse라는 객체는 더 이상 어느곳에서도 참조하지 않는 값이 되어버렸다. 이제 이 값은 가비지 컬렉터의 수집 대상이 되어버린다. 가비지컬렉터가 언제 수집할 지는 모른다. 
- 스태틱 영역이 스태틱인 이유 : 스태틱은 "고정된"이라는 뜻을 가지고 있다. 스태틱 영역에 올라간 정보는 main 메서드가 시작되기 전에 올라가서 main 메서드가 종료된 후에 내려올 정도로 스태틱 영역에 단단히 고정되어 있기 때문에 스태틱 영역이라고 한다. 


### 클래스 멤버 vs 객체멤버 = static 멤버 vs 인스턴스 멤버 

- tail의 갯수 같은 경우에는 모두 다 1개로 똑같다. 때문에, 이것을 인스턴스에서 할당하게 되는 것은 메모리 상의 값이 낭비되는 것이라고 볼 수 있다. 
	- 만약 이 값을 클래스 상에서 미리 1로 고정된 값을 지정해준다면, static 영역에서 1로 미리 저장되고, 힙 영역에서는 더 이상 이 값을 메모리 상에서 차지하지 않게 될 것이다. 

```java
public class Mouse {
	public String name; 
	public int age;
	public static int countOfTail = 1; 

	public void sing(){
		System.out.println(name + "찍찍!!!");
	}
}
```
코드를 이렇게 수정하고나면 countOfTail 속성은 T 메모리의 스태틱 영역에 단 하나의 저장 공간을 가지게 된다. 

- 정적 메서드는 언제 사용하는 것이 좋을까? 
	- 정적 메서드는 객체들의 존재 여부에 관계없이 쓸 수 있는 메서드이다. 
	- main 메서드는 항상 정적 메서드여야 한다. 


## 상속 : 재사용 + 확장 

- 객체지향에서 상속은 상위 클래스의 특성을 하위 클래스에서 상속하고 거기에 더해 필요한 특성을 추가, 즉 확장해서 사용할 수 있다는 의미이다. 
	- 객체지향에서 상속이란 일반인들이 생각하는 상속이 아닌, 확장, 세분화, 슈퍼 클래스와 서브 클래스 개념으로 이해하기 바란다. 상위 분류, 하위 분류로 이해해도 좋다. 
	- 상위클래스쪽으로 갈 수록 추상화, 일반화 되었다고 말하며, 하위 클래스 쪽으로 갈 수록 구체화, 특수화되었다고 말한다. 
	- 상속의 개념이 조직도나 계층도가 아닌 분류도라는 사실을 기억하자. 
- 상속 관계에서 반드시 만족해야 할 문장이 있다. 
	- 하위 클래스는 상위클래스이다. 
	- 조직도의 경우 
		- 아버지는 할아버지다 => 성립하지 않는다. 
		- 아들은 아버지다 => 성립하지 않는다. 
	- 분류도의 경우 
		- 포유류는 동물이다. => 성립한다. 
		- 고래는 포유류다 => 성립한다. 
		- 고래는 동물이다 => 성립한다. 
	- 이것은 객체지향의 원칙 중 LSP를 나타내는 말이다. 
- 자바에서는 inheritance가 없다.대신 extends라는 키워드가 존재한다. 

> 하위 클래스는 상위 클래스이다. 

### 상속의 강력함 

- 클래스와 객체의 작명 : 클래스는 분류스럽게, 객체 참조 변수명은 유일무이한 사물처럼 작명해야 한다. 

```java
public class 동물 {
	String myClass;

	동물(){
		myClass = "동물";
	}

	void showMe(){
		System.out.println(myClass);
	}
}
```

```java
public class 포유류 extends 동물 {
	포유류(){
		myClass = "포유류";
	}
}
```

```java
public class 조류 extends 동물 {
	조류(){
		myClass = "조류";
	}
}
```

```java
public class 펭귄 extends 조류 {
	펭귄(){
		myClass = "펭귄";
	}
}
```

- 상속한다는 것은 상위 클래스의 특성을 상속한다는 의미이지만, 부모- 자식 관계는 아니다. 
- 책에서 보여주려는 감동. 하위 클래스는 상위 클래스이다. 포유류는 동물이다. `동물 mammalia = new 포유류()` 
	- 이렇게 동물이라는 클래스로 포유류라는 클래스를 만들 수 있다는 것. 이렇게 하더라도 논리상으로 어떠한 문제가 없다는 것. 

### 상속은 is a 관계를 만족해야 한다? 

- 펭귄 Is a 동물. 
- 사실 더 정확한 표현은 is a kind of 이다. 

> 하위 클래스 Is a kind of 상위 클래스 

> 펭귄 is a kind of 조류 -> 펭귄은 조류의 한 분류이다. 

- 상속에 대해서 기억해야 할 세 가지 문장 
	- 객체 지향의 상속은 상위 클래스의 특성을 재사용하는 것이다. 
	- 객체 지향의 상속은 상위 클래스의 특성을 확장하는 것이다. 
	- 객체 지향의 상속은 is a kind of 관계를 만족해야 한다. 

### 상속과 인터페이스 

- 인터페이스는 어떤 관계를 나타내는 것일까? 
	- 인터페이스 : 구현 클래스 is able to 인터페이스 
	- 해석 : 구현 클래스는 인터페이스할 수 있다. 
	- 예제 : 고래는 헤엄칠 수 있다. 

- 상위 클래스는 하위클래스에게 특성을 상속해주고, 인터페이스는 클래스가 '무엇을 할 수 있다'라고 하는 기능을 구현하도록 강제하게 된다. 
- 상위 클래스에 특성이 많은 것이 좋을까, 인터페이스가 많은 것이 좋을까? 
	- 특성이 많고, 인터페이스가 적은 것이 가장 좋은 그림이다. 
	- 이유는 리스코프 치환원칙에 의할 때 상위 클래스에 특성이 많은 것이 좋고, 인터페이스 분리 원칙에 의해 생각해볼 때, 상위 클래스에 인터페이스가 적은 것이 좋다고 생각해 볼 수 있다.  

```java
public class 동물 {
	String myClass; 

	동물(){
		myClass = "동물";
	}

	void showMe(){
		System.out.println(myClass);
	}
}
```

```java
public interface 날수있는 {
	void fly();
}
```


```java
public interface 헤엄칠수있는 {
	void swim();
}
```

```java
public class 포유류 extends 동물 {
	포유류(){
		myClass = "포유류";
	}
}
```

```java
public class 조류 extends 동물 {
	조류(){
		myClass = "조류";
	}
}
```

```java
public class 고래 extends 포유류 implements 헤엄칠수있는 {
	고래(){
		myClass = "고래";
	}

	@Override 
	public void swim(){
		System.out.println(myClass + "수영 중. 어프!!! 어프!!")
	}
}
```


### 상속과 T 메모리 

```java
public class Animal {
	public String name;

	public void showName(){
		System.out.printf("안녕 나는 %s야. 반가워\n", name);
	}
}
```


```java
public class Penguin extends Animal {
	public String habitat;

	public void showHabitat(){
		System.out.printf("%s는 %s에 살아\n", name, habitat);
	}
}
```

```java

public class Driver{
	public static void main(String[] args){
		Penguin pororo = new Penguin();

		pororo.name = "뽀로로";
		pororo.habitat = "남극";

		pororo.showName();
		pororo.showHabitat();

		Animal pingu = new Penguin();

		pingu.name = "핑구";

		pingu.showName();
	}

}
```

- Penguin 클래스의 인스턴스만 힙 영역에 생긴 것이 아니라 Animal 클래스의 인스턴스도 함께 힙 영역에 생긴다. 
	- 하위 클래스의 인스턴스가 생성될 때 상위 클래스의 인스턴스도 함께 생성된다. 
- pingu 변수의 참조는 Penguin이 아니라 Animal을 향하고 있다. 
	- 때문에 pingu는 Penguin의 메서드를 사용할 수 없다. 


## 다형성 : 사용편의성 

- 객체 지향에서 다형성이라고 하면 오버라이딩 혹은 오버로딩이라고 할 수 있다. 

### 오버라이딩? 오버로딩? 

- 오버라이딩과 오버로딩 구분하기 
	- 인공위성에서 내려볼 때 오버라이딩된 경우에는 맨 위에 올라탄 존재만 보인다. 오버로딩된 경우에는 그 위에 적재된 요소들 전부 다가 보인다. 

```java
public class Animal {
	public String name;

	public void showName(){
		System.out.printf("안녕 나는 %s야. 반가워\n", name);
	}
}
```


```java
public class Penguin extends Animal{
	public String habitat; 

	public void showHabitat(){
		System.out.printf("%s는 %s에 살아\n", name, habitat);
	}

	//오버라이딩 - 재정의 : 상위클래스의 메서드와 같은 메서드 이름, 같은 인자 리스트 
	public void showName(){
		System.out.println("어머 내 이름은 알아서 뭐하게요?");
	}

	public void showName(String yourName){
		System.out.printf("%s 안녕, 나는%s라고 해\n", yourName, name);
	}
}
```

```java
public class Driver{
	public static void main(String[] args) {
		Penguin pororo = new Penguin();

		pororo.name = "뽀로로";
		pororo.habitat = "남극";

		pororo.showName(); // 어머 내 이름은 알아서 뭐하게요?
		pororo.showName("초보람보"); // 초보람보 안녕, 나는 뽀로로라고 해. 
		...
	}
}
```


## 캡슐화 : 정보은닉 

### 객체 멤버의 접근 제어자 





--- 

- 붕어빵틀과 붕어빵을 클래스와 객체의 관계로 비유하는 것의 잘못된 점은 분류에 있을 것 같다. 클래스는 엄밀히 말하면 넓은 범위의 분류를 뜻하는 것인데, 붕어빵 틀은 오직 붕어빵을 찍어내는 틀에 불과하다는 것이다. 
- 상위 클래스를 상속받은 하위클래스를 통해서 인스턴스를 생성할 때, T 메모리에 어떤 일이 일어날까? 
	- 힙 영역에 하위 클래스의 인스턴스만 생성되는 것이 아니라, 상위 클래스의 인스턴스도 함께 생성된다. 


- 책을 읽다가 느낀 재미있는 표현 : 

> 컴퓨터 프로그램을 만드는 과정에서 개발자는 바로 해당 애플리케이션의 창조자가 된다. 그래서 우리는 객체 지향 프로그래밍을 할 때 클래스를 먼저 설계하게 된다. 

