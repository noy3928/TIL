# 3.1 함수

- 함수 : 어떤 입력을 받아서 자신을 호출한 코드 쪽에 출력값을 반환할 수 있는 재사용 가능한 코드 블록.


```kotlin
import kotlin.math.PI

fun circleArea(radius: Double): Double {
	return PI*radius*radius
}

fun main() {
	print("Enter radius: ")
	val radius = readLine()!!.toDouble()
}

```

- fun 키워드는 컴파일러에게 함수 정의가 뒤따라온다는 사실을 알려준다. 
- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.

```kotlin
fun increment(n: Int):Int {
	return n++
}
```

- 값에 의한 호출(call by value) : 
	- 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻. 특히 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다는 뜻이다. 하지만 파라미터가 참조라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다. 

```kotlin
fun increment(a: IntArray): Int {
	return ++a[0]
}

fun main() {
	val a = intArrayOf(1,2,3)
	println(increment(a)) //2
	println(a.contentToString())  // [2,2,3]
}
```

- 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서 파라미터 타입을 추론하지 못한다. 
- 반환 타입은 추론이 가능하긴하지만, 여전히 명시해주는 것이 좋다.
	- 반환 타입은 일종의 문서화 역할을 한다. 함수 정의의 첫 줄만 보고도 함수가 만들어내는 값이 무엇인지 바로 알 수 있게 해준다. 
- 반환 타입을 생략하는 경우 
	- 첫번째 : 유닛 타입을 반환하는 경우. 유닛은 자바 void에 해당하는 코틀린 타입이다. 함수가 의미 있는 반환값을 돌려주지 않는다는 뜻이다. 
		- 만약 반환값 타입을 지정하지 않으면 코틀린은 여러분이 Unit 함수를 정의한다고 가정한다. 
	- 두번째 : 식이 본문인 함수(expression-body). 어떤 함수가 단일 식으로만 구현될 수 있다면 return 키워드와 블록을 만드는 중괄호{}를 생략하고 다음과 같은 형태로 함수를 작성할 수 있다. `fun circleArea(radius:Double):Double = PI*radius*radius`

## 3.1.2 위치 기반 인자와 이름 붙은 인자

- 코틀린에서는 위치 기반 인자와 이름 붙은 인자 2가지 방법을 사용한다. 
	- 이름붙은 인자는 위치가 아니라 파라미터의 이름을 명시함으로써 인자를 전달하는 방식이다. 
	- 이름붙은 인자를 사용하면 인자의 실제 순서는 중요하지 않다. 

## 3.1.3 오버로딩과 디폴트 값

- 코틀린에서도 오버로딩은 이용가능하다. 다만 컴파일러가 어떤 함수를 호출해야 할지 구분할 수 있도록 오버로딩한 함수의 파라미터 타입이 모두 달라야 한다.  
	- 반환값이 다른것은 다른 함수로 여기지 않는다. 
- 오버로딩 해소(overloading resolution)
	- 1. 파라미터의 개수와 타입을 기준으로 호출할 수 있는 모든 함수를 찾는다.
	- 2. 덜 구체적인 함수를 제외시킨다. 규칙 1에서 선택한 후보 목록에서 어떤 함수의 파라미터 타입이 다른 함수의 파라미터 타입의 상위 타입인 경우 이 함수는 다른 함수보다 덜 구체적인 함수다. 덜 구체적인 함수가 모두 제외될 때까지 이 단계를 반복한다. 
	- 3. 후보가 하나로 압축되면 이 함수가 호출할 함수다. 후보가 둘 이상이면 컴파일 오류가 발생한다. 

- 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다. 디폴트값이 있으면 인자 개수가 가변적이어서 오버로딩 해소가 복잡해질 수 있다. 


## 3.1.4 vararg 

- 인자의 개수가 정해지지 않은 경우에 사용할 수 있는 기능이 있다. 파라미터 정의 앞에 vararg 변경자를 붙이면 된다. 

```kotlin 
fun printSorted(vararg items: Int){
	items.sort()
}

fun main(){
	printSorted(6,2,10,1)
}
```

## 3.1.5 함수의 영역과 가시성

- 코틀린 함수의 3가지 구분
	- 파일에 직접 선언된 최상위 함수
	- 어떤 타입 내부에 선언된 멤버 함수
	- 다른 함수 안에 선언된 지역 함수

- 기본적으로 파일내 선언된 최상위 함수는 public이다. 같은 디렉터리 안에 다른 파일에서 사용할 수 있다. 
- 경우에 따라서는 프로젝트의 나머지 부분으로부터 구현 상세 내용을 숨겨서 보호하고 싶을 때가 있다. 이렇게하면 함수의 영역을 줄일 수 있고, 코드에서 함수가 쓰일 수 있는 위치를 제한할 숭 ㅣㅆ다.
	- private이나 internal 이라는 키워드를 붙일 수 있다. 
	- 최상위 함수를 private로 정의하면 함수가 정의된 파일 안에서만 해당 함수를 볼 수 있다. 


- jvm이 볼 때 최상위 main() 함수는 코틀린 파일마다 자동으로 만들어지는 특별한 파사드 클래스의 정적 멤버라는 사실을 설명했다. 지역 함수의 경우에도 코틀린 컴파일러는 비슷한 트릭을 써서 지역 함수를 정의하며, 