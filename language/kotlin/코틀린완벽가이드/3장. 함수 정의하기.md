# 3.1 함수

- 함수 : 어떤 입력을 받아서 자신을 호출한 코드 쪽에 출력값을 반환할 수 있는 재사용 가능한 코드 블록.


```kotlin
import kotlin.math.PI

fun circleArea(radius: Double): Double {
	return PI*radius*radius
}

fun main() {
	print("Enter radius: ")
	val radius = readLine()!!.toDouble()
}

```

- fun 키워드는 컴파일러에게 함수 정의가 뒤따라온다는 사실을 알려준다. 
- 코틀린 함수 파라미터는 무조건 불변이다. 즉, 함수 본문에서 파라미터 값을 변경하면 컴파일 오류가 발생한다.

```kotlin
fun increment(n: Int):Int {
	return n++
}
```

- 값에 의한 호출(call by value) : 
	- 파라미터 값에 호출하는 쪽의 인자를 복사한다는 뜻. 특히 호출 인자로 전달한 변수를 변경해도 호출된 함수 내부의 파라미터 값에는 영향이 없다는 뜻이다. 하지만 파라미터가 참조라면 호출한 쪽의 데이터는 그대로 남아있고 이 데이터에 대한 참조만 복사된다. 

```kotlin
fun increment(a: IntArray): Int {
	return ++a[0]
}

fun main() {
	val a = intArrayOf(1,2,3)
	println(increment(a)) //2
	println(a.contentToString())  // [2,2,3]
}
```

- 파라미터에는 항상 타입을 지정해야 한다. 컴파일러는 함수 정의에서 파라미터 타입을 추론하지 못한다. 
- 반환 타입은 추론이 가능하긴하지만, 여전히 명시해주는 것이 좋다.
	- 반환 타입은 일종의 문서화 역할을 한다. 함수 정의의 첫 줄만 보고도 함수가 만들어내는 값이 무엇인지 바로 알 수 있게 해준다. 
- 반환 타입을 생략하는 경우 
	- 첫번째 : 유닛 타입을 반환하는 경우. 유닛은 자바 void에 해당하는 코틀린 타입이다. 함수가 의미 있는 반환값을 돌려주지 않는다는 뜻이다. 
		- 만약 반환값 타입을 지정하지 않으면 코틀린은 여러분이 Unit 함수를 정의한다고 가정한다. 
	- 두번째 : 식이 본문인 함수(expression-body). 어떤 함수가 단일 식으로만 구현될 수 있다면 return 키워드와 블록을 만드는 중괄호{}를 생략하고 다음과 같은 형태로 함수를 작성할 수 있다. `fun circleArea(radius:Double):Double = PI*radius*radius`

## 3.1.2 위치 기반 인자와 이름 붙은 인자

- 코틀린에서는 위치 기반 인자와 이름 붙은 인자 2가지 방법을 사용한다. 
	- 이름붙은 인자는 위치가 아니라 파라미터의 이름을 명시함으로써 인자를 전달하는 방식이다. 
	- 이름붙은 인자를 사용하면 인자의 실제 순서는 중요하지 않다. 

## 3.1.3 오버로딩과 디폴트 값

- 코틀린에서도 오버로딩은 이용가능하다. 다만 컴파일러가 어떤 함수를 호출해야 할지 구분할 수 있도록 오버로딩한 함수의 파라미터 타입이 모두 달라야 한다.  
	- 반환값이 다른것은 다른 함수로 여기지 않는다. 
- 오버로딩 해소(overloading resolution)
	- 1. 파라미터의 개수와 타입을 기준으로 호출할 수 있는 모든 함수를 찾는다.
	- 2. 덜 구체적인 함수를 제외시킨다. 규칙 1에서 선택한 후보 목록에서 어떤 함수의 파라미터 타입이 다른 함수의 파라미터 타입의 상위 타입인 경우 이 함수는 다른 함수보다 덜 구체적인 함수다. 덜 구체적인 함수가 모두 제외될 때까지 이 단계를 반복한다. 
	- 3. 후보가 하나로 압축되면 이 함수가 호출할 함수다. 후보가 둘 이상이면 컴파일 오류가 발생한다. 

- 디폴트 값이 있는 파라미터를 함수 인자 목록 뒤쪽에 몰아두는 쪽이 더 좋은 코딩 스타일이다. 디폴트값이 있으면 인자 개수가 가변적이어서 오버로딩 해소가 복잡해질 수 있다. 


## 3.1.4 vararg 

- 인자의 개수가 정해지지 않은 경우에 사용할 수 있는 기능이 있다. 파라미터 정의 앞에 vararg 변경자를 붙이면 된다. 

```kotlin 
fun printSorted(vararg items: Int){
	items.sort()
}

fun main(){
	printSorted(6,2,10,1)
}
```

## 3.1.5 함수의 영역과 가시성

- 코틀린 함수의 3가지 구분
	- 파일에 직접 선언된 최상위 함수
	- 어떤 타입 내부에 선언된 멤버 함수
	- 다른 함수 안에 선언된 지역 함수

- 기본적으로 파일내 선언된 최상위 함수는 public이다. 같은 디렉터리 안에 다른 파일에서 사용할 수 있다. 
- 경우에 따라서는 프로젝트의 나머지 부분으로부터 구현 상세 내용을 숨겨서 보호하고 싶을 때가 있다. 이렇게하면 함수의 영역을 줄일 수 있고, 코드에서 함수가 쓰일 수 있는 위치를 제한할 숭 ㅣㅆ다.
	- private이나 internal 이라는 키워드를 붙일 수 있다. 
	- 최상위 함수를 private로 정의하면 함수가 정의된 파일 안에서만 해당 함수를 볼 수 있다. 


- jvm이 볼 때 최상위 main() 함수는 코틀린 파일마다 자동으로 만들어지는 특별한 파사드 클래스의 정적 멤버라는 사실을 설명했다. 지역 함수의 경우에도 코틀린 컴파일러는 비슷한 트릭을 써서 지역 함수를 정의하며, 지역 함수를 둘러싼 영역의 변수나 파라미터 목록등의 문맥을 포획해주는 특별한 클래스를 선언한다. 


# 3.2 패키지와 임포트

코틀린 패키지는 관련 있는 선언을 묶는 방법이다. 패키지는 이름이 있고, 다른 패키지를 포함할 수 있다. 

## 3.2.1 패키지와 디렉터리 구조

- 파일에서 맨 앞에 패키지 이름을 지정하면 파일에 있는 모든 최상위 선언을 지정한 패키지 내부에 넣을 수 있다. 패키지를 지정하지 않으면 컴파일러는 파일이 디폴트 최상위 패키지에 속한다고 가정한다. 


- 패키지 디렉티브는 package 키워드로 시작하고 점으로 구별된 식별자들로 이뤄진 패키지 전체 이름이 뒤에 온다. 기본적으로 이 전체 이름은 프로젝트의 전체 패키지 계층에서 루트 패키지로부터 지정한 패키지에 도달하기 위한 경로다. 
```kotlin 
package foo.bar.util
fun readInt(radix: Int = 10) = readLine()!!.toInt(radix)
```

- util이라는 패키지에 속하고, util은 다시 bar 패키지에 속하며, bar는 다시 foo 패키지에 속하고, foo 패키지는 루트 패키지에 속한다. 
- 같은 패키지 디렉티브를 사용하면 여러 파일을 같은 패키지에 넣을 수 있다. 
	- Q. 여러 파일을 같은 패키지에 넣게 되면 어떤 장점이 있을까?
	- Q. 폴더링만 구분해놓고, 같은 패키지에 포함시키는 것은 가능한 그림인가? 


- 같은 패키지 안에서는 간단한 이름을 사용해 패키지 내에 있는 다른 정의를 참조할 수 있다. 
- 패키지 계층 구조는 소스 파일에 있는 패키지 디렉티브로부터 구성된 별도의 구조라는 점에 유의하라. 소스 파일 트리와 패키지 계층 구조가 일치할 수도 있지만 꼭 그럴 필요는 없다. 예를 들어 소스 파일은 모두 한 디렉터리 아래에 있지만 각각이 서로 다른 패키지에 포함될 수도 있고, 한 패키지에 포함된 소스 파일들이 모두 서로 다른 디렉터리에 들어갈 수도 있다. 

- import alias 사용하기

```kotlin 
import foo.readInt as fooReadInt
import foo.readInt as barReadIng 
fun main(){
	val n = fooReadInt()
	val m = barReadIng()
}
```


# 3.3 조건문

## 3.3.1 if문으로 선택하기

- 코틀린의 if는 식으로 사용할 수 있다.
```kotlin 
fun max(a:Int, b: Int) = if(a > b) a else b
```

- if의 두 가지 중 어느 쪽이 블록인 경우에도 마찬가지다. 이 경우에는 블록 맨 끝에 있는 식의 값이 블록 전체의 값이 된다.

```kotlin
fun main(){
	val s = readLine()!!
	val i = s.indexOf("/")

	val result = if(i>= 0){
		val a = s.substring(0, i).toInt()
		val b = s.substring(i+1).toInt()
		(a/b).toString()
	}else ""
}
```

## 3.3.2 범위, 진행, 연산

- 코틀린은 순서가 정해진 값 사이의 수열을 표현하는 몇 가지 타입을 제공한다.

```kotlin
val chars = 'a'..'h'
val twoDigits = 10..99
val zero20ne = 0.0..1.0
```

in 연산을 사용하면 어떤 값이 범위 안에 들어있는지 알 수 있다. 기본적으로 한 쌍의 비교식을 조합한 것과 같다.
```kotlin
val num = readLine()!!.toInt()
println(num in 10..99)
```

기본적으로 .. 연산에 의해 만들어지는 범위는 닫혀 있다. 즉, 시작 값과 끝 값이 범위에 포함된다. 반만 닫힌 범위를 만드는 다른 연산도 있다. 

```kotlin
val twoDigits = 10 until 100
```

# 3.4 루프

- do-while은 do 키워드 내부의 내용이 실행된 다음에 while의 조건문을 확인한다.
- while문은 조건이 참이어야만 몸통 내부를 실행한다. 


## 3.4.2 for 루프와 이터러블 

- 루프 변수는 자동으로 불변 값이 된다. 즉, 루프 몸통에서 루프 변수를 변경할 수는 없다. 