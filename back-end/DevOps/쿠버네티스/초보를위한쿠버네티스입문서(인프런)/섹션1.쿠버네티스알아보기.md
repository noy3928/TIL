
## 쿠버네티스 아키텍처

- 구성 설계 
	- desired state 가 근간이 되는 개념이다
		- 먼저 원하는 상태가 있다. 그리고 그 원하는 상태와 현재의 상태를 비교한 다음 차이점을 찾아낸다. 그 차이점에 따라서 조치를 취한다. 이런 루프를 반복적으로 도는 것이다. 이러한 행위를 쿠버네티스가 하는 것이다 
	- 이 desired state를 저장하고 관리하는 것이 etcd이다. 
	- api서버가 중간에 존재한다. 
		- 다른 컴포넌트들은 api 서버에게 물어보고, api서버는 etcd에게 물어본다. 다른 컴포넌트들은 etcd와 직접 소통하는 경우가 없다. api 서버를 통해서 컴포넌트들은 etcd와 소통한다. 
	- scheduler 
		- 새로 생성된 pod을 감지하고 실행할 노드를 선택한다. 어떤 노드에 어떤 컨테이너를 실행할지. 노드의 현재 상태와 pod의 요구사항을 체크하는 역할을 한다. 
		- 어떤 서버에 여유가 있는지. 그래서 여유 있는 서버 쪽에 컨테이너를 띄울 수 있도록 조절해주는 역할을 함. 
	- controller 
		- 컨트롤러는 굉장히 다양하게 존재할 수 있다. 복제 컨트롤러, 노드 컨트롤러, 엔드포인트 컨트롤러 등등. 끊임없이 상태를 체크하고 원하는 상태를 유지하는 역할을 한다. 복잡성을 낮추기 위해 하나의 프로세스로 실행한다. 

- 명령을 쿠버네티스에 보내는 부분 / 명령을 쿠버네티스가 받고 동작하는 부분 / 쿠버네티스의 동작을 통해서 노드가 실제로 띄우지는 부분
	- 이렇게 3가지 부분으로 나뉘어질 수 있다. 아래에서는 실제 명령을 받고 쿠버네티스가 동작하는 부분을 자세하게 살펴볼 것이다. 이쪽 부분을 우리는 마스터라고 부르자. 

- Q. 근데 그럼 쿠버네티스 안쪽에 api 서버라는것이 따로 있는 것인가? 

- etcd (모든 데이터를 확실하게 관리한다)
	- 모든 상태와 데이터를 저장한다.
	- 분산 시스템으로 구성하여 안정성을 높인다.
	- 가볍고 빠르면서 정확하게 설계한다.
	- key-value 형태로 데이터를 저장한다.
	- TTL, watch 같은 부가 기능을 제공한다. 
	- 백업은 필수이다. 
- api 서버
	- 상태를 바꾸거나 조회하는 역할을 한다.
	- etcd와 유일하게 통신하는 모듈이다.
	- rest api 형태로 제공한다.
	- 권한을 체크하여 적절한 권한이 없을 경우 요청을 차단한다.
	- 관리자 요청 뿐 아니라 다양한 내부 모듈과 통신한다. 
	- 수평으로 확장되도록 디자인되어있다. 


- 조회의 흐름
	- 1) 컨트롤러는 상태를 체크하고 싶다. 이 상태 체크를 직접 etcd에게 요청하는 것이 아니다. api 서버에게 상태 체크를 요청한다. 그러면 api 서버는 권한을 확인한다. 권한을 확인하고나면, api 서버는 etcd에게 상태를 확인한다. 이런 방식으로 이루어진다.
	- 2) etcd에서 상태가 변경이 되었다. 원하는 상태로 변경된 것이다. 그러면 그 결과를 api 서버에게 알려준다. api서버는 각각의 컨트롤러에게 변경된 내용을 전달한다. 그러면 컨트롤러는 변경 사항을 참고하여 조치를 취한다. 그리고 반영한 결과를 다시 api 서버에게 알려주고, 결과를 받은 api서버는 다시 해당 정보를 갱신한다. 그것을 etcd에게 알려주는 것이다. 

- node 쪽을 살펴보자 (실제 컨테이너가 떠있는 부분)
	- 현재 노드에는 proxy와 kubelet이라는 컴포넌트가 떠있다고 가정하다. 이 두 노드도 쿠버네티스와 통신을 할 때는 api 서버만을 바라본다. 


- kublet 
	- 큐블릿은 각 노드에 전부 다 떠있어야 한다. 이 큐블릿이 팟을 실행하고 중지하고 상태를 체크한다. 그렇기 때문에 계속 모든 노드에 떠서 동작을 해야한다. 
	- cri라는 개념이 있다. -> ??? 
- proxy 


- 이번에는 더 큰 그림에서 요청의 흐름을 살펴보자
	- 

---
- pod이란 무엇인가?
	- 