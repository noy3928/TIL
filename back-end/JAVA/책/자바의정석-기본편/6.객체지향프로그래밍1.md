## 1. 객체지향 언어

- 객체지향 언어의 주요 특징
  - 코드의 재사용성이 높다
  - 코드의 관리가 용이하다
  - 신뢰성이 높은 프로그래망을 가능하게 한다
- 유의점 : 너무 객체지향 개념에 얽매여서 고민하기 보다는 일단 프로그램을 기능적으로 완성한 다음 어떻게하면 보다 객체지향적으로 코드를 개선할 수 있을지를 고민하여 점차 개선해 나가는 것이 좋다.

## 2. 클래스와 객체

- 클래스란 객체를 정의해놓은 것. 객체의 설계도 또는 틀이라고 정의할 수 있다.
- 클래스는 객체를 생성하는데 사용되는 것이며,
- 객체는 클래스에 정의된 대로 생성된다.

- 프로그래밍에서의 객체는 클래스에 정의된 내용대로 메모리에 생성된 것을 뜻한다.
- 클래스와 객체의 관계를 우리가 살고 있는 실생활에서 예를 들면, 제품 설계도와 제품과의 관계라고 할 수 있다. 예를 들면 tv설계도는 tv라는 제품을 정의한 것이며, tv를 만드는데 사용된다.
- 클래스를 사용하는 이유 :
  - 클래스를 정의하고 클래스를 통해 객체를 생성하는 이유는 설계도를 통해서 제품을 만드는 이유와 같다. 하나의 설계도만 잘 만들어 놓으면 제품을 만드는 일이 쉬워지기 때문이다.

## 3. 객체의 구성요소 - 속성과 기능

- 객체는 속성과 기능 두 종류의 구성요소로 이루어져있다.
- 클래스란 객체를 정의한 것이므로 클래스에는 객체의 모든 속성과 기능이 정의되어 있다.
- 클래스로부터 객체를 생성하면, 클래스에 정의된 속성과 기능을 가진 객체가 만들어지는 것이다.

```java
class Tv {
  String color;
  boolean power;
  int channel;

  void power() {
    power = !power;
  }

  void channelUp() {
    channel++;
  }

  void channelDown() {
    channel--;
  }
}
```

## 4. 객체와 인스턴스

- 클래스로부터 객체를 만드는 과정을 클래스의 인스턴스화라고 한다.
- 어떤 클래스로부터 만들어진 객체를 그 클래스의 인스턴스라고 한다.
- 결국 인스턴스는 객체와 같은 의미이지만, 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖고 있다. 그리고 인스턴스는 어떤 클래스로부터 만들어진 것인질르 보다 강조하는 의미를 갖고 있다.
-

## 6. 객체의 생성과 사용

```java
Tv t;
t = new Tv();
```

```java
class Ex6_1 {
    public static void main(String[] args) {
        Tv t;
        t = new Tv();
        t.channel = 7;
        t.channelDown();
        System.out.println("현재 채널은 " + t.channel + "입니다.");
    }
}

class Tv {
    String color;
    boolean power;
    int channel;

    void power() {
        power = !power;
    }

    void channelUp() {
        channel++;
    }

    void channelDown() {
        channel--;
    }
}
```

1. Tv t;

- tv 클래스 타입의 참조변수 t를 선언한다. 메모리에 참조변수 t를 위한 공간이 마련된다. 아직 인스턴스가 생성되지 않았으므로 이 참조변수로 할 수 있는 것은 아무것도 없다.

2. t = new Tv();

- 연산자 new에 의해 Tv 클래스의 인스턴스가 메모리의 빈 공간에 생성된다.
- 주소가 0x100곳에 생성되었다고 가정하자. 이 때, 멤버변수는 각 자료형에 해당하는 기본값으로 초기화 된다.

3. t.channel = 7;

- 참조변수 t로 인스턴스에 접근하여 멤버변수 channel의 값을 7로 변경한다.

## 7. 객체의 생성과 사용 예제

- 같은 클래스로부터 생성되었을지라도 각 인스턴스의 속성은 서로 다른 값을 유지할 수 잇으며, 메서드의 내용은 모든 인스턴스에 대해 동일하다.

## 8. 객체 배열

- 객체 역시 배열로 다루는 것이 가능하다. 이것을 객체 배열이라고 한다.
- 객체 배열안에 객체가 저장되는 것은 아니다. 객체의 주소가 저장된다.
- 사실 객체 배열은 참조변수들을 하나로 묶은 참조변수 배열인 것이다.

```java
Tv[] tvArr = new Tv[3];
```

이 객체 배열은 3개의 객체, 정확히는 객체의 주소를 저장할 수 있다.

```java
Tv[] tvArr = { new Tv(), new Tv(), new Tv() };
```

## 10. 클래스의 정의 - 사용자 정의 타입

- 프로그래머가 서로 관련된 변수들을 묶어서 하나의 타입으로 새로 추가하는 것을 '사용자 정의 타입'이라고 한다.
- 자바와 같은 객체지향언어에서는 클래스가 곧 사용자 정의 타입이다.

```java
int[] hour = new int[3];
int[] minute = new int[3];
int[] second = new int[3];
```

- 위와 같이 배열로 처리하면 다뤄야 하는 시간 데이터의 개수가 늘어나더라도 배열의 크기만 변경해주면 되므로, 변수를 매번 새로 선언해줘야 하는 불편함과 복잡함은 없어졌다.
- 그러나 하나의 시간을 구성하는 시, 분, 초가 서로 분리되어 있기 때문에 프로그램 수행과정에서 시, 분, 초가 따로 뒤섞여서 올바르지 않은 데이터가 될 가능성이 있다.
- 이런 경우 시, 분, 초를 하나로 묶는 사용자정의 타입, 즉 클래스를 정의하여 사용해야 한다.

```java
class Time {
    int hour;
    int minute;
    float second;
}
```

- 이제 이렇게하면 시,분,초가 하나의 단위로 묶이기 때문에 다른 시간 데이터와 섞이는 일은 없을 것이다.
- 하지만 시간 데이터에는 다음과 같은 추가적인 제약조건이 있다.

1. 시, 분, 초는 모두 0보다 크거나 같아야 한다.
2. 시의 범위는 0-23, 분과 초의 범위는 0-59이다.

- 이러한 조건들이 모두 프로그램 코드에 반영될 때, 보다 정확한 데이터를 유지할 수 있을 것이다.
- 객체지향언어가 아닌 언어에서는 이러한 추가적인 조건들을 반영하기가 어렵다.
- 객체지향언어에서는 제어자와 메서드를 이용해서 이러한 조건들을 코드에 쉽게 반영할 수 있다.

```java
public class Time {
    private int hour;
    private int minute;
    private float second;

    public void setHour(int h) {
        if (h < 0 || h > 23) return;
        hour = h;
    }
    ...
}
```

- 제어자를 이용해서 변수의 값을 직접 변경하지 못하게 하고, 대신 메서드를 통해서 값을 변경하도록 작성하였다.
- 값을 변경할 때 지정된 값의 유효성을 조건문으로 점검한 다음에 유효한 값일 경우에만 변경한다.

## 11. 선언위치에 따른 변수의 종류

- 변수는 클래스 변수, 인스턴스 변수, 지역변수 모두 3 종류가 있다.
- 변수의 종류를 결정짓는 중요한 요소는 '변수의 선언 위치'이다.
- 멤버 변수를 제외한 나머지 변수들은 모두 지역변수이며, 멤버변수 중 static이 붙은 것은 클래스 변수, 붙지 않은 것은 인스턴스 변수이다.

```java
class Variables {
    int iv;
    static int cv;
    void method() {
        int lv = 0;
    }
}
```

### 1. 인스턴스 변수(instance variable) :

- 클래스 영역에 선언되며, 인스턴스를 생성할 때 만들어진다.
- 그래서 인스턴스 변수의 값을 읽어 오거나 저장하려면 먼저 인스턴스를 생성해야한다.
- 인스턴스마다 별도의 저장공간을 가지므로 서로 다른 값을 가질 수 있다.
- 인스턴스마다 고유한 상태를 유지해야하는 속성의 경우, 인스턴스 변수로 선언한다.

### 2. 클래스 변수 :

- 클래스 변수를 선언하는 방법은 인스턴스 변수 앞에 static을 붙이기만하면 된다.
- 인스턴스마다 독립적인 저장공간을 갖는 인스턴스 변수와는 달리, 클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유하게 된다.
- 한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우, 클래스 변수로 선언해야 한다. ( 공통적인 값을 유지해야하는 속성의 예시에는 무엇이 있을까? )
- 클래스 변수는 인스턴스 변수와 달리 인스턴스를 생성하지 않고 언제라도 바로 사용할 수 있다는 특징이 있으며, '클래스이름. 클래스 변수'와 같은 형식으로 사용한다.

### 3. 지역변수 :

- 메서드 내에 선언되어 메서드 내에서만 사용 가능하며, 메서드가 종료되면 소멸되어 사용할 수 없게 된다.
- for문 또는 while문의 블럭 내에 선언된 지역 변수는, 지역변수가 선언된 블럭 내에서만 사용 가능하며, 블럭을 벗어나면 소멸되어 사용할 수 없게 된다.

## 12. 클래스 변수와 인스턴스 변수

- 카드 클래스를 자것앟기 위해서는 먼저 카드를 분석해서 속성과 기능을 알아내야 한다.
- 속성으로는 카드의 무늬, 숫자, 폭, 높이 정도를 생각할 . 수있을 것이다.
- 이 중에서 어떤 속성을 클래스 변수로 선언할 것이며, 또 어떤 속성들을 인스턴스 변수로 선언할 것인지 한번 생각해보자.

```java
class Card {
    // 인스턴스 변수
    // 개별 속성
    String kind;
    int number;

    // 클래스 변수 (공통속성)
    static int width = 100;
    static int height = 250;
}
```

## 13. 클래스 변수와 인스턴스 변수 예제

```java
class Ex6_3 {
    public static void main(String[] args) {
        System.out.println("Card.width = " + Card.width);
        System.out.println("Card.height = " + Card.height);

        Card c1 = new Card();
        c1.kind = "Heart";
        c1.number = 7;

        Card c2 = new Card();
        c2.kind = "Spade";
        c2.number = 4;
    }
}
```

## 14. 메서드란?

- '메서드'는 특정 작업을 수행하는 일련의 문장들을 하나로 묶은 것이다.
- 어떤 값을 입력하면 이 값으로 작업을 수행해서 결과를 반환한다.
- 메서드가 작업을 수행하는데 필요한 값만 넣고 원하는 결과를 얻으면 될 뿐, 이 메서드가 내부적으로 어떤 과정을 거쳐 결과를 만들어내는지 전혀 몰라도 된다.
- 즉, 메서드에 넣을 값과 반환하는 결과만 알면 되는 것이다.

## 15. 메서드의 선언부

- 메서드의 선언부는 '메서드의 이름'과 '매개변수 선언', 그리고 '반환타입'으로 구성되어 있다.
- 메서드가 작업을 수행하기 위해 어떤 값들을 필요로 하고 작업의 결과로 어떤 타입의 값을 반환하는지에 대한 정보를 제공한다.
- 매개변수 선언 :
  - 매개변수는 메서드가 작업을 수행하는데 필요한 값들을 제공받기 위한 것이다.
  - 필요한 값의 개수만큼 변수를 선언하며 각 변수 간의 구분은 쉼표를 사용한다.
  - 한 가지 주의할 점은 일반적인 변수선언과 달리 두 변수의 타입이 같아도 변수의 타입을 생략할 수 없다는 것이다.
- 반환타입 :
  - 메서드의 작업수행 결과인 반환값의 타입을 적는다. 단, 반환값이 없는 경우 반환타입으로 'void'를 적어야한다.

## 16. 메서드의 구현부

- 메서드의 선언부 다음에 오는 괄호를 메서드의 구현부라고 한다.
- 여기에 메서드를 호출했을 때 수행될 문장들을 넣는다.

## 20. return 문

- 원래는 반환값의 유무에 관계없이 모든 메서드에는 적어도 하나의 return문이 있어야 한다.
- 그런데도 반환타입이 void인 경우, return 문 없이도 아무런 문제가 없었던 이유는 컴파일러가 메서드의 마지막에 'return'을 자동적으로 추가해주었기 때문ㅇ다.
