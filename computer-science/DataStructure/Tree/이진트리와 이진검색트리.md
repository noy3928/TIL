# 이진트리

노드가 왼쪽 자식과 오른쪽 자식만을 갖는 트리를 이진 트리라고 한다.  
이때 두 자식 가운데 하나 또는 둘 다 존재하지 않는 노드가 있어도 상관없다.  
이진트리의 특징은 왼쪽 자식과 오른쪽 자식을 구분한다는 점이다.  
왼쪽 자식을 루트로 하는 서브트리를 왼쪽 서브트리라고 하고, 오른쪽 자식을 루트로 하는 서브트리를 오른쪽 서브트리라고 한다.

## 완전이진트리 complete binary tree

루트부터 아래쪽 레벨로 노드가 가득 차 있고, 같은 레벨 안에서 왼쪽부터 노드가 채워져있는 이진 트리를 완전 이진 트리라고 한다.
노드를 채우는 방법은 다음과 같다.

- 마지막 레벨을 제외하고 모든 레벨에 노드가 가득 차 있다.
- 마지막 레벨에 한해서 왼쪽부터 오른쪽으로 노드를 채우되 반드시 끝까지 채우지 않아도 된다.(오른쪽 노드는 비어있어도 괜찮다.)
  높이가 k인 완전 이진 트리가 가질 수 있는 노드의 수는 최대 2(k+1) - 1개이다. n개의 노드를 저장할 수 있는 완전 이진 트리의 높이는 Log n이다.

## 이진검색트리

이진 검색 트리는 모든 노드가 다음의 조건을 만족해야 한다.

- 왼쪽 서브트리 노드의 키값은 자신의 노드 키값보다 작아야 한다.
- 오른쪽 서브트리 노드의 키값은 자신의 노드 키값보다 커야 한다.

따라서 키값이 같은 노드는 복수로 존재하지 않는다.  
노드 5를 보면, 왼쪽 서브트리의 노드 (4,1)은 모두 5보다 작고,  
오른쪽 서브트리의 노드 (7,6,9)는 모두 5보다 크다.

이진 검색 트리를 중위 순회의 깊이 검색으로 스캔하면 다음과 같이 노드의 키 값을 오름차순으로 얻을 수 있다.  
1->4->5->6->7->9->11->12->13->14->15->18

이진 트리의 다음과 같은 특징 때문에 알고리즘에서 폭 넓게 사용하고 있다.

- 구조가 단순하다.
- 중위 순회의 깊이 우선 검색을 통하여 노드값을 오름차순으로 얻을 수 있다.
- 이진 검색과 비슷한 방식으로 아주 빠르게 검색할 수 있다.
- 노드를 삽입하기 쉽다.

<br>
[이진트리 예시코드](./Binary%20Search%20Tree.py)

![노드 클래스 노드의 이미지](node-ref-right-left.jpg "노드 이미지")
노드 클래스의 **init** 함수는 4개의 매개변수로 전달받은 값을 각 필드에 대입한다.

### 이진 검색 트리 클래스 BinarySearchTree

이 클래스의 유일한 필드는 루트에 대한 참조를 유지하는 root이다. 클래스 BinarySearchTree의 **init**() 함수는 root에 None을 대입하여  
노드가 하나도 없는 빈 상태의 이진 검색 트리를 생성한다.

### 키 값으로 검색하는 search() 함수

이진 검색 트리에서 검색을 수행하는 과정을 구체적으로 알아보자.

1.처음에 주목하는 루트의 키는 5다. 3은 5보다 작으므로 왼쪽 자식 노드를 따라간다.  
2.다음에 주목하는 노드의 키는 2다. 3은 2보다 크므로 오른쪽 자식 노드를 따라간다. 3.다음에 주목하는 노드의 키는 4다. 3은 4보다 작으므로 왼쪽 자식 노드를 따라간다. 4.키가 3인 노드에 도달했다. 검색에 성공한다.
<br>

다음은 실패한 검색이다. 1.처음에 주목하는 루트의 키는 5다. 8은 5보다 크므로 오른쪽 자식 노드를 따라간다. 2.다음에 주목하는 노드의 키는 7이다. 주목 노드는 리프이고 오른쪽 자식 노드는 존재하지 않는다. 더 이상 스캔을 할 수 없으므로 검색에 실패한다.

이것의 알고리즘은 다음과 같다.

1.루트에 주목한다. 여기서 주목하는 노드를 p라고 하겠다.
2.p가 None이면 검색을 실패하고 종료한다.  
3.검색하는 key와 주목 노드 p의 키를 비교한다.
3-1.key=p : 검색을 성공하고 종료한다.  
 3-2.key<p : 주목노드를 왼쪽 자식 노드로 옮긴다.  
 3-3.key>p : 주목노드를 오른쪽 자식 노드로 옮긴다.  
4.2번 과정으로 되돌아간다.

<br>

### 노드를 삽입하는 add() 함수

노드를 삽입할 때 주의할 점은 노드를 삽입한 뒤에 트리의 형태가 **이진 검색 트리의 조건을 유지해야 한다** 는 것이다.  
따라서 노드를 삽입할 때에는 검색할 때와 마찬가지로 먼저 **삽입할 위치를 찾아낸 뒤에** 수행해야 한다.

삽입하는 과정을 살펴보자.
1을 삽입하는 과정:  
1.삽입할 위치를 찾는다. 추가할 값 1은 2보다 작고 왼쪽 자식 노드가 존재하지 않으므로 삽입할 위치로 2를 선택한다.  
2.1을 2의 왼쪽 자식 노드로 삽입한다.  
<br>

5를 삽입하는 과정 :  
1.삽입할 위치를 찾는다. 추가할 값 5는 4보다 크고 오른쪽 자식 노드가 존재하지 않으므로 삽입할 위치로 4를 선택한다.  
2.5를 4의 오른쪽 자식 노드로 삽입한다.

![5를 삽입하는 과정](add5.jpg "5를 삽입하는 과정")

이것의 알고리즘은 다음과 같다.

1.루트에 주목한다. 여기서 주목하는 노드를 node라고 한다.  
2.삽입하는 key와 주목node의 키를 비교한다.
2-1. key = node : 삽입을 실패하고 종료한다.
2-2. key < node :

- 왼쪽 자식 노드가 없으면, 그 자리에 노드를 삽입하고 종료한다.
- 왼쪽 자식 노드가 있으면, 주목 노드를 왼쪽 자식 노드로 옮긴다.

2-3. key > node :

- 오른쪽 자식 노드가 없으면, 그 자리에 노드를 삽입하고 종료한다.
- 오른쪽 자식 노드가 있으면, 주목 노드를 오른쪽 자식 노드로 옮긴다.

  3.2번 과정으로 되돌아간다.

<br>

### 노드를 삭제하는 remove() 함수

노드를 삭제하는 과정은 삽입하는 과정보다 복잡하다. 노드를 삭제할 때 다음과 같은 3가지 경우가 있기 때문이다.

a.자식 노드가 없는 노드를 삭제하는 경우  
b.자식 노드가 1개인 노드를 삭제하는 경우  
c.자식 노드가 2개인 노드를 삭제하는 경우

#### a.자식노드가 없는 노드를 삭제하는 경우

자식 노드가 없는 노드 3을 삭제하는 경우. 노드 3을 가리키는 부모노드 4의 왼쪽 보인터가 노드 3을 가리키지 않도록 업데이트 한다.  
즉, 왼쪽 포인터를 None으로 한다. 그 결과 노드 3을 가리키는 노드가 없기 때문에 이진 검색 트리에서 삭제된다.

정리하면 다음과 같다.

- 삭제할 노드가 부모 노드의 왼쪽 자식이면, 부모의 왼쪽 포인터를 None으로 한다.
- 삭제할 노드가 부모 노드의 오른쪽 자식이면, 부모의 오른쪽 포인터를 None으로 한다.

#### b.자식노드가 1개인 노드를 삭제하는 경우

자식노드가 1개인 7을 삭제하는 경우. 원래 노드 7의 위치에 노드 8을 가져오면 삭제할 수 있다. 왜냐하면 '자식 노드 8을 루트로 하는 서브트리의 모든 키는 부모 노드 6보다 커야 한다'는 관계가 성립하기 때문이다.  
구체적인 과정을 살펴보면 삭제할 노드 7의 부모 노드인 6의 오른쪽 포인터가 삭제할 노드 7의 자식 노드인 8을 가리키도록 업데이트하면 된다.  
그러면 노드 7을 가리키는 노드가 없기 때문에 이진 검색 트리에서 삭제된다.

정리하면 다음과 같다.

- 삭제할 노드가 부모 노드의 왼쪽 자식인 경우 : 부모의 왼쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트한다.
- 삭제할 노드가 부모 노드의 오른쪽 자식인 경우 : 부모의 오른쪽 포인터가 삭제할 노드의 자식을 가리키도록 업데이트 한다.

<br>

#### c.자식 노드가 2개인 노드를 삭제하는 경우

자식 노드가 2개인 노드를 삭제하는 과정은 앞의 a,b 경우보다 복잡하다.  
노드 5의 왼쪽 서브트리 사운데 키값이 가장 큰 노드 4를 노드 5의 위치로 옮겨 삭제를 수행한다.

![5를 삭제하는 과정](remove5.jpg "5를 삭제하는 과정")

[삭제 예시코드](Binary%20Search%20Tree.py)

## 균형 검색 트리

이진 검색 트리는 키의 오름차순으로 노드가 삽입되면 트리의 높이가 깊어지는 단점이 있다.  
예를 들어 비어 있는 이진 검색 트리에 1,2,3,4,5 순으로 노드를 삽입하면 직선 모양의 트리가 된다.  
이와 같이 높이를 O로 제한하여 고안된 검색 트리를 균형 검색 트리라고 한다.
