
# 3.1 추상화

팩토리 메서드 패턴을 이해하기 위해서는 먼저 객체지향의 추상화에 대한 개념을 학습해야한다.
(어떤 연관이 있을까?)

## 3.1.1 추상 개념

- 추상은 사전적 의미로 중요한 부분만 분리하여 이해하기 쉽게 만드는 작업이다.
- 파악하려는 기능이 요약된 정보가 있다면 보다 쉽게 이해할 수 있을 것이다. **객체에 추상적 개념을 적용하는 이유는 객체의 동작을 보다 쉽게 파악하기 위해서이다.** 
- 그러면 어떻게 추상화할까?
	- => 먼저 기능을 이해하기 위해 세부 사항을 분리한다.

## 3.1.2 코드 요약
- 추상화 작업은 코드를 요약하는 것이다.
- 추상화 작업을 위해서는 먼저 요약된 정보와 실제 구현부를 분리한다. 

# 3.2 패턴 확장

추상화를 통해 팩토리 패턴을 확장한다. 중요한 부분만 분리하여 추상 클래스의 골격을 형성한다.
(골격을 형성하기 위해서는 가장 요약된 내용의 코드를 뽑아내야한다.)


## 3.2.1 팩토리

```php
class LgProduct 
{
	 public function name()
	 {
		 echo "LG Gram laptop"
	 }
}
```
팩토리 패턴에선 직접 객체를 생성하지 않는다. 별도의 클래스를 통해서 생성한다. 

```php 
class Factory
{
	public final function create()
	{
		return new LgProduct();
	}
}
```

## 3.2.2 추상화

- 이전에 생성한 팩토리 클래스에 추상화를 결합하자.
- 그러면 2가지 형태로 구분된다.
	- 팩토리 메서드 패턴
	- 추상 팩토리 패턴
- 기존의 Factory 클래스를 추상 클래스로 변경하자.
	- 이렇게 하는 이유 => 객체를 생산하고 사용하는 것을 분리하기 위함. (생산과 사용의 분리)
	- Q. 객체의 생산과 사용은 왜 분리하는가? 

```php
abstract class Factory
{
	public final function create()
	{
		return $this->createProduct();
	}

	// 추상 메서드 선언
	abstract public function createProduct();
}
```

- 이렇게 작성하고나면 반드시 실제 구현 클래스를 만들어야한다.
- 이렇게 추상화를 함으로써, 선언과 구현이 자연스럽게 분리된다. 

## 3.2.3 인터페이스

- 인터페이스는 클래스를 설계하는 방법을 규정하는 약속
- 인터페이스를 적용하면 반드시 인터페이스에 선언된 정의에 따라 클래스에 구현한다. 
- 추상 클래스에는 구체화되지 않은 추상 메서드를 선언할 수 있는데, 이것은 인터페이스와 유사하다.
	- 이 추상 메서드는 상속받은 하위 클래스에서 반드시 메서드를 구현해야한다. 
- 추상화는 실제적인 동작을 하위 클래스에 위임함으로써 추상 클래스 안에서 미리 위임된 메서드를 사용할 수 있다.


## 3.2.4 템플릿 메서드 패턴

- 추상화를 적용한 예제에서는 실체 객체 생성을 createProduct 메서드로 위임한다. 추상 클래스의 create 메서드에서 호출한 createProduct 메서드는 추상화 선언만 되어있고, 실제 구현은 없다. 
- 이처럼 추상화를 사용하면 실제 내용이 구현되지 않은 상태에서도 메서드를 미리 호출해서 사용할 수 있다.

## 3.2.5 패턴 차이

- 팩토리 메서드 패턴과 템플릿 메서드 패턴은 유사한 동작이 있다. 해결하려는 목적에 따라 두 패턴에는 차이가 있다.
- 두 패턴의 공통점은 추상화를 사용해 객체를 생성한다는 것, 상위 클래스에서 정의를 결정하고 하위 클래스에 구체적인 처리를 위임한다는 것이다. 

# 3.3 상위 클래스

- 추상 클래스로 변경하면 클래스는 강제적으로 상위 클래스와 하위 클래스로 분리된다.

## 3.3.1 분리

- 추상화는 클래스의 골격 구조를 변경한다.
- 일반 클래스가 추상화로 변경되면, 클래스는 추상 클래스와 구현 클래스로 분리된다.
	- 추상 클래스란 abstract 키워드를 이용해 변경된 타입의 클래스를 말한다.
	- 추상화로 선언된 클래스는 일반적인 클래스 선언보다 객체의 결합 관계를 더 느슨한 관계로 변경한다.
	- 추상화로 분리된 상세한 구현은 하위 클래스로 위임하여 작성한다.

## 3.3.2 공통된 기능

- 추상화의 상위 클래스는 추상 클래스이다. 
	- 추상 클래스는 인터페이스와는 다르다.
		- 인터페이스는 설계 규약만 표현할 수 있다.
		- 추상 클래스는 행위 메서드를 추상 클래스 안에 같이 구현할 수 있다.
		- 구현된 메서드는 상속할 경우 하위 클래스에서도 사용 가능하다.
- (이 장에서는 이런 메서드를 공통된 기능으로 설명하고 있다.)

## 3.3.2 개념적 정의 

- 메서드에 대한 개념적 정의가 가능하다. -> 이것이 추상 메서드이다.
	- 이것은 추상 클래스가 가진 특징이다.  
	- 인터페이스와 같이 특정한 메서드에 대한 선언이 가능하다.

```java
abstract public function createProduct();
```
이것이 추상 메서드이다.

- 추상 메서드
	- 실제 구현부는 존재하지 않는다.
	- 정의 부분만 선언된다.
	- 구현부는 상속받는 하위 클래스에서 구현한다.
	- 인터페이스와의 차이는 선언 앞에 abstract 키워드가 붙는다는 점이다.
- 상속받으면
	- 하위 클래스는 선언된 메서드의 실제 구현부를 반드시 만들어야 한다.
	- 인터페이스와 같이 구현부 작성의 의무가 존재한다.
	- 이를 '하위 클래스에 구현을 위임한다'라고 표현한다.
	- 이런 위임이 '추상화'의 특징이다.

## 3.3.4 템플릿

- 팩토리 메서드와 템플릿 메서드의 공통점 -> 템플릿 구성
	- 템플릿은 모두 추상화를 통해 구성한다.

## 3.3.5 계층 구조

- 상위 클래스는 구조화된 뼈대를 형성
- 하위 클래스는 상위 클래스에서 선언한 뼈대를 바탕으로 실제 구현부를 작성

# 3.4 하위 클래스

## 3.4.1 상속

- 추상화를 통해 확장된 팩토리 메서드는 반드시 구현클래스를 만들어야 객체를 생성할 수 있다.

```php

class ProductFactory extends Factory
{
	public function _contstruct()
	{
		echo _CLASS_."를 생성합니다.\";
	}
}

```

- extends를 이용해 상속받는다.
- 하위 클래스에선 실제 구현을 작성한다.


## 3.4.2 메서드 구현

```php
abstract public function createProduct();
```

```php
<?php

// 팩토리 메서드 구현 부분

class ProductFactory extends Factory
{
public function __

construct()

{

echo

__

CLASS__."를 생성합니다.\n";

}

public function createProduct() // 추상 메서드 오버라이딩

{

return new LgProduct();

}

}
```


- createProduct는 new 키워드로 객체를 직접 생성해 반환하고 있다.
	- 이전에는 클래스 이름을 구체적으로 명시하여 객체를 생성했지만, 
	- 팩토리 메서드 패턴은 위임된 하위 클래스에서 메서드 호출로 객체를 생성한다.

- new 키워드를 직접 사용하여 객체를 생성하지 않고, 추상화로 재구현된 메서드를 호출함으로써 객체 생성을 처리한다.
	- 덕분에 상위 추상 클래스는 느슨한 코드를 작성할 수 있다.
	- 단계별 클래스를 상속하고 하위 클래스로 위임함으로써 의존성을 제거할 수 있다.
	- 팩토리 메서드 패턴은 객체를 생성하는 뼈대를 형성할 때 자주 응용한다.
- 이제 실제 객체를 생성하고 반환받기 위해서는 상속받은 하위 클래스를 사용한다. 

### 3.4.3 객체를 생성하는 객체

- 생성 패턴의 특징 : 
	- 생성을 담당하는 객체가 요청된 객체를 생성한다는 것이다
- 팩토리 메서드는 일반 팩토리 패턴보다 동작이 다소 복잡하다.
	- 팩토리 메서드에서 주목할 것은 객체 생성을 위한 인터페이스를 정의하는 것이다. 
	- 인터페이스를 통해 의존성을 낮추고 보다 일반적인 코드로 생성 패턴을 구현할 수 있다.

## 3.4.4 다형성




---

- 나의 질문 : 
	- 팩토리 패턴은 왜 쓰는거지? 어떤 문제점을 해결하려는거지?
	- 객체의 생산과 사용을 분리하는 이유는 뭐지?