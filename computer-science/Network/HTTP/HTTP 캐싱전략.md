## HTTP1.1's caching machanism 

HTTP/1.1 은 분산 정보 시스템의 성능을 향상시키기 위해 캐싱 기능을 사용하도록 설계되었다. HTTP1.1의 캐싱 메커니즘은 캐싱이 잘 동작하도록 여러 요소를 포함한다. 주요 캐시 키는 요청 방법과 대상 URI이며, 적절한 캐시 키로 정의된 경우 GET 이외의 응답도 캐시 엔트리의 일반적인 형태가 된다. 
Vary 헤더는 캐시된 응답을 사용할 수 있는지 여부를 결정하기 위해서 미래 요청 헤더를 어떻게 일치시킬지 결정한다. max-age=N요청 지시어는 클라이언트가 원본 서버에서 생성 저장된 응답을 N초 이내에 사용할 수 있다는 것을 나타낸다. 


--- 

## [HTTP Cache로 불필요한 네트워크 요청 방지](https://web.dev/i18n/ko/http-cache/) 

### 브라우저 호환성 

실제로 HTTP 캐시라는 단일 api는 존재하지 않는다. 웹 플랫폼 API 집합에 대한 일반적인 이름이라고 보면 된다. 이러한 API는 모든 브라우저에서 지원되는 기능이다. 
- Cache-Control 
- ETag 
- Last-Modified 

### HTTP 캐시 작동 방식 

- 브라우저가 제공하는 모든 HTTP 요청은 먼저 브라우저 캐시로 라우팅되어 요청을 수행하는 데 사용할 수 있는 유효한 캐시 응답이 있는지 확인한다. 
	- (요청을 보내면 먼저 캐싱되어 있는 데이터가 있는지 확인한다는 말) 
- 일치하는 항목이 있으면 캐시에서 응답을 읽어 네트워크 대기 시간과 전송으로 인해 발생하는 데이터 비용을 모두 제거한다. 
	- (캐시된 응답을 보내게 되면 데이터 전송에 필요한 비용이 발생하지 않는다는 말이다. )

- HTTP 캐시의 동작은 요청 헤더와 응답 헤더의 조합에 의해서 제어된다. 이상적인 시나리오에서는 웹 애플리케이션의 코드와 웹 서버의 구성을 모두 제어할 수 있다. 
	- 그러니까 헤더를 어떻게 조작하느냐에 따라서 캐시의 동작이 달라질 수 있다는 것이다. 이 헤더에도 2가지 헤더, 응답 헤더와 요청헤더. 이 2가지를 조작함으로써 동작이 달라지는 것이다. 


### 요청헤더 : 기본값 유지(일반) 
- 웹 앱의 송신 요청에 포함되어야 하는 중요한 헤더가 많다. 하지만 브라우저는 요청을 할 때 거의 항상 사용자를 대신해서 브라우저가 직접 헤더를 설정한다. 
- `If-None-Match` 나 `If-Modified-Since` 는 새로 고침 검사에 영향을 미치는 요청 헤더이다. 이런 헤더들은 HTTP 캐시의 현재 값에 대해서 브라우저가 어떻게 이해하고 있느냐에 따라서 표시되는 값이 달라진다. 
	- [[If-None-Match]]
- 이것은 좋은 소식이 될 수 있다. 왜냐하면 HTML에 `<img src="my-image.png" >` 와 같은 태그를 계속 포함할 수 있다는 의미가 되며, 브라우저는 별도의 작업 없이도 사용자를 위해서 자동으로 HTTP캐시를 처리한다는 의미가 되기 대문이다. 


### 응답헤더 : 웹 서버 구성 

HTTP 캐싱 설정에서 가장 중요한 부분은 웹 서버가 각 발신 응답에 추가하는 헤더이다. 다음의 헤더들은 모두 효과적인 캐싱 동작에 영향을 미치는 것들이다. 

- Cache-Control : 서버는 Cache-Control 지시문을 반환하여 브라우저 및 기타 중간 캐시가 개별 응답을 캐시하는 방법과 기간을 지정할 수 있다. 
- ETag : 브라우저가 만료된 캐시 응답을 찾으면 작은 토큰(일반적으로 파일 내용의 해시)을 서버로 보내 파일이 변경되었는지 확인할 수 있다. 서버가 동일한 토큰을 반환하면 파일이 동일하므로 다시 다운로드할 필요가 없다. 
- Last-Modified : 이 헤더는 ETag와 동일한 목적을 위해서 사용된다. 하지만 시간 기반 전략을 사용한다. 그래서 ETag의 콘텐츠 기반 전략과 반대로 리소스가 변경되었는지 여부를 판단한다. [[Last-Modified]]

일부 웹 서버는 기본적으로 해당 헤더를 설정할 수 있도록 지원하는 기능이 내장되어 있다. 하지만 다른 웹 서버는 헤더를 명시적으로 구성하지 않는 한 헤더를 완전히 생략한다. 헤더를 구성하는 방법에 대한 구체적인 세부 정보는 사용하는 웹 서버에 따라서 상당히 달라진다. 때문에 가장 정확한 세부 정보를 얻으려면 서버 설명서를 참조해야 한다. 

Cache-Control 응답 헤더를 생략한다 할지라도, HTTP 캐싱이 비활성화되지는 않는다. 대신, 브라우저는 어떤 유형의 캐싱 동작이 주어진 유형의 내용에 가장 적합한지 효과적으로 추측한다. 응답 헤더를 구성하는 것보다 더 많은 제어 권한을 원할 수도 있다. 그렇다면 조금 더 신경을 써서 응답 헤더를 구성해보자. 


### 어떤 응답 헤더 값을 사용해야할까? 

웹 서버의 응답 헤더를 구성할 때 다루어야 하는 두 가지 중요한 시나리오가 있다. 


#### 버전 지정된 URL에 대한 장기 캐싱 

- 버전이 지정된 URL에 대해서는 캐싱된 응답을 더 쉽게 무효화하므로 좋은 방법이라고 할 수 있다.
	- 서버가 브라우저에 CSS 파일을 1년 동안 캐시하도록 지시(Cache-Control : max-age=31536000) 했지만 디자이너가 즉시 출시해야 하는 긴급 업데이트를 방금 수행했다고 가정해보겠다. 파일의 'stale' 캐시 사본을 업데이트하도록 브라우저에 알리려면 어떻게 해야 하는가? 적어도 리소스의 URL을 변경하지 않고는 불가능하다. 브라우저가 응답을 캐시한 후 캐싱된 버전은 max-age 또는 expires에 의해 더 이상 최신 상태가 아닐 때까지 사용되거나 예를 들어서 사용자가 브라우저 캐시를 삭제하는 것과 같은 다른 이유로 캐시에서 제거될 때까지 사용된다. 따라서 페이지가 구성될 때 서로 다른 사용자가 다른 버전의 파일을 사용하게 될 수 있다. 리소스를 방금 가져온 사용자는 새 버전을 사용하는 반면, 이전 복사본을 캐시한 사용자는 이전 버전의 응답을 사용한다. 클라이언트 측 캐싱과 빠른 업데이트의 두 가지 장점을 모두 활용하려면 어떻게 해야 할까? 리소스의 URL을 변경하고 사용자가 콘텐츠가 변경될 때마다 새로운 응답을 다운로드하도록 강요한다. 일반적으로 파일 이름에 해당 내용을 내장하도록 한다. `style.x234dff.css` 처럼 파일 지문 또는 버전 번호를 내장해서 이를 수행한다. 

- 변경되지 않는 URL에 대한 요청에 응답할 때 응답에 `Cache-Control : max-age=31536000`을 추가할 수 있다. 이 값을 설정하고나면 향후 1년 동안 동일한 URL을 로드해야 할 때, 웹서버에 네트워크를 요청할 필요 없이 HTTP 캐시긔 값을 즉시 사용할 수 있다. 네트워크를 피함으로써 얻을 수 있는 신뢰성과 속도를 즉시 얻을 수 있다. 

#### 버전 없는 URL에 대한 서버 재검증 

- 불행하게도 로드하는 모든 URL의 버전이 지정되는 것은 아니다. 웹 앱을 배포하기 전에 빌드 단계를 포함할 수 없으므로 자산 URL에 해시를 추가할 수 없다. 그리고 모든 웹 어플리케이션에는 HTML 파일이 필요하다. 이 파일에는 버전 정보가 포함되어 있지 않다. 방문한 URL이 `https://example.com/index.34def12.html`임을 기억해야 하는 경우 어느 누구도 해당 URL의 사이트를 이용하려 하지 않을 것이다. 그렇다면 해당 URL에 대해 무엇을 할 수 있을까? 
- 이것은 패배를 인정해야하는 시나리오이다. HTTP 캐싱 만으로는 네트워크를 완전히 피할 수 있을 만큼 강력하지가 않다. 그러나 네트워크 요청이 최대한 빨리 가능한 효율적으로 이루어지도록 하기 위해 취할 수 있는 몇 가지 단계가 있다. 
- 다음 Cache-Control 값은 버전이 지정되지 않은 URL이 캐시되는 위치와 방법을 미세 조정하는 데 도움이 될 수 있다. 
	- no-cache : 이는 캐시된 URL 버전을 사용하기 전에 매번 서버에서 유효성을 다시 확인해야 한다고 브라우저에 지시한다. 
	- no-store : 이는 브라우저와 다른 중간 캐시가 파일의 어떤 버전도 저장하지 않도록 지시한다. 
	- private : 브라우저는 파일을 캐시할 수 있지만 중간 캐시는 캐시할 수 없다. 
	- public : 응답은 모든 캐시에 의해 저장될 수 있다. 
- 위의 Cache-Control과 함께 ETag 또는 Last-Modified 두 개의 추가 응답 헤더 중 하나를 설정하는 것도 도움이 될 수 있다. 응답 헤더에서 언급했듯이 ETag와 Last-Modified 모두 브라우저가 만료된 캐시된 파일을 다시 다운로드해야 하는지 여부를 결정하는 동일한 목적을 수행한다. ETag가 더 정확하기 때문에 권장되는 접근 방식이다. 
- ETag 또는 Last-Modified 를 설정하면 재검증 요청을 훨씬 더 효율적으로 만들 수 있다. 요청 헤더에 언급되어 있는 If-Modified-Since 또는 If-None-Match 요청 헤더를 트리거할 수 있다. 
	- 적절하게 구성된 웹 서버가 수신 요청 헤더를 볼 때, 브라우저가 HTTP 캐시에 이미 가지고 있는 리소스의 버전이 웹 서버의 최신 버전과 일치하는지 확인할 수 있다. 일치하는 항목이 있는 경우 서버는 `304 Not Modified` HTTP 응답으로 응답할 수 있다. 이는 "이미 가지고 있는 것을 계속 사용하라는"것과 동일하다. 이러한 유형의 응답을 보낼 때 전송할 데이터가 거의 없으므로 요청되는 실제 리소스의 복사본을 실제로 다시 보내는 것보다 훨씬 빠르다. 