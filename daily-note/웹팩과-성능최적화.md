
- 웹페이지의 로드 타임에 영향을 많이 미치는 3가지 : 
	- Amount of JS for Initial DownLoad : 이 중에서도 가장 영향을 많이 미치는 것은 js 파일이다. 이것이 most expensive하다 
	- Amount of Css for initial Download 
	- Amount of Network requests on Initial download 


- 목표 : 
	- <= 200kb (initial js)
	- <= 100kb (inital css)
	- http : <= 6 initial network calls 
	- http/2 : <= 20 initial network calls 
	- 90% code coverage 
		- 이것이 의미하는 것은 초기에 렌더링된 코드들 중에서 90%의 코드가 실제로 사용되고 있는 코드여야 한다는 것이다. 초기 페이지에서 
- 왜 저 정도 수치로 목표를 제시하는 것일까? 
- 어쨌든 이런 목표는 너무 높은 목표라고 생각될 수 있지만, 초기 렌더링시 받아오는 리소스의 양이고, 이것을 목표로 삼고 나아가보자. 


## code coverage를 어떻게 측정할까? 

-  크롬의 개발자 툴에 들어가면 coverage를 확인할 수 있다. 


## code splitting이란 ? 

- process of splitting pieces of your code into async chunks 
- 코드 스플리팅을 한다는 것은 빌드 타임에 lazy load할 것을 분리시킨다는 것이다. 그리고 이것은 웹팩의 설정을 통해서 할 수 있을 것이다. 


### types of code splitting 

- 일반적으로 웹사이트는 상호작용을 위해서 14초 정도 걸린다. 만약 이것보다 더 빠르게 상호작용이 가능하다면, 당신의 사이트는 평균보다 빠르다는 것이다. 
- 2가지 종류가 있는데, 
	- static code splitting
	- dynamic code splitting 
- dynamic이 정말 중요하다. `there is nothing in webpack that is purely dynamic `

- static code splitiing : 
	- when to use : 
		- heavy js : 맨 처음에 three.js 라이브러리를 사용하지 않고, 아직 들어가지 않은 페이지들은 필요하지도 않는데, 왜 download를 해야하는 것일까. 할 필요가 없다. 그냥 필요할 때 load하면 된다. 
		- anything temporal : 뭐 스크롤를 내려야 보인다던지, 버튼을 클릭해야 보이는 것들을 굳이 초기 렌더링시에 가져올 필요가 있을까? 
		- routes : 사용하지 않는 페이지 

psude code :
```js
import Listener from "./listener.js"

const getModal = () => import("./src/modal.js");

Listener.on("didSomthingToWarrentModalBeingLoaded", () => {
	// Async fetching modal code from a separate chunk 
	getModal().then((module) => {
		const modalTarget = document.getElementById("Modal");
		module.initModal(modalTarget);
	})
})
```