- [패키지 매니저 고르기](https://www.youtube.com/watch?v=Ds7EjE8Rhjs)  
	- 기존에 자바스크립트는 모듈을 지원하지 않았었다. 초창기 자바스크립트는 모듈로 분리할 만큼 크지 않았다. 
	- 패키지란? 모듈이 많아지고 커지면, 이것을 관리하기 위한 도구도 필요하다. 이것이 패키지다. 
	- npm의 등장. 패키지가 많아지면 그것을 관리하기 위한 도구도 필요. 
		- 여러 버전의 동일한 패키지를 한 프로젝트에서 사용할 수 있게 하자. 
		- 설치 방식을 통일하자. 
		- 패키지 관련 정보가 들어있는 메타 데이터를 간소화하자. 
		- 누구나 배포할 수 있도록 하자. 
		- 사용되는 파일들 
			- node_modules
				- 설치를 하고자 하는 패키지들이 담겨있는 폴더
			- package.json
				- 그 패키지들을 제공할 수 있는 cli와 메타 데이터를 제공한다. 
			- .npmrc
			- package-lock.json
	- yarn(yet another resource negotiator) 
		- 병렬화를 통한 속도 개선 
			- npm은 병렬화 x. yarn은 병렬화를 통해 속도를 개선함. 
		- 자동화된 lock 생성 
		- 의존성 트리 알고리즘 변경 
			- 의존성 트리가 덜 변경되도록 만드는 것이 목적. 
		- 캐시 사용 
			- 캐시를 가지고 있어서 기존에 다운 받았던 패키지들을 기억할 수 있다.  
			- 캐시 안에 기존에 다운로드 받았던 내용들을 기록해놓아서 그 내용들을 다운받지 않도록 하여 속도를 개선했다. 
			- Yarn은 패키지를 설치할 때마다 그 패키지의 복사본을 로컬 캐시 디렉토리에 저장합니다. 이후 동일한 패키지를 요청하면 Yarn은 네트워크 호출을 수행하는 대신 이 로컬 캐시를 사용하여 패키지를 더 빠르게 설치할 수 있습니다.
	- npm 계열의 한계 :
		- 비효율적인 의존성 검색 : 
			- 패키지가 없다면 부모부터 루트까지 순차적으로 패키지를 찾아나가게 된다. 만약 패키지가 없다면 계속해서 찾아나간다는 단점이 존재한다. 중간에 잘못된 버전이나 의존성을 가지고 있어도 그것을 검색해서 사용해버릴 수 있는 치명적인 단점이 존재한다. 
		- 유령의존성 : 
			- 프로젝트에서 직접적으로 사용되지 않지만, 의존성 트리의 일부 다른 패키지에 의해 필요로 하는 의존성
				- npm은 특정 버전의 패키지를 요구하는 모든 패키지에 대해 별도의 복사본을 유지함
				- 디렉토리에는 불필요하게 많은 패키지가 포함될 수 있습니다. 또한, 이로 인해 의존성 트리는 복잡해지고, 관리가 어려워질 수 있습니다.
			- package.json에 명시가 되어 있지 않다는 것이 문제. a1 -> b1에서 b1을 실제로 사용중인데, a1을 삭제해버리면 b1도 쥐도새도 모르게 삭제될 수 있다. 
		- node_modules가 너무 무겁다는 것이 문제다 : 
	- pnpm 
		- 평탄화 되지 않은 node_modules를 사용하겠다. 
		- 그리고 중복된 패키지가 있으면 레지스트리에 넣어두고 그것을 참조하여 사용하겠다는 구조. Symbolic Link를 이용해서 사용.
		- 다운로드 수를 줄이고 링크를 활용하는 방법으로 효유성을 높인 방식. 
	- yarn berry 
		- node_modules와 node에 내장된 의존성 관리 없이 의존성을 관리하면 어떨까? 
			- 때문에 yarn2에서는 node_modules가 없다. 
			- pnp라는 생소한 녀석이 생김. 
		- cache : zip 파일이 생성된다. 패키지를 zip 파일로 저장하는 방식이다. 3가지 이점이 있다. 
			- 1. zero install : yarn install을 하지 않아도 된다. cache 되어 있는 파일을 사용하기 때문에 yarn install이 불필요해진다. 
			- 2. 오프라인에서 캐싱 기능으로 사용가능해진다. 
			- 3. ci 배포시에 clone만 하면 의존성이 다 있기 때문에 배포 속도를 줄일 수 있다. 
			- 덕분에 폴더도 줄어들고, 용량도 줄어든다. 
		- 어떻게 관리할 것인가? plug'n'play 방법으로 한다. 코드만 꼽으면 바로 실행가능하다. pnp.cjs 파일을 확인해보면 알 수 있다. 
			- 어떤 페키지인지, 어떤 버전인지, 어느 위치에 있는지, 어떤 의존을 참조하는지. 등등의 내용이 pnp.cjs에 들어가 있다. 
- [yarn.lock과 package-lock.json](https://www.youtube.com/watch?v=E2HSpcN-ir4) 
	- lock 파일이란 무엇인가? 프로젝트 종속성에 대한 정보를 저장하고 있다. 프로젝트에 설치된 정확한 버전정보와 패키지 간의 의존성 정보 관계를 저장하고 있다. 
	- 이 파일이 중요한 이유는 주로 팀으로 협업할 때 부각된다. 
		- 주로 패키지에 대한 버전이 명확하게 명시되어있는 것이 아니라, 특정 버전 이상과 같은 방식으로 적혀있다. 그리고 그 상태로 패키지들을 설치하게되면 제일 최신 버전의 패키지를 설치하게 된다. 그러면 매번 시점에 따라 다르게 패키지를 설치하게 될 때, 다른 버전의 패키지를 설치하게 되고, 그러면 팀원들 간의 협업이 어려워지게 된다. 
	- lock 파일의 중요성 
		- 일관성 
			- 같은 버전의 패키지를 사용함으로써 일관성을 유지할 수 있다. 버전관련 문제를 방지할 수 있다. 
		- 안정성
			- lock 파일이 없으면, 버전이 자동으로 업데이트 될 수도 있다. 
		- 속도 향상 
			- lock 파일은 패키지에 대한 정확한 버전 정보를 포함하고 있기 때문에 패키지를 빠르게 설치할 수 있다. 성능에 긍정적인 영향을 미친다. 