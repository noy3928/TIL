
- 함수형에는 성능상의 문제는 없을까? 
	- 많은 사람들이 의심하는 부분이지만, FP도 성능이 그렇게 나쁘지는 않다. 
- 이번 장에서는 함수형의 성능을 이해하기 위해서 몇가지 js의 단면을 이해하고, 최적화 기법을 알아볼 것이다. 
	- 최적화 기법 : 느긋한 평가, 메모화, 꼬리 호출 최적화 
- 함수형이 최적화를 수행하는 방법 : 
	- 함수 중복 호출을 피해서 코드가 정말 필요할 때까지 평가를 지연시키는 전략 


## 7.1 함수 실행의 내부 작동 원리 

- js에서는 함수가 실행되면 실행 컨텍스트가 쌓인다. 
	- 그런데 커링을 과도하게 사용하면 실행 컨텍스트에 안좋은 영향을 미칠 수 있다. 


### 7.1.1 커링과 함수 콘텍스트 스택 

- 커링을 사용하면 오버헤드가 더 많이 발생할 수 있다. 
- 커링을 사용하면 함수가 중첩된 구조로 바뀐다. 
	- 중첩된 구조로 바뀌었다는 것은 콜스택에 쌓이는 함수 스택이 많아졌다는 의미가 된다. 
	- 때문에 이것이 깊이 중첩되게 되면 메모리를 과대하게 점유할 가능성이 생긴다. 


### 7.1.2 재귀 코드의 문제점 

- 재귀를 사용해도 콘텍스트 스택에 문제가 생길 수 있다.
	- 종료시점을 정확하게 명시하지 않을 경우 스택오버플로우가 발생할 수 있다. 

<br>
## 7.2 느긋한 평가로 실행을 늦춤 

- 느긋한 평가의 근본적인 사상 : 
	- 가능한 한 오래, 의존하는 표현식이 호출될 때까지 미룬다. 
- 조급한 평가전략은 곧 바로 평가를 수행하지만, 느긋한 평가전략은 평가를 요구하는 시점까지 평가를 미룬다. 
- 이런 느긋한 평가는 어떻게 활용할 수 있을까? 
	- 불필요한 계산을 피한다. 
	- 단축 융합을 사용한다. (shortcut fusion)

### 7.2.1 대체 함수형 조합으로 계산을 회피 

- 조건에 따라서 한 쪽만 호출하여 쓸데 없는 계산을 피하는 것이다. 
	- alt 조합기가 예시가 될 수 있다. 
	- 이를 통해 중복을 줄이고, 불필요한 함수 계산을 간단하게 넘어갈 수 있다. 

```javascript
const alt = R.curry((func1, func2, val) => func1(val) || func2(val));
```


### 7.2.2 단축 융합을 활용 

- 단축융합이란 몇 개의 함수 실행을 하나로 병합하고 중간 결과를 계산할 때 사용하는 내부 자료구조의 개수를 줄이는 함수 수준의 최적화이다. 
	- 자료구조가 줄면 대량 데이터를 처리할 때 필요한 과도한 메모리 사용을 낮출 수 있다. 
	- 이것이 가능해질 수 있는 근거는 전적으로 함수형의 참주 투명성에 관한 규칙 때문이다. 


<br>

## 7.3 필요할 때 부르리 전략 

- 반복적인 계산을 피하는 것은 성능을 끌어올리는 한 가지 방법이다. 
- 이를 위해 캐시라는 전략이 존재한다. 
	- 단순히 캐시전략만 생각했을 때는 한계점이 존재한다. 
		- 모든 함수에 래퍼를 두고 호출하는 것은 버겁다. 
		- 전역 공유 캐시 객체에 의존하게 된다. 
- 이런 캐시의 한계를 해결하기 위해 함수형에선 메모화라는 메커니즘이 존재한다. 


### 7.3.1 메모화 

- 함수 인수로 키값을 만들고, 이 키로 계산 결과를 캐시에 보관해두었다가, 이후 다시 같은 인수로 함수를 호출하면 보관된 결과를 즉시 반환한다는 로직은 방금 전 코드와 같다. 
- 이런 원리 또한 함수형의 참조 투명성 규칙 덕분에 가능해진다. 
	- 같은 인자에 같은 값이 나온다는 확신이 있기 때문에 사용가능해지는 규칙이다. 

<br>
### 7.3.2 계산량이 많은 함수를 메모화 

- 계산량이 많은 함수를 메모화하면 속도를 상당히 높일 수 있다. 
	- 하지만 이런 메모화에서도 인수가 많아지면 복잡하고, 비싼 연산을 수반하게 된다. 
	- 이를 위해 커링을 사용할 수 있다. 


### 7.3.3 커링과 메모화를 활용 

- 커링을 활용하면 다항 인수 함수를 단항 인수 함수로 바꿀 수 있다. 
- 이를 통해 효율적으로 메모화를 진행할 수 있다. 


### 7.3.4 분해하여 메모화를 극대화 

- 코드를 잘게 나눌수록 메모화의 효과는 득대화 된다. 

### 7.3.5 재귀 호출에도 메모화를 적용 

- 재귀에서도 메모화를 적용할 수 있다. 

<br>

## 7.4 재귀와 꼬리 호출 최적화 

- 재귀는 일반 프로그램보다 스택 소비량이 훨씬 많다. 
	- 재귀를 일반 루프만큼 실행을 최적화할 방법은 없을까? 
	- 꼬리재귀호출을 수행하도고 하면 된다. 

- 꼬리재귀호출은 재귀뿐만 아니라, 마지막 행위가 다른 함수를 호출하는 어떤 함수에도 적용할 수 있다. 

- 꼬리 호출 최적화가 최적화인 이유 :
	- 재귀 함수가 가장 마지막에 함수를 호출하면, 자바스크립트 런타임은 남은 할 일이 없기 때문에 더 이상 현재 스택 프레임을 붙들고 있을 이유가 없어진다. 따라서 그대로 폐기한다. 