## 제목 고민 :

- 프론트엔드 개발자가 알아야 할 5가지 디자인 패턴
- 프론트엔드 개발자가 디자인 패턴을 알아야 할까요?
- 프론트엔드인 당신이 이 5가지 디자인 패턴을 알아야 하는 이유

부제 : 이 글을 읽으면 당신의 성장속도는 145% 상승합니다.

# 서문 :

- 이 글은 전부 읽는데 1-2시간 정도가 소요될 것이다. 때문에 이 글을 읽고자 하시는 분들은 시간을 내어, 찬찬히 습득해보시기를 추천한다. 아니면, 하루에 패턴 1개씩 읽으면서 습득해나가는 것도 여러분들의 시간을 활용하기에 좋은 방법이 될 것이라고 생각한다.
- 최대한 내가 읽었던 참고자료들을 이 글에도 녹여내기 위해서 노력했다. 이 글을 통해서 내가 알려드리는 디자인 패턴에 대한 이해도를 높이게 되기를 바라고, 나아가서 다른 자료를 읽을 때도 도움이 되는 배경지식이 되기를 바란다.
-

# 디자인 패턴이란 무엇인가?

- time-tested solutions to recurring design problems
- 디자인 패턴은 시간에 의해 검증된 해결방안이다.
- 일반적으로 마주할 수 있는 문제에 대한 잘 설계된 solution이다.

- 이것은 일종의 템플릿이라고 생각해도 괜찮다.

> In software engineering, a design pattern is a general reusable solution to a commonly occurring problem in software design.

> A design pattern is a general reusable solution to a commonly occurring problem within a given context. What does that mean?
> Programmers often encounter the same problem repeatedly. Rather than have everyone come up with their own solution to common programming issues, we use a best practice type solution that has been documented and proven to work.
> The word general is important. We cannot just copy and paste a design pattern into our code. A design pattern represents an idea, and we should write an implementation for that pattern and implement that in our code.

- 디자인 패턴은 언어에 제한이 있는 종류의 것이 아니다. 모든 언어에서 구현가능한 방식이다.
  It is not exactly language exclusive but is applicable to all languages that has a certain structural feature enabled.

### 디자인 패턴의 역사적 기원

- Christopher Alexander
  - 토목 엔지니어
    ![](https://velog.velcdn.com/images/yesbb/post/59bc6e6d-596c-4291-b816-ecc5ebf5c86f/image.webp)

이 사람이 건축을 하면서 만들게 된 디자인 원칙이 있었다. 그리고 그런 원칙 아래에서 작업을 할 때, 효율이 있다는 것을 발견했다. 본인이 깨달은 인사이트를 [저술](https://www.amazon.com/-/dp/0195019199)로 전파하면서 이런 디자인 원칙은 점차 유명해지기 시작했다. 아마 이 저술에는 건축물의 패턴에 대한 소개를 하고 있을 것이다.

그런데 개발자들은 이런 pattern 이라는 개념을 개발을 할 때에도 적용시키기 시작했다. 그런 시도가 책으로 처음 출판된 것이 바로 아래의 책이다.

<p><img src="https://velog.velcdn.com/images/yesbb/post/8c9ad010-0d16-4785-9073-58b3f2aaf2d8/image.jpeg" height="100px" width="300px"></p>

이 책이 출판된 이후로, 디자인 패턴에 대한 연구와 커뮤니티는 점점 커지게 되었다. 이 책에 기록된 패턴은 총 23가지로, 당시의 저자들의 경험을 토대로 기록한 것들이다. 그러나 디자인 패턴은 오늘날에까지 이르면서 수 없이 많이 등장하게 된다.

- 디자인 패턴은 문제해결을 위해서 객체와 클래스가 어떤 관계를 맺고 있는지를 보여준다.

[history](https://refactoring.guru/design-patterns/history)

### 디자인 패턴의 장점

디자인 패턴은 2가지 큰 유익을 가진다. 1)그들은 이미 검증된 솔루션을 제공해준다. 이런 솔루션들은 결합도는 낮으면서, 응집도는 높게 개발할 수 있도록 도와준다. 2)디자인 패턴은 커뮤니케이션의 유익을 가져다준다. 설계의 단계에서 특정 문제해결에 대한 솔루션을 단순히 패턴의 이름을 언급함으로써 즉시 이야기 해볼 수 있다. 이미 알려진 패턴을 공유하며 대화한다면, 커뮤니케이션의 비용을 줄일 수 있다. 3)일반적으로 알려진 문제에 대한 보편적인 해결책을 제공해줌으로써, 가독성 및 유지 보수성도 높일 수 있다.

This means that rather than just creating code based on the default and seemingly obvious path, design patterns makes you take a step back, away from the code, and towards the logical thinking portion of the code creation process.
As a result, your thinking process is able to ascribe to different modes of logic and its implementation based on context, current, and future requirements.
And with this knowledge and ability, a developer is able to make code less entangled and more structured in nature. It also allows the code to be flexible, rather than brittle when changes and pivots in requirements are introduced.
This is why we use design patterns and how it can help us work much more effectively, as much as it can help us with our team based code coordination and cohesive construction abilities.

[](https://www.dottedsquirrel.com/observer-pattern-javascript/)

- [it gives developers a common vocabulary to talk about software solutions.](https://stackoverflow.com/questions/978489/how-important-are-design-patterns-really)

### 디자인 패턴의 단점 : 디자인 패턴에는 유익만 있는가?

그렇지는 않다. 디자인 패턴의 단점도 존재한다.

- 디자인 패턴은 어쩌면 문제해결에 대한 사고를 가로막을지도 모른다. 더 나은 해결책을 생각해낼 수 있음에도 불구하고, 특정 패턴에 가로막힐 수도 있다는 것이다.

- 조그만한 기능을 위해서 과도한 코드를 만들어낼 수도 있다는 단점이 있다.

[Design pattern: what is it and why use it?](https://ryax.tech/design-pattern-what-is-it-and-why-use-it/)
[What Are Design Patterns and Do I Need Them?](https://www.developer.com/design/what-are-design-patterns-and-do-i-need-them/)

# 디자인 패턴을 공부해야 하는 이유

아마 디자인 패턴을 공부하지 않아도, 개발을 할 수 있을 것이다. 그러나 당신도 모르게 특정 디자인 패턴을 적용하고 있을지도 모른다. 아마 대부분의 사람들이 이와 비슷한 상황일 것이다. 그럼에도 불구하고 시간을 들여서 디자인 패턴을 공부해야 하는 이유는 무엇일까?

#### 1.널리 알려진 해결방법을 통해 문제를 해결하기 위해서 :

위에서 재차 설명했던 내용입니다. 디자인 패턴은 시간 속에서 검증된 문제해결책입니다. 여러분들이 특정 문제에 닥쳤을 때, 특정 디자인 패턴을 떠올림으로서 쉽게 문제를 해결할 수 있을 것입니다.
거인의 어깨위에 올라서서 멀리 내다보라는 말이 있습니다. 무슨 말이냐 하니, 과거 속에 위대한 업적을 이룬 인물의 업적을 토대로 삼고 더 멀리 나아가라는 말입니다. 과거의 업적을 되풀이 할 이유는 없는 것이죠. 여기서 말하는 거인이란, 단순히 특정 한 인물이 될 수도 있지만, 과거의 유산이 될 수도 있습니다. 과거에 개발자 선배들이 특정 문제를 해결하기 위한 패턴을 만들어놓았다면, 저희는 그 패턴이라는 어깨를 밟고 더 멀리 내다볼 줄 알아야 합니다.  
켄트 백의 구현패턴이라는 책에선 이런 글이 나옵니다.

> 패턴은 반복적으로 일어나는 문제에 대한 합리적인 해결책을 제공해서 프로그래머가 남는 시간과 에너지, 창의력을 진정 독착정인 문제 해결에 사용할 수 있게 해준다. p.31

이 해결책을 토대로 삼아, 더울 효율적으로 다른 문제를 위해 시선을 돌리는 것이 나을 때도 있을 것입니다.

#### 2.의사소통의 효율성을 높이기 위해서 :

언급했듯이, 디자인 패턴을 사용한다는 것 자체는 커뮤니케이션의 비용을 상당히 줄여줄 수 있습니다. 그런데 여기에도 전제가 있습니다. 바로 당신이 그 디자인 패턴을 안다는 전제입니다.
문제해결을 위한 회의를 하는 중입니다. 그리고 팀장님이 말씀하시네요. '이 문제는 싱글톤 패턴으로 해결하면 되겠어.' 그런데 당신은 머릿속으로 생각합니다. '싱글톤 패턴...? 그게 뭐지..?!' 사실, 당신이 공용적으로 사용되는 디자인 패턴을 알고 있지 못하다면 그것은 커뮤니케이션 비용을 줄여주는 것이 되지 못합니다.

이런 의사소통의 효율을 높이기 위해서라도 여러분들은 디자인 패턴을 공부해야 합니다.

#### 3.성장속도를 높이기 위해서 : !important ✨

성장 속도가 빠른 사람들의 특징은 무엇일까요? 여러가지가 있겠지만, 해당 분야에 대한 기초가 튼튼한 사람들은 성장의 속도가 빠릅니다.

여기서 잠시, 기초가 무엇인가요? 여러가지로 정의를 내릴 수 있겠지만, 기초란 특정 기술을 이루고 있는 토대 및 근간, 다른 말로는 배경지식이라고도 할 수 있습니다. 이런 토대, 배경지식이 튼튼한 사람들은 그 분야의 또 다른 지식을 습득할 때도 빠르게 습득할 수 있습니다. 왜냐하면 그것이 전혀 새로운 것이 아니라, 자신이 알고 있는 여러 기초들이 종합된 기술이라는 것을 알고 있기 때문입니다.

여기에 저희가 디자인 패턴을 공부 해야하는 이유가 있습니다. 프론트엔드 개발자로써, 다양한 기술을 접하게 될 것입니다. 이런 기술들은 왜 탄생했을까요? 특정 문제, 불편함을 해결하기 위해서 탄생했습니다. 이 글에서 자주 등장하던 단어가 나왔습니다. '문제' 이것을 해결하기 위한 일반적인 해결책이 무엇이라구요? 디자인 패턴. 저희가 사용할 기술, 라이브러리도 다르지 않습니다. 그들도 특정 문제를 해결하기 위해서 디자인 패턴을 사용합니다. 이 말은 곧, 우리가 공부할 기술들은 여러 기둥으로 구성되어 있는데, 그 커다란 기둥 중 하나가 곧 디자인 패턴이라는 것입니다.

만약 여러분들이 특정 디자인 패턴에 대한 선행지식이 있고, 그 패턴을 지금 공부해야하는 기술이 사용하고 있다면 학습에 대한 부담감은 훨씬 더 떨어지지 않을까요? 분명히 디자인 패턴을 알고 있던 사람과 그렇지 않은 사람은 학습의 속도가 다를 수 밖에 없을 것입니다.

그렇다면 여러분들이 디자인 패턴을 공부하지 않을 이유가 무엇이겠습니까? 지금 당장 같이 공부해봅시다.

[Why should I learn patterns?](https://refactoring.guru/design-patterns/why-learn-patterns)

---

# 디자인 패턴의 3가지 카테고리

본격적으로 개별적인 디자인 패턴을 알아보기 전에, 먼저 큰 그림을 그려보겠습니다. 디자인 패턴도 크게 3가지 카테고리로 나눌 수 있습니다.
Creational Pattern, Structural Pattern, Behavioral Pattern 이 그것입니다.

## Creational Pattern (생성 패턴)

Creational design pattern은 특정한 상황에 알맞는 객체를 생성하는 메커니즘과 관련이 있습니다. 이런 디자인 패턴을 생겨난 이유는 다음과 같습니다. 기본적인 방식으로 객체를 생성하게 될 때, 설계상의 문제나 코드의 복잡성을 증가시키고 유연성을 떨어뜨릴 가능성이 있기 때문입니다. 이 카테고리에 해당하는 패턴으로 객체를 생성할 때 코드의 유연성과 재사용성을 증가시킬 수 있습니다.
아래는 이 카테고리에 해당하는 패턴들입니다.

- factory pattern : 클래스가 인스턴스화 하는 것을 하위 클래스에게 미룰 수 있는 패턴.
- abstract pattern : 구체적인 세부사항은 드러내지 않고, 인터페이스만 공개하는 방식으로 객체를 생성하는 패턴.
- builder pattern : 복잡한 객체의 생성을 여러 단계로 나누는 것이다. 그래서 객체를 생성하는 각각의 과정이 분명하게 드러날 수 있도록 하는 패턴.
- prototype pattern : 프로토타입 인스턴스를 사용하여 만들 객체의 종류를 지정하고 이 프로토타입을 복제하여 새 객체를 만드는 패턴.
- singleton pattern : 하나의 클래스는 하나의 인스턴스를 가지도록 보장하고, 전역에서 접근할 수 있도록 하는 패턴.

본 글에서 다루어 볼 creational pattern은 singleton pattern과 builder pattern 입니다.

## Structural Pattern (구조 패턴)

구조 패턴(Structural Pattern)은 작은 객체와 클래스들이 유연성과 효율성을 유지하면서 조합되어, 더 큰 구조를 만드는 패턴입니다. 쉽게 생각하면, 서로 다른 작은 클래스들이 하나의 큰 클래스에 모여 단일한 인터페이스를 제공하는 클래스를 생각해보면 될 것 같습니다.
이 카테고리에 있는 패턴들은 합성할 객체와 클래스들의 관계를 고려하고, 이 합성을 통해서 더 커진 객체에서 어떻게 기능을 추가할 것인지를 정의합니다. 특징으로는 다음과 같은 것들이 있습니다.

- 서로 독립적으로 개발한 클래스 라이브러리를 마치 하나인 것처럼 사용할 수 있다.
- 여러 인터페이스를 합성하여 서로 다른 인터페이스들의 통일된 추상을 제공한다.
- 인터페이스나 구현을 복합하는 것이 아니라 객체를 합성하는 방법을 제공한다.

그리고 이 카테고리에 속하는 디자인 패턴으로는 다음과 같은 것들이 있습니다.

- adapter pattern : 클라이언트가 기대하는 하나의 인터페이스로 조정하는 패턴
- bridge pattern : 추상화를 구현에서 분리하여 두 가지가 독립적으로 변할 수 있도록 하는 패턴
- composite pattern : 모든 객체가 동일한 인터페이스를 갖는 객체 트리 구조의 패턴
- decorator pattern : 하위 분류로 인해 새 클래스가 기하급수적으로 증가하는 런타임에 클래스에 기능을 추가하는 패턴
- facade pattern : 기존 인터페이스의 단순화된 인터페이스를 생성하여 일반적인 작업에 쉽게 사용 가능하게 하는 패턴
- flyweight pattern : 공간을 절약하기 위해 많은 수의 개체가 공통 속성 개체를 공유하는 패턴
- proxy pattern : 다른 것에 대한 인터페이스로 기능하는 클래스 패턴

본 글에서 다루어 볼 패턴은 adapter pattern 과 proxy pattern 입니다.

## Behaviral Pattern (행동 패턴)

행동 패턴은 객체와 클래스 사이의 소통에 관여하는 패턴이다. 이 카테고리에 속하는 패턴을 적용할 경우, 결합도를 낮추고 유연한 코드를 작성할 수 있게 도와줍니다. 만약 객체와 클래스 사이의 소통을 고려해야한다면, 이 카테고리에 속한 패턴들을 들여다보는 것이 좋을 것 같습니다. 대표적으로 아래와 같은 패턴들이 있습니다.

- chain of responsibilities pattern : 요청을 처리하는 기회를 하나 이상의 객체에 부여하여 요청을 보내는 쪽과 받는 쪽의 결합을 피하는 패턴.
- Command: 요청을 객체로 캡슐화하여 서로 다른 사용자의 매개변수화, 요청 저장 또는 로깅, 연산의 취소를 지원하게 만드는 패턴.
- Interpreter: 주어진 언어에 대해서 문법을 위한 표현수단을 정의하고, 해당 언어로 된 문장을 해석하는 해석기를 사용하는 패턴.
- Iterator: 내부 표현부를 노출하지 않고 어떤 객체 집합의 원소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴.
- Mediator: 한 집합에 속해있는 객체들의 상호 작용을 캡슐화하는 객체를 정의하는 패턴. 중재자는 객체들이 직접 서로 참조하지 않도록함으로써 객체들간의 느슨한 연결을 촉진시키며 객체들의 상호작용을 독립적으로 다양화 시킬 수 있도록 해준다.
- Observer: 객체들 사이에 1 : N 의 의존관계를 정의하여 어떤 객체의 상태가 변할 때, 의존관계에 있는 모든 객체들이 통지받고 자동으로 갱신될 수 있게 만드는 패턴
- State: 객체의 내부 상태가 변경될 때 행동을 변경하도록 허락하는 패턴. 객체는 자신의 클래스가 변경되는 것처럼 보이게 된다.
- Visitor: : 객체구조를 이루는 원소에 대해 수행할 연산을 표현한다. 방문자는 연산에 적용할 원소의 클래스를 변경하지 않고 새로운 연산을 재정의 할 수 있다.

[디자인 패턴 정의와 종류에 대하여](https://coding-factory.tistory.com/708)
[위키백과 : 구조패턴](http://wiki.hash.kr/index.php/구조패턴)
[design pattern catalog](https://refactoring.guru/design-patterns/catalog)
[How JavaScript works: Creational, Structural, and Behavioural design patterns + 4 best practices](https://blog.sessionstack.com/how-javascript-works-creational-structural-and-behavioural-design-patterns-4-best-practices-2e8beeba744c)
[Design Pattern Course](https://www.gofpatterns.com/creational/index.php)
[quora](https://qr.ae/pv5Ud6)

<br>

---

<br>

# 디자인 패턴 설명의 구조

이제 본격적으로 각각의 디자인 패턴을 설명하기에 앞서 템플릿을 소개하려 합니다. 제가 설명드릴 내용들은 아래의 템플릿 안에서 구성될 것입니다.

기본적으로 디자인 패턴은 객체와 클래스 간의 관계를 정의내리고 그것을 통해서 문제를 해결합니다. 아마 이런 구조 또한 그런 관계를 보여주는 것이 중심이 될 것입니다.

- 정의 : 해당 패턴이 무엇인지 소개합니다.
- 목적 및 동기 : 어떤 문제를 해결하기 위해서 만들어진 패턴인지, 이 패턴이 하는 일이 무엇이지를 소개합니다.
- 예시 : 해당 패턴을 쉽게 이해하기 위한 예시를 소개합니다.
- 구성요소 : 디자인 패턴 안에서 객체와 클래스들이 존재하는지 어떤 관계도를 가지고 있는지 설명합니다.
- 코드 : 실제로 해당 패턴이 코드로 어떻게 구현되어 있는지 살펴봅니다.
- 장단점 : 해당 패턴이 가지고 있는 장단점에는 무엇이 있는지 알아봅니다.

그럼 이제 정말 본격적으로 디자인 패턴에 대해서 알아보겠습니다.

# Creational Pattern 생성 패턴

가장 먼저 알아볼 패턴은 Creational Pattern 입니다. 생성패턴은 객체를 생성하는 방식을 다루는 패턴입니다. 이 글에선 Singleton Pattern과 Factory Pattern, Builder Pattern에 대해서 설명하겠습니다.

## 1.Singleton Pattern

가장 유명하고도, 기초적인 패턴이며, 논란이 많기도 한 싱글톤 패턴에 대해서 알아보겠습니다.

https://refactoring.guru/design-patterns/singleton

https://www.geeksforgeeks.org/singleton-design-pattern-introduction/

https://www.contentful.com/blog/2020/05/12/singleton-pattern-evil-or-misused/

### 정의 :

Singleton Pattern은 오직 하나의 객체만 생성하도록 만드는 방법입니다. 하나의 객체, 하나의 인스턴스만 생성함으로써, 이후에 생겨나는 인스턴스들은 최초에 생성된 인스턴스를 참조하도록 구성됩니다.

### 목적 및 동기 :

Singleton Pattern은 하나의 클래스만을 생성하도록 제한해야 할 때 필요합니다. 이렇게 인스턴스의 갯수가 몇개인지를 신경써야하는 경우는 언제일까요? 공유된 하나의 자원에 접근
여러 새로운 인스턴스를 가지고 접근할 수 있도록 허용해서는 안되는 상황에 적용할 수 있도록 만들어진 디자인 패턴입니다. 가령 예를 들면 데이터베이스를 예로 들 수 있습니다.

### 예시 :

### 구성요소 :

### 코드 :

오직 하나의 객체만 생성하도록 만드는 방법

```javascript
class Cat {
  constructor(name) {
    this.name = name
  }

  speak() {
    console.log(this.name, "meow")
  }
}
```

하나의 객체만 생성되도록 강제하는 패턴.

여러 가지 객체를 만들어도 결국 하나의 객체만 만들어지게 하는 것.

```javascript
class Singleton {
  static instance
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this
    }
    return Singleton.instance
  }
}

let s1 = new Singleton()
let s2 = new Singleton()

if (s1 === s2) {
  console.log("they are same, Singleton")
} else {
  console.log("they are not same")
}
```

분명히 다른 오브젝트를 만들었는데, 같은 객체라고 말하는 상황.

이런 싱글톤을 사용하게 되면, 아무리 많은 오브젝트를 만들어도 실제로는 모두 같은 오브젝트를 가리키고 있는 것이다.

우리가 관심있는 싱글톤 캣을 만들어보자.

```javascript
class SingleCat {
  static instance
  constructor(name) {
    this.name = name
    if (!SingleCat.instance) {
      SingleCat.instance = this
    }
    return SingleCat.instance
  }

  speak() {
    console.log(this.name, "meow")
  }
}

let sKitty = new SingleCat("kitty")
let sNabi = new SingleCat("nabi")

sKitty.speak()
sNabi.speak()

if (sKitty === sNabi) {
  console.log("they are same, Singleton")
} else {
  console.log("they are not same")
}
```

둘다 'kitty'를 내보내게 된다.

이 두 객체가 같다면

하나의 프로세스 안에서,

하나의 오브젝트가 리소스를 많이 차지 할때,

외부 네트워크와 연결하는데, 이 연결네트워크가 단 하나만 있어야 하는 경우가 있을 것 같다.

### 장단점 :

One instance, no flex :

The biggest problem with the singleton pattern is that you assume there will only ever be one instance. This is a big assumption to make and often comes back to bite you. What you end up with is completely inflexible code.

For example, some people argue that entries such as a sitemap should be a singleton. You only want one instance of your sitemap and a single access point. But many instances of a sitemap can exist, potentially tagged by the released version of the site itself. On load, the site fetches the sitemap entry tagged by the current version of the site. Therefore, old users still get a valid sitemap for the version they are on. If singleton were used here, it would break that behavior. This inflexibility is one of the biggest reasons why singleton is an antipattern.

Engineers often use singletons to provide a global access point. They are often used in place of a global variable that has a single instance. But most developers steer clear from global variables, and singletons should provoke the same response.

[singleton pattern evil or misused](https://www.contentful.com/blog/2020/05/12/singleton-pattern-evil-or-misused/)

## 2.Factory Pattern

### 정의 :

factory pattern은 생성 패턴에 속한 디자인 패턴으로써, 객체 생성하는 방식에 대한 패턴입니다. 이 패턴에서 상위 클래스는 객체 생성을 위한 인터페이스를 제공합니다. 그리고 하위 클래스에서 이 인터페이스를 활용해 만들어 낼 구체적인 객체의 타입을 지정하는 방식으로 이루어집니다.

### 목적 및 동기 :

생성자 패턴은 객체지향 프로그래밍에서 인스턴스화의 근본적인 문제점을 해결하고자 합니다. 인스턴스화의 근본적인 문제점은 무엇일까요? 클래스를 통해서 인스턴스를 생성할 수 있지만, **유연성이 떨어진다**(inflexibility)는 문제점이 있습니다. 클래스를 통해 객체를 만들고나면, 그 객체는 독립적으로 변화될 수 없다는 것입니다. 팩토리 패턴은 이런 **유연성을 잃어버리는 문제**를 해결합니다.

생성자 패턴에서 생성 클래스를 만들고 해당 클래스는 인터페이스를 제공합니다. 그리고 클라이언트는 그 인터페이스를 따라서, 구체적으로 그들이 원하는 것을 요구합니다. 그러면 생성 클래스는 요구받은 인스턴스의 타입에 따라 객체를 생성하는 방식으로 이루어집니다.

결론적으로 팩토리 패턴이 도달하고자 하는 지점은 **객체 생성을 단순화하고, 모듈화하고, 확장성을 높이는 것**에 있습니다.

### 적용상황 :

다음은 이 패턴을 적용하기 적합한 상황입니다.

- 생성 클래스를 만들어놓고, 구체적인 요구사항은 지연시키고 싶을 때.
- 클라이언트에서 무엇을 요구하는지 모를 때. 부모 클래스에서는 미리 인터페이스만 제공.
- 리소스를 최적화하기 원할 때. 생성 객체를 만들어놓고 재사용하는 방법으로 활용.

### 일상 예시 :

아직은 조금 추상적인 이야기일 수 있을 것 같습니다. 일상속에서 살펴볼 수 있는 예시를 소개해보겠습니다.

**1.커피 자판기 :**
커피 자판기가 있습니다. 이 커피 자판기를 이용하면 아메리카노를 먹든, 라떼를 먹든 저희는 그것이 어떻게 만들어지는지에 대해서는 신경쓰지 않아도 됩니다. 그저 커피 자판기가 제공하는 버튼(인터페이스)을 누르기만 하면 원하는 커피를 얻을 수 있습니다.

<p><img src="https://velog.velcdn.com/images/yesbb/post/8031e665-ec16-42cc-a092-678156fb1aba/image.jpg" height="70px" width="250px"></p>

**2.인력 회사 :**

당신이 고용주라고 해보겠습니다. 현재 단기 인력이 필요한 상황입니다. 이 인력을 구하려면 그들에게 제공할 비용, 기술에 대한 검증 등등 고려해야 할 사항들이 많습니다. 이럴 때, 인력 회사를 활용하면 아주 간편합니다.
회사에 연락해서, 어떤 종류의 인력이 필요한지만 말하면 그들은 적절한 인력을 보내줄 것입니다. 비용, 기술에 대한 검증과 같은 사항들은 고려하지 않아도 됩니다.

이 2가지 예를 통해서 factory 패턴을 알아봤습니다. 커피 자판기, 인력회사와 같은 객체를 생성해두고나면, 클라이언트 입장에서는 내부적으로 어떻게 돌아가는지는 신경쓰지 않고서도 원하는 것을 얻어낼 수 있습니다. 클라이언트가 해야할 일은 그저 원하는것이 무엇인지를 전달할 뿐입니다.

### 구성요소 :

### 코드 :

1.커피자판기

```javascript
class Americano {
  constructor() {
    this.shot = "one shot"
    this.water = "200ml"
  }
}

class Latte {
  constructor() {
    this.shot = "one shot"
    this.milk = "200ml"
  }
}

class CoffeeMachine {
  constructor(type) {
    if (type === "americano") {
      return new Americano()
    }
    if (type === "latte") {
      return new Latte()
    }
  }
}

const americano = new CoffeeMachine("americano")
const latte = new CoffeeMachine("latte")

console.log(americano) // Americano { shot: 'one shot', water: '200ml' }
console.log(latte) // Latte { shot: 'one shot', milk: '200ml' }
```

커피 자판기 코드입니다. CoffeeMachine이라는 생성 클래스에게 어떤 타입의 커피를 마실지 알려주면, 그 타입에 알맞는 커피를 반환해줍니다. 커피 자판기에서는 사용자가 별도로 샷의 갯수나, 물의 양을 조절할 수 없기 때문에 따로 옵션이 주어지지는 않았습니다. 다음으로는 옵션도 주어지는 코드를 확인해보겠습니다.

2.자동차 공장

```javascript
class Car {
  constructor(options) {
    this.doors = options.doors || 4
    this.state = options.state || "brand new"
    this.color = options.color || "silver"
  }
}

class Truck {
  constructor(options) {
    this.state = options.state || "used"
    this.wheelSize = options.wheelSize || "large"
    this.color = options.color || "blue"
  }
}

class VehicleFactory {
  constructor(options) {
    return this.createVehicle(options)
  }

  createVehicle(options) {
    if (options.vehicleType === "car") {
      return new Car(options)
    } else {
      return new Truck(options)
    }
  }
}

// Create an instance of our factory that makes cars
const car = new VehicleFactory({
  vehicleType: "car",
  color: "yellow",
  doors: 6,
})

const movingTruck = new VehicleFactory({
  vehicleType: "truck",
  state: "like new",
  color: "red",
  wheelSize: "small",
})

console.log(car) // Car { doors: 6, state: 'brand new', color: 'yellow' }
console.log(movingTruck) // Truck { state: 'like new', wheelSize: 'small', color: 'red' }
```

자동차 공장에게 어떤 종류의 자동차를 만들고 싶은지를 알리고 옵션으로 새 차를 원하는지 중고를 원하는지, 색상과 문의 갯수,바퀴의 크기 등등을 알려줍니다. 그러면 요구사항에 알맞는 차를 반환해줍니다.

### 장단점 :

**장점 : **

- 낮은 결합도 : 생성 객체와 구체적으로 만들어진 객체 사이의 결합도를 피할 수 있습니다.
- 재사용성 : 코드의 재사용성을 높일 수 있습니다.
- 단일책임원칙 : 생성과 관련된 코드를 하나의 장소에 모음으로써,기능을 쉽게 지원할 수 있습니다.
- 개방/폐쇄원칙 : 새로운 타입을 추가할 수 있으면서도, 이것을 사용하는 코드를 수정할 필요는 없습니다.
- 복잡한 객체 생성 로직을 클라이언트가 다 알 필요가 없습니다.

**단점 : **

- 구체적으로 생성된 모든 객체들은 그것을 만들어 줄 구체적인 생성자를 필요로 합니다. 어쨌든 상위 클래스에서도, 타입에 따라 생성해줄 생성자가 필요하다는 말입니다. 그렇다면 인스턴스의 타입을 확장해야 하는 경우에, 단순히 인터페이스만 추가하는 것이 아니라, 그 인터페이스에 알맞는 생성자를 추가로 만들어줘야 합니다. 분명 이 패턴이 확장가능성이 높은 것은 사실이지만, 그에 따른 노고는 무시할 수 없습니다. 때문에 인스턴스의 타입을 확장할 계획이 있다면, 미리 설계를 잘해두는 것이 필요합니다.
- 생성될 객체의 타입이 많을수록 생성 객체 내부는 복잡해질 것입니다.

**단점에 대한 해결책 : **
생성될 객체의 타입이 많아질 수록 생성 객체 내부는 복잡해질 것이라는 문제점이 있었습니다. 그렇다면 이런 경우에는 어떻게 문제를 해결할 수 있을까요?
제가 생각해본 방법은 결국에 그 생성 타입들을 또 다시 한번 **추상화**시키는 것이 필요할 것이라는 생각이 들었습니다. 예를 들어 생각해보겠습니다.

피자를 만드는 공장이 있었습니다. 문제는 이 하나의 공장에서 만드는 피자의 종류가 매우 많아져버려서, 관리가 복잡해진 것입니다. 관리자는 고민을 하다가, 결국 공장을 두 개로 나눠서 관리하기로 했습니다.
공장을 어떻게 나눌까 피자의 종류를 살펴봤더니, 고구마와 관련된 피자의 종류가 다양했던 것입니다. 그래서 고구마가 들어가는 피자공장과, 고구마가 들어가지 않는 피자공장으로 나누어 만들게 되었습니다.

예시에서 소개한 것처럼, 코드에서도 인스턴스의 타입이 많아지면, 그 타입을 추상화할 수 있는 수준까지 추상화한 다음 factory 클래스를 나누는 것이 해결책이 될 것 같습니다.

(🙏 혹시 factory 패턴의 문제점을 해결하는 방법으로 더 좋은 의견이 있으시다면 가르침을 주시면 좋을 것 같습니다.)

[RefactoringGuru](https://refactoring.guru/design-patterns/factory-method)

## 3.Builder Pattern

### 목적 및 동기 :

- 생성자 패턴의 목적은 복잡한 객체의 생성과 결과물을 엄격히 구분함으로써, 같은 생성 과정이 다른 결과물을 만들 수 있도록 하는 것이다.

- 이것은 복잡한 객체를 순서대로 만들어내기 위해 사용되며, 최종 단계에서 객체를 반환한다.

- 객체를 만드는 과정은 반드시 일반적이어야 한다. 그렇게 함으로써 같은 객체의 다양한 버전을 만들 수 있어야 한다.

### 사용상황 :

- 생성 객체가 가지는 파라미터의 갯수가 너무 길어서, 복잡하고 비효율적일 때 사용한다. 추가적으로 필요한 값만 설정하는 것도 가능하다.
- 같은 종료의 객체이면서도 다른 속성을 가진 객체를 생성하고 싶을 때 사용한다.
- 복잡한 객체를 순서대로 생성하려하고, 그 순서의 지연시키고 싶을 때 사용한다.

### 구성요소 :

- Product : Product 클래스는 builder pattern에 의해 만들어 질 복잡한 객체의 타입을 지정한다.

- Builder : 이 추상적인 기본 클래스는 올바르게 객체를 생성하기 위한 모든 스텝들을 정의한다. builder의 실제 기능이 만들어진 subclass에서 수행되기 때문에 각각의 스탭은 일반적으로 추상화되어있다. GetProduct라는 메서드를 통해서 최종적인 결과물을 받는다. Builder 클래스는 간단한 인터페이스와 자주 교체된다.

- ConcreteBuilder : Builder에서 상속되는 builder class는 얼마든지 있을 수 있다. 이런 클래스들은 특정 복잡한 객체를 만들기 위한 기능을 포함하고 있다.

- Director : Director 클래스는 최종 결과물을 만들어내기 위한 알고리즘을 컨트롤한다. director object는 초기화되고 이것의 Construct method는 호출된다. Construct method는 최종 결과물을 만들어내기 위한 세부적인 builder object들을 잠시 보관한다. 그리고 director는 결과물을 만들어내기 위한 올바른 순서로 concrete builder의 메서드를 호출한다. 과정의 마지막 단계에서, 결과물을 반환하는 builder 객체의 GetProduct 메서드를 호출한다.

### 장단점 :

장점 :

- 한번에 가지는 파라미터의 갯수를 줄일 수 있다.
- 생성 메서드의 가독성을 상당히 높일 수 있다.
- constructor의 파라미터 갯수를 줄여줄 수 있고, 필요한 값만 넣어줄 수 있기 때문에 파라미터에서 옵셔널하게 지정해주지 않아도 된다.
- 항상 완성된 상태로 만들어질 수 있다.
- 복잡한 로직 없이도, 불변한 객체를 만들 수 있다.

단점 :

- 코드의 줄 수가 2배 정도 증가하긴 하지만, 설계의 유연성과 가독성을 생각하면 감안할 수 있는 단점이다.
- 다른 타입의 경우 ConcreteBuilder를 더 만들어줘야하는 경우도 생긴다.

[Builder Design Pattern](https://www.geeksforgeeks.org/builder-design-pattern/)
[Builder Pattern](https://refactoring.guru/design-patterns/builder)

# Structural Pattern 구조 패턴

## 4.Adapter Pattern

## 5.Proxy Pattern

# Behavioral Pattern 행동 패턴

## 6.Mediator Pattern

### 정의 :

첫번째로 소개할 패턴은 중재자 패턴(mediator pattern)입니다.
중재자라는 말의 사전적 정의는 무엇일까요?

> 분쟁에 끼어들어 쌍방을 화해시키는 사람.

저희가 개발을 할 때에도 '분쟁'이라는 개념이 등장할지는 모르겠지만, 어쨌든 개별대상 사이에서 의사소통을 도와주는 역할을 한다고 이해할 수 있습니다.
이런 중재자라는 이름으로부터 우리는 특정 객체 혹은 클래스가 가운데서 다른 객체 및 클래스의 소통을 도와준다는 것을 유추해볼 수 있을 것 같습니다.

- 중재자 패턴은 행동 디자인 패턴에 속한다. 이 패턴은 객체들 사이의 혼잡한 의존성을 줄여준다. 객체들 사이의 직접적인 소통을 제한하고, 오직 중재자 객체를 통해서만 소통하도록 강제하는 방식으로 이루어진다.
  (Mediator is a behavioral design pattern that lets you reduce chaotic dependencies between objects. The pattern restricts direct communications between the objects and forces them to collaborate only via a mediator object.)

- 중재자 패턴의 핵심은 "개개의 객체들이 어떻게 소통할 지 정의한 중재자 객체를 정의하는 것"입니다. 이런 객체를 활용하면, 서로간에 간접적으로 소통할 수 있으면서도 객체들 사이의 결합도를 줄일 수 있습니다. 클라이언트 객체는 다른 클라이언트 객체에게 메시지를 전달하기 위해서, 중재자 객체에게 메시지를 보내고, 다른 클라이언트 객체는 중재자 객체로부터 그 메시지를 전달받는 방식으로 이루어집니다.

### 목적 및 동기 :

**어떤 문제를 해결하려하나? : **

하나의 문제 상황을 가정해보겠습니다. 여러분은 지금 프로필 다이얼로그와 로그인 다이얼로그를 가지고 있습니다. 이 각각의 다이얼로그 안에는 다양한 종류의 form 컴포넌트를 가지고 있을 것입니다. 그리고 그 각각의 form 컴포넌트들은 다른 form 컴포넌트와 상호작용을 주고 받아야 하는 경우도 있습니다.
예를 들어서, "나는 강아지를 키웁니다"라는 체크박스에 표시를 했을 때, 강아지 이름을 입력하는 textfield가 숨겨져 있다가 나오도록 만드는 경우를 생각해볼 수 있습니다. 또 다른 예시가 있다면, 제출 버튼을 눌렀을 때, 모든 textfield의 내용에 대해서 유효성 검증을 하는 경우도 생각해볼 수 있습니다.

이런 내용을 구현할 때, 직접적으로 그 각각의 form 컴포넌트 안에 비지니스 로직을 집어 넣으면 그 컴포넌트는 재사용하기가 어려워 질 것입니다. 예를 들어서, 체크박스 컴포넌트를 로그인 컴포넌트에서 사용하려하는데, dog과 관련된 내용에 심하게 결합되어 있기 때문에, 재사용하기가 어려워집니다. 이런 문제점을 해결하고자 중재자 패턴이 나오게 되었습니다.

**중재자 패턴은 문제를 어떻게 해결하나? : **

중재자 패턴은 개개의 컴포넌트들이 직접적으로 소통하지 않도록 제안합니다. 대신에 중재자 객체를 활용해 간적접으로 소통하도록 만들어줍니다. 결과적으로 컴포넌트들은 서로에 대해서 의존성을 가지지 않고, 오직 하나의 객체, 중재자 객체에게만 의존성을 가지게 됩니다.

더 구체적으로 위에서 예시로 들었던 form 컴포넌트에 대해서 이야기해보겠습니다. submit 버튼을 클릭해다고 해보겠습니다. 그러면 이것은 모든 form의 값들을 검증해야합니다. 그러나, 중재자 패턴을 이용할 경우, 해야 할 일은 중재자 객체에게 알림을 보내는 것입니다. 그러면, 중재자 객체에서 한꺼번에 각각의 form에 대한 유효성을 검증해줄 것입니다. 그러므로 이제 각각의 컴포넌트들은 서로에 대한 의존성을 가지지 않고, 하나의 중재자 객체에게만 의존성을 가지고 있는 상황이 될 것입니다.

이런 방법으로 중재자 패턴은 개별적인 객체들 사이에서 벌어질 수 있는 복잡함을 해결합니다. 컴포넌트들이 더 적은 의존성을 가진다면, 수정하고, 확장하고, 재사용하는 것이 훨씬 더 쉬워지게 될 것입니다.

이런 중재자의 역할을 일상속에서 한번 찾아보겠습니다.

개발을 하다보면 수 없이 많은 클래스와 객체가 만들어지게 될 것이다. 이것이 많아질 수록 더 복잡해지고, 사용하기 어려워 질 것이다. 더구나 이런 것들끼리 소통하다보면 복잡한 문제가 생길 수 있다. 이런 복잡함을 낮춰주기 위한 것이 중재자 패턴이다.
이 중재자 객체는 객체들끼리 소통하는 방식을 정의내리고, 그렇게 함으로써 각 객체들 사이의 의존성을 낮춰줄 수 있다.

### 적용상황 :

- 객체들이 서로에게 너무 의존하고 있는 상황이기 때문에, 수정하는 것이 어려운 상황에 적용시키기에 적합합니다. 각 객체들 사이의 관계성을 뽑아내 추상화 시키고 단 하나의 중재자 객체를 의존하도록 만들 수 있습니다.
- 특정 컴포넌트를 다른 상황에서도 재사용하고 싶은데, 특정 다른 객체에 너무 깊이 결합되어 있는 경우 적용하기에 적합합니다. 중재자 패턴을 적용하고나면, 각각의 컴포넌트들은 서로에 대해서 알 수 없기 될 것입니다. 그들은 중재자 객체를 통해서 간접적으로 소통합니다. 현재 사용중인 컴포넌트를 다른 곳에서도 사용하고 싶다면, 다른 중재자 객체를 활용합니다.
-

### 일상예시 : 이 개념을 이해할 실제 사례가 있는가?

**🛫 관제소 **

공항으로 가보겠습니다. 비행기를 운행하는 파일럿은 이륙 혹은 착륙하고자 할 때, 그들끼리 직접 소통하지 않습니다. 만약 그들끼리 소통한다면 굉장히 복잡한 일이 생겨버릴 것입니다.

![](https://velog.velcdn.com/images/yesbb/post/c899ddc6-38a4-4e68-b193-a7cac448ffe4/image.png)
이런 일을 방지하고 효율적으로 소통하는 방식은 관제소에게 상황을 전파하는 것입니다. 그러면 관제소는 상황을 정리하고 또 다른 파일럿들에게 알려줄 것입니다. 관제소 덕분에 비로소 모든 비행기들은 정돈된 상황 속에서 이륙과 착륙을 진행할 수 있게 됩니다.
![](https://velog.velcdn.com/images/yesbb/post/91fefd4a-db1e-4a04-a52d-e21c44977838/image.png)

**📑 교실**

이번에는 교실로 가보겠습니다. 학생들이 앉아있고, 오늘은 가정통신문이 나가는 날입니다. 이때 선생님께서는 가정 통신문을 나눠주는 방법에는 2가지가 있습니다. 1.선생님이 직접 가정통신문을 다 나눠준다. 2.가정통신문 뭉치를 학생들에게 던져주고 알아서 가져가게 한다.

![](https://velog.velcdn.com/images/yesbb/post/2bb314d3-56e4-4352-a947-8be14a81fc97/image.jpg)

첫번째 방법부터 살펴보겠습니다. 선생님께서 직접 가정 통신문을 나눠주는 경우에는 이것을 나눠주는 행위에 대한 중재자는 '선생님'이 됩니다. 교실 마지막까지 다다라서 학생들에게 통신문을 나눠주고 나서 뒤돌아보는데, 한 학생이 손을 들고 말합니다. "선생님, 저 종이 못받았는데요🤨"
자 이제부터 '디버깅'에 들어가야합니다. 종이를 나눠주도록 '중재자' 역할을 한 사람은 선생님이었기 때문에, 종이를 받지 못한 학생이 발생한 것은 전적으로 선생님의 '책임'입니다. 우리는 이 사실을 즉각적으로 알 수 있으며, 더 나아가 남은 종이가 어디에 있는지도 책임자인 '선생님'이 알 수 있습니다. '디버깅'이 꽤 효율적으로 이루어지는 모습을 볼 수 있죠?

두번째 방법을 보겠습니다. "애들아, 여기 통신문 나뒀으니까 가져가~" 왈자지껄 아이들이 한바탕 왔다가더니, 뒤늦게 한 아이가 손을 들고 말합니다. "선생님, 저 종이 못받았는데요🥲"
자 이제부터 '디버깅'을 해보겠습니다. 그런데 곧바로 발견되는 문제가 있습니다. 첫번째로, 나머지 종이 더미가 어디갔는지를 모른다는 것입니다. 두번째로, 누가 이 과정을 망쳤는지, 책임자가 누구인지를 알 수 없습니다. 이 상황을 타개할 방법은 아이들 한 명, 한 명에게 가서, 물어보는 방법 밖에는 없습니다.

이런 일상 예시를 통해 중재자 패턴을 사용하는 것이 효율적이고, 유용한 순간을 이해할 수 있었습니다.

### 용례 : 중재자 패턴을 사용중인 예시에는 무엇이 있는가?

채팅방이 가장 유명한 예시가 되겠습니다.
방에 참여하는 참가자가 각각의 객체가 될 것입니다. 이들은 서로 직접 소통하지 않습니다.
채팅방이라는 중재자에게 메시지를 보내면, 채팅방이라는 중재자는 그 방에 들어와 있는 다른 모든 참가자(객체)들에게 메시지를 전달해줍니다.

이런 순서가 될 것입니다.

참가자1 -> 메시지 -> 중재자(채팅방) -> 메시지 -> 참가자2

코드로 살펴보겠습니다.

```javascript
class Participant {
  constructor(name) {
    this.name = name
    this.chatroom = null
  }

  send(message, to) {
    this.chatroom.send(message, this, to)
  }

  receive(message, from) {
    log.add(from.name + "to" + this.name + ": " + message)
  }
}

let Chatroom = function () {
  let participants = {}

  return {
    register: function (participant) {
      participants[participant.name] = participant
      participant.chatroom = this
    },

    send: function (message, from, to) {
      if (to) {
        to.receive(message, from)
      } else {
        for (let key in participants) {
          if (participants[key] !== from) {
            participants[key].receive(message, from)
          }
        }
      }
    },
  }
}

log = (function () {
  let log = " "
  return {
    add: msg => {
      log += msg + "\n"
    },
    show: () => {
      alert(log)
      log = " "
    },
  }
})()

function run() {
  let yoko = new Participant("Yoko"),
    john = new Participant("John"),
    chatroom = new Chatroom()

  chatroom.register(yoko)
  chatroom.register(john)

  yoko.send("All you need is love.")
  yoko.send("I love you john")
  john.send("Hey, no need to broadcast", yoko)

  log.show()
}

run()
```

### 장단점 : 중재자 패턴의 장단점은 무엇인가?

**장점 : **

- 단일책임원칙(Single Responsibility Priciple)을 지킬 수 있습니다. 객체 사이의 소통을 추상화해 하나의 장소에서 관리하고 있음으로, 이해하거나 관리하기 쉽습니다.
- 개방폐쇄원칙(Open/Closed Principle)을 지킬 수 있습니다. 실제 컴포넌트들에는 변화를 일으키지 않고도 새로운 중재자 객체를 소개할 수 있습니다.
- 객체 사이의 결합도를 낮출 수 있습니다. 객체 사이의 결합도가 높으면, 하나의 객체에 문제가 생겼을 때 도미노처럼 문제가 발생할 수 있습니다.
- 개개의 컴포넌트들을 재사용할 수 있습니다.

**단점 : **

- 잘못하면, ['God Object'](https://en.wikipedia.org/wiki/God_object)로 발전할 가능성이 있습니다. Gob Object란 객체지향 언어에서 하나의 안티패턴으로 분류되는데, 수 없이 다양한 타입의 객체들이 하나의 객체를 참조하고 있는 상황 때문에 발생하는 상황을 문제삼는 패턴입니다.
- 항상 비간접적으로 소통하는 방식 때문에 성능상의 문제가 발생할 수 있다.
-

[Mediator Pattern - JSManifest](https://jsmanifest.com/the-mediator-pattern-in-javascript/)
[Mediator Pattern - Patterns]()
[Mediator Pattern - OODesign](https://www.oodesign.com/mediator-pattern)
[Mediator Pattern - GofPattern](https://www.gofpatterns.com/design-patterns/module6/mediator-pattern-applicability.php)
[Mediator Pattern - Refactoring guru](https://refactoring.guru/design-patterns/mediator)
[Mediator Pattern - jargon](http://jargon.js.org/_glossary/MEDIATOR_PATTERN.md)

## 7.Observal Pattern

### 정의 :

먼저 위키피디아의 정의를 읽어보겠습니다.

> 옵저버 패턴은 객체의 상태 변화를 관찰하는 관찰자들, 즉 옵저버들의 목록을 객체에 등록하여 상태 변화가 있을 때마다 메서드 등을 통해 객체가 직접 목록의 각 옵저버에게 통지하도록 하는 디자인 패턴이다. 주로 분산 이벤트 핸들링 시스템을 구현하는 데 사용된다(위키피디아)

사실 위키피디아의 정의는 그렇게 와닿지는 않죠? 위키피디아의 정의를 뒤로하고 다시 한 번 설명해보겠습니다. 옵저버 패턴은 구독 모델을 따릅니다. 이 구독모델이란 subscriber와 publisher가 존재하는 모델입니다. publisher에게 변경이 생기면, subscriber에게 알림을 보내주고, subscriber는 그에 맞게 특정 액션을 취하는 모델입니다. 이런 모델을 따르는 것을 옵저버 패턴이라고 할 수 있습니다. 아마 이 정도만으로도 감이 잡히셨겠지만, 이후의 설명들을 읽으시면 더 확실히 이해가 되실 겁니다.

### 목적 및 동기 :

옵저버 패턴은 어떤 문제를 해결하기 위해서 나온 패턴일까요? 2가지 문제 상황을 생각해보겠습니다.

1. 특정 요소의 상태나 행동을 관찰하고 싶습니다. 그럴 때 우리는 그 요소를 계속해서 관찰해줘야합니다. 그것을 관찰하기 위해서 계속해서 방문해서 살펴봐야하는 어려움이 따릅니다. 실례로, 새로운 아이폰 모델이 곧 도착한다는 소식을 듣고 매일 매장에 방문하는 고객을 생각해볼 수 있을 것 같습니다. 기대를 가득 안고 매장에 방문했으나, 기대한 소식을 얻지 못하고 빈 손으로 집에 돌아오는 고객을 생각해보십시요. 얼마나 비효율적이며, 낭비적입니까?

2. 특정 요소의 상태나 행동을 확인하기 위해서, 직접 방문하는 것은 피곤합니다. 그래서 알림을 보내는 방향으로 전환했다고 해보겠습니다. 그런데, 그런 알림을 받기 원하지 않는 사람들에게도 알림이 가는 것입니다. 새로운 아이폰 모델에는 관심이 없는 사람들에게도, 아이폰 모델이 도착했다는 알림가게 되면 이것 또한 낭비이고 피곤한 상황이 됩니다. 여러분 메일함에 관심이 없는 스팸들 있으시죠? 짜증나지 않습니까?

옵저버 패턴은 이런 문제점을 해결하고자 만들어진 디자인 패턴입니다. 결론적으로 옵저버패턴을 사용하면 :

1.특정 대상의 업데이트를 관찰하기 위해서 지속적인 확인을 해 줄 필요가 없습니다. 2.하나의 대상을 여러 관찰자가 관찰할 수 있습니다. 3.알람을 받고 싶은 대상만 알람을 받을 수 있습니다.

### 적용상황 :

그렇다면 언제 이 패턴을 사용하면 좋을까요?

- 특정 객체의 변화를 다수의 객체가 관찰해야하는 경우 사용하기 적합합니다.
- 알람이나, 메일, 메시지를 보내야하는 상황에 적합합니다. 특정 웹사이트를 구독해두면, 그 사이트에서 어떤 이벤트가 일어났을 때 알람을 보낼 수 있습니다.
- 관찰하고자 하는 객체가 언제 변화될지도 모르고, 그 변화가 다른 객체에 영향을 미쳐야하는 경우 사용하기 적합합니다.
- 구독자 목록을 동적으로 관리하고 싶을 때, 사용하기 적합합니다. 이 패턴에서 구독자는 원할 때 구독과 해지를 사용할 수 있습니다.
- 모듈 간 의존성을 낮추고 싶을 때 사용하기 적합합니다. 만약 a,b 모듈이 서로의 데이터를 필요로 하는 상황이 있다고 가정할 때, 이 때 두 모듈을 합치는 방식은 의존성을 높이게 되고 유지 보수적인 측면에서 좋지 못합니다. 이런 상황에 옵저버 패턴을 사용하면 의존성을 낮추는 동시에, 데이터를 전달할 수 있습니다. 두 모듈을 관찰하는 관찰자를 두고, 데이터가 변경하는 것을 관찰하는 관찰자를 둔 다음, 데이터가 변경되었을 때, 특정 액션을 수행하도록 하는 방법입니다.

### 일상예시 :

1.잡지 구독 :
저희가 잡지사에 특정 잡지를 구독하면, 잡지사는 잡지가 발행될 때마다 저희에게 잡지를 보내줍니다. 잡지사 입장에서는, 특정 잡지의 잡지가 발행되면 구독자 리스트를 확인하고, 리스트에 해당하는 사람들에게 잡지를 보내줍니다. 구독자는 잡지가 발행되었는지 안되었는지 계속 확인할 필요가 없습니다. 잡지가 발행하면 알아서 도착할 것이기 때문이 신경 쓸 필요가 없습니다.

2.뉴스 레터 :
특정 뉴스를 구독해두면, 그 웹사이트를 확인해보지 않아도 알아서 메일을 보내줍니다. 웹사이트 입장에서는 새로운 게시물이 발행되면, 구독자 리스트를 확인하고 그들에게 메일을 보내줍니다.

옵저버 패턴의 경우에는 개발을 하면서도 관찰할 수 있는 사례가 많았습니다. 그런 <u>개발 속 사례</u>들도 소개해보겠습니다.

1.addEventListener : 이 메서드도 옵저버 패턴의 한 예시라고 볼 수 있습니다. 특정 DOM 요소에 이벤트를 등록해두고, 그것에 이벤트 일어났을 때(어떤 변화가 생겼을 때), 특정 함수를 실행하는 방식으로 이루어집니다.

2.[react](https://studysection.com/blog/observer-pattern-in-react-reactjs/) : 리액트의 state또한 옵저버 패턴의 한 예시라고 할 수 있습니다. react는 특정 컴포넌트에서 state가 변경된 것을 감지하고, 그에 따라 컴포넌트를 렌더링해줍니다. 관찰 대상은 state, 관찰자는 react라고 할 수 있겠습니다.

3.intersection observer : 무한스크롤을 구현하려 할 때, 자주사용하는 기능입니다. observer를 화면 어딘가에 구현해놓고, 그 대상이 화면에 나타나는 것이 감지되면 특정 액션을 수행합니다. 무한스크롤의 경우 추가적인 데이터를 불러오는것이 될 것 같습니다.

### 구성요소 :

옵저버 패턴을 이루고 있는 구성요소를 알아보겠습니다.

- observer : 관찰자입니다.
- observable object : 관찰자들을 모아 둔 객체입니다. subject의 상태가 변경되면 그 subject를 구독하고 있는 observer 들에게 알려줍니다. observable object의 구성요소는 다음과 같습니다.
  - observers : 관찰자들이 모여 있는 배열입니다.
  - subscribe : observers 배열에 관찰자를 넣어 주기 위한 메서드
  - notify : 특정 이벤트가 일어났을 때, 옵저버에게 알려주는 메서드입니다.
- subject : 관찰자가 관찰하는 대상입니다.

아래 두개는 아직 다 읽어보지 못한 것들.

- https://betterprogramming.pub/observer-design-pattern-in-javascript-c839ee49add4
- https://www.dottedsquirrel.com/observer-pattern-javascript/

### 코드 :

옵저버 패턴에서도 마찬가지로, 다양한 코드를 소개함으로써 이해도를 높이려고 합니다.

**1.옵저버 객채 : **
옵저버 패턴을 사용하면, 우리는 옵저버라는 객체로 또 다른 객체(observable)에 구독을 걸 수 있습니다. 그리고 뭔가 이벤트가 일어나면 observable은 그것의 모든 옵저버에게 notify 합니다. 옵저버는 3가지 중요한 요소를 가지고 있습니다.

- observers : 옵저버의 배열입니다. 이것들은 특정 이벤트가 일어나면 알림을 받게 될 것입니다.
- subscribe() : observers list에 observers를 더하기 위한 것입니다.
- notify() : 특정 이벤트가 일어났을 때, 옵저버에게 알림을 주는 역할을 합니다.

```javascript
class Observable {
  constructor() {
    this.observers = []
  }

  subscribe(func) {
    this.observers.push(func)
  }

  unsubscribe(func) {
    this.observers = this.observers.filter(observer => observer !== func)
  }

  notify(data) {
    this.observers.forEach(observer => observer(data))
  }
}
```

가장 근본적인 형태의 옵저버 패턴 코드라고 할 수 있을 것 같습니다. 이런 종류의 패턴으로 다양한 기능에서 사용되는 것을 아래의 예시에서 확인해보실 수 있을 것입니다.

2.어머니 예시 코드 :

3.마우스 관찰 예시 :
![](https://velog.velcdn.com/images/yesbb/post/51465658-6689-4a89-a57b-28a9e827263e/image.mov)

해당 패턴을 사용하고 있는 예시를 찾아보다가, 아주 적절한 예를 찾았습니다. 이 코드는 [Observer Design Pattern in JavaScript
](https://betterprogramming.pub/observer-design-pattern-in-javascript-c839ee49add4) 라는 아티클에서 가져온 코드입니다.

위에 보여드린 gif예시를 살펴보시면 2가지를 분석할 수 있습니다.

- 마우스의 위치값이 즉시 텍스트박스에 업데이트됩니다.
- 마우스가 움직인 뒤 원이 그 경로를 따라서 움직입니다.

이것이 정말 적절한 예시라고 생각했던 이유는, 다양한 컴포넌트들이 단 하나의 대상(마우스의 움직임)을 관찰하고 그에 따라서 컴포넌트들이 특정 action을 취해주고 있기 때문입니다.

먼저 이 동작을 구현하기 위해서 MousePositionObservable 클래스를 만들어보겠습니다. 이 클래스가 하는 일은 다음과 같습니다.

- 관찰자 콜백들의 리스트를 보관하고 있습니다.
- 마우스가 움직이는 이벤트를 듣고, 모든 구독자들의 콜백 함수를 트리커합니다.
- 구독 메서드를

```javascript
class MousePositionObservable {
  constructor() {
    this.subscriptions = []
    window.addEventListener("mousemove", this.handleMouseMove)
  }
  handleMouseMove = e => {
    this.subscriptions.forEach(sub => sub(e.clientX, e.clientY))
  }
  subscribe(callback) {
    this.subscriptions.push(callback)

    return () => {
      this.subscriptions = this.subscriptions.filter(cb => cb !== callback)
    }
  }
}
```

그리고 아래는 html, css코드입니다.

```html
<div class="container">
  <div class="circle"></div>
  <div class="mouse-position">
    <h4>Mouse Position</h4>
    <div class="position"></div>
  </div>
</div>
```

```css
.container {
  position: relative;
  width: 100vw;
  height: 100vh;
  background-color: rgb(240, 244, 247);
  background: linear-gradient(-70deg, #202020, #000000);
}
.circle {
  position: absolute;
  background-color: #238643;
  width: 25px;
  height: 25px;
  border-radius: 50%;
  z-index: 2;
}

.mouse-position {
  position: fixed;
  top: 20px;
  right: 20px;
  width: 200px;
  height: 100px;
  border-radius: 4px;
  padding: 4px 16px;
  color: white;
  background: rgba(255, 255, 255, 0.1);
  border: 2px solid rgba(255, 255, 255, 0.1);
  box-shadow: 0 0 80px rgba(0, 0, 0, 0.25);
  overflow: hidden;
}

.mouse-position h4 {
  color: white;
  margin: 10px 0;
}
```

이제 이

```javascript
const mousePositionObservable = new MousePositionObservable()

mousePositionObservable.subscribe((x, y) => {
  const circle = document.querySelector(".circle")
  window.setTimeout(() => {
    circle.style.transform = `translate(${x}px, ${y}px)`
  }, 1000)
})

// Update the mouse positon container to show the mouse position values
mousePositionObservable.subscribe((x, y) => {
  const board = document.querySelector(".mouse-position .position")
  board.innerHTML = `
    <div>
       <div>ClientX: ${x}</div>
       <div>ClientY: ${y}</div>
    </div>
  `
})
```

이제 여기서 두 가지지 구독자 콜백을 instance에 넣어줬다. 이 구독자들은 마우스의 이벤트를 감지하기 원하는 녀석들이다.

circle 요소에 대한 구독자 콜백은 dom element에 대한 값을 받아와서, circle의 위치를 변경시킨다.
(The subscription callback for the circleelement gets the reference of the DOM element and updates its tranformproperty. The transform property will use hardware acceleration where possible, so using translate() over position top and left will see performance benefits if any animations or transitions are also being used on the element.) => translate도 같이 넣어준 이유를 설명하고 있다.

3.

### 장단점 :

장점 :

- 하나의 이벤트를 관찰함으로 다양한 액션을 수행하고 싶을 때, 매우 유용하다.
- 연관된 객체들 사이에서 일관성을 유지하면서, 기능들의 결합도를 낮출 수 있다.
- 모듈간의 의존성을 낮출 수 있다.
- polling 방식을 방지할 수 있다. polling 이란 상태를 주기적으로 확인하고 만약 조건을 만족할 경우 자료를 처리하는 방식을 말한다. 이것의 단점은 짧은 주기로 관찰하면 부하가 발생한다는 것이고, 긴 주기로 관찰하면 실시간성이 떨어진다는 점이다. 하지만, 옵저버 패턴을 사용하게 되면, 관찰 대상의 상태가 변경되었을 때를 감지할 수 있으므로 polling을 사용하지 않아도 된다.

- Why is this a good thing?
  Imagine you want to update a collection of things when something updates from a particular source. However, you don’t want to call your object, function or method every single time something happens.
  Imagine you have about fifty of these objects/functions/methods.
  The observer pattern lets you consolidate and call whatever you want from a single source.

단점 :

- 코드의 결합도를 낮추기 때문에, 이것은 종종 어플리케이션의 다른 부분이 제때 동작하는지 보장할 수가 없다. 예를 들어서, 특정 대상에게 구독을 하고 있는 구독자는 부적저하게 수행하는 코드를 가지고 있을지라도, 그 대상은 그런 사실을 알 수 있는 방법이 없다.
  (Since the Observer design pattern leads to loosely coupled code, it is sometimes hard to guarantee that other parts of the application are working as they should. For example, the subscriptions added to the subject may have code that is behaving incorrectly, but there is no way for the publisher to know that.) => 아직 정확하게 해석하지 못한 문장

- 옵저버가 많고 복잡해지면, 성능상의 문제를 일으킬 수 있습니다.
- 옵저버에 등록되어있는 subject가 많아질 수록, 알람이 noise해질 수 있습니다.

  - 알림이 noise해지는 것이 왜 문제가 될 수 있을까?
    - 알림의 순서를 관리할 수 없다는 문장도 있었다. 알림의 순서를 관리할 수 없다는 것이 왜 문제가 된다는 것일까?
    -

- 이 패턴은 구현할 때, 주의하지 않으면 매우 거대하고 복잡한 코드를 만들어낼 가능성이 높다.
- 옵저버 디자인 패턴의 가장 큰 단점은 구독자들이 랜덤한 순서로 알림을 받게 될 것이라는 것이다.
- 옵저버의 명시적인 구독과 구독해제 때문에 메모리 누수의 문제점도 있다.

https://www.dottedsquirrel.com/observer-pattern-javascript/

[자바포인트 : observer pattern](https://www.javatpoint.com/observer-design-pattern-in-python)

[오렐리 : observer pattern](https://www.oreilly.com/library/view/learning-javascript-design/9781449334840/ch09s05.html)

[HowToDoInJava : observer pattern](https://howtodoinjava.com/design-patterns/behavioral/observer-design-pattern/)

[Advantages and disadvantages of the observer pattern](https://blog.actorsfit.com/a?ID=01250-2ff7354e-cc77-4caa-9ef8-22ddf8c9d404)

[Observer Pattern Pros & Cons](https://neillmorgan.wordpress.com/2010/02/07/observer-pattern-pros-cons/)

[Understanding the Observer Design Pattern](https://betterprogramming.pub/understanding-the-observer-design-pattern-f621b1d0b6c9)

[Observer](https://refactoring.guru/design-patterns/observer)

## 옵저버 패턴과 중재자 패턴의 차이 :

옵저버는 하나의 publisher가 그것을 구독하고 있는 subscriber들에게 알림을 보낸다.

중재자는 중재자 객체를 참조하고 있는 다른 인스턴스과 소통하고 싶을 때 사용한다.

<br>

나중에 읽어보고 싶은 자료 :
https://www.cs.unc.edu/~stotts/GOF/hires/disc5fso.htm
