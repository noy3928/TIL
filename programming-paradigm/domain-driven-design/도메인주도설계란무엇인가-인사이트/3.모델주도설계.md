# 3. 모델 주도 설계

- 우리는 비즈니스 도메인에 깊이 뿌리내린 좋은 모델을 만들어야한다. 이런 모델을 만들어내는 것이 목적이다.
- 초반에 만들어진 원본 모델과 실제 개발을 하면서 만들어져가는 제품사이의 간극은 얼마나 좁혀나갈 수 있을까?
- 우리가 고민해야 할 모델의 중요한 부분은 쉽고 정확하게 코드로 변환할 수 있도록하는 것이다.
  - 때문에 중요한 질문은 '모델을 코드로 어떻게 변환할 것인가?'하는 것이다.
- 분석모델은 개발자가 존재하지 않은채로 만들어진 모델이기에 코드로 변환되기에 어렵다. 때문에 이것은 개발에 착수하면서 바로 폐기되는 모델이다.
  - 분석 모델은 분석과 코드 설계를 분리하는 설계 기법이다.
- 분석모델은 분석가들이 모델에 내재된 결함이나 도메인 자체의 복잡성을 예측할 수 없다는데에 문제가 있다.
- 분석 모델을 기반으로하면, 개발자들은 스스로의 판단에 의지에 설계를 고민해야하는 시점에 도달하게 된다. 이렇게 되면 원래의 모델과 다른 그림을 그리게 된다는 문제점이 있다.
- 분석가들이 만들어낸 모델을 문서나 모델로 표현을 하더라도 충분히 전달되지 못하는 맥락은 분명히 존재한다.
- 하지만 개발자들이 분석가들의 회의에 참여한다면 코드를 설계하기 전에 도메인과 모델을 명확하고도 정확하게 이해한다면 훨씬 더 생산적일 것이다.
- 도메인 모델링과 설계를 밀접하게 관련시키는 것이 훨씬 더 나은 접근 방식인 이유는, 소프트웨어로 정확하게 표현될 수 있는 모델을 선택할 수 있기 때문이다.
- 코드를 작성하는 사람들은 모델을 잘 알아야만 코드로 설계할 수 있다. 때문에 모델에 대한 피드백을 끊임없이 주고받을 수 있게 된다.
- 기술자들은 모델을 설계하는 시간에 적극적으로 동참해야한다.
- 도메인 모델이 글자 그대로 소프트웨어에 반영될 수 있도록 설계해야한다. 이렇게 함으로써 유비쿼터스 언어를 지원해야한다.
- 객체지향 프로그래밍은 모델을 코드로 구현해내기에 적합한 패러다임이다.
- 절차적 언어는 모델을 코드로 구현하는데에 어려움을 겪을 수 있다.

모델 주도 설계를 위한 블록

- 계층형 아키텍처
  - 응용 시스템의 상당 부분은 도메인과 직접적인 관련이 없다.
  - 도메인과 관련이 없는 ui, db 등 여타 지원 성격의 코드들은 비지니스 객체 내부에 포함되기도 한다.
  - 하지만, 이렇게 코드가 뒤섞여있으면 읽고 이해하기도 어렵고, 변경의 여파도 크며, 테스트도 어려워진다.
  - 때문에 레이어를 분리해야한다. 각각의 레이어를 분리하여 설계해서 높은 응집도를 가지게 만들며 하위 레이어에만 의존하도록 만들어야 한다. 이렇게 할 때, 도메인 모델은 자신에게만 집중하기 때문에 훨씬 더 풍성해질 수 있다.  이러한 레이어의 종류는 다음과 같다.
    - ui 레이어
    - 어플리케이션 레이어 : 어플리케이션 활동을 조율하는 레이어. 업무 로직을 포함하지 않는다. 비즈니스 객체의 상태를 보관하지 않지만, 어플리케이션 작업의 처리 상태는 보관한다.
    - 도메인 레이어 : 도메인 정보를 포함. 업무 소프트웨어의 심장. 비즈니스 객체 상태를 포함.
    - 인프라스트럭처 레이어
    - 각각의 레이어는 자신에게만 집중해야한다. 그리고 각 레이어끼리 어떻게 소통할 것인지 규칙을 잘 수립해야한다.
- 엔티티
  - 엔티티는 소프트웨어가 여러 상태를 거치는 동안에도 동일한 값을 유지하는 식별자를 지니고 있다.
      - 연속성과 식별성의 흐름이 있다.(아직 이 말이 잘 이해가 안된다.)
  - 단순히 참조 값을 가지고 있고, 그 내부에 여러 값을 가지고 있는 객체는 엔티티가 아니다.
  - 사람이라는 개념을 구현하려고한다면, 이 사람이 고유한 사람이라는 것을 구분해낼 수 있는 식별자가 반드시 필요하다.
  - 은행 계좌 시스템에서 계좌 번호는 정확하게 식별가능한 값이다. 메모리상에 객체 상태로 존재하다 사라지더라도 지속성이 있으며, 식별성이 있다. (여기서 조금 이해가 된 것 같다.)
  - 소프트웨어에서 엔티티를 만들어낸다는 것은 이런 식별자를 만들어내는 작업이라해도 과언이 아니다.
- 값 객체 
  - 우리는 모든 객체를 엔티티로 만들어야하는 것일까? 모든 객체가 식별자를 가지도록 만들어야하는 것일까? 
  - 모든 객체가 엔티티가 되도록 만들면 몇 가지 문제점이 있다.
    1. 비용이 많이 든다. 각 인스턴스가 유일한 식별자를 가지도록 보장해야하지만, 이것을 고민하는 것은 쉽지 않은 일이다.(그냥 uuid를 쓰면 되는 것이 아닐까? 내가 아직 이 맥락에서의 식별자를 잘 이해를 못한 것 같다.)
    2. 성능상의 문제를 야기한다. 모든 객체를 엔티티로 만들면 메모리 사용량이 늘어나고, 성능이 저하된다. 
  - 그림 프로그램의 예시에서, point는 식별자를 가져야할까? 아니다. 그냥 좌표만 가지고 있으면 된다.
  - 도메인의 특정 요소에 속성을 포함시켜야할 때가 있고, 객체 자체가 아니라 그 객체가 가지는 속성에만 관심이 있는 경우가 있다. 이것들에는 식별자가 존재하지 않는다. 
    - 이런 것들을 우리는 값 객체라고 부른다. 
  - 딱 엔티티의 정의에 부합하는 객체만을 엔티티로 만들어야한다. 나머지는 모두 값 객체로 만들어라. 
  - 값 객체는 불변성을 가지고 있다. 
    - 최대한 단순하게 만든다. 만들어지고나면 생명주기동안 변하지 않는다. 값이 바뀌어야하면 다른 값을 만들어라. 
  - 값을 공유하려고 한다면, 이것은 무조건 불변성을 가져야한다. 
  - 값 객체의 각 속성들은 하나하나가 개념적으로 완전한 의미를 가져야 한다. 
    - 예를 들어, Customer에 name, street, city, state라는 정보가 있다고 할 때, street, city, state는 그 자체로 완전한 의미를 가지지 않는다. 
    - 이런 것들은 값 객체로 만든다. Address라는 값 객체를 만들어서 그 안에 street, city, state를 넣는다. 이런 속성들은 함께 존재해야 완전한 의미를 가진다. 
- 서비스 
  - 도메인 모델을 구성할 때, 행위를 정의해야 할 때가 있다. 행위는 언제나 객체 안에 포함되어야 하지만, 이 행위가 어떤 객체에 포함되어야할 지가 애매한 순간이 있다. 
  - 이런 종류의 행위가 도메인에서 식별되었을 때, 그것을 서비스로 정의한다. 서비스는 상태를 가지지 않고, 단순히 도메인에 기능을 제공하는 목적을 가진다. 
  - 서비스는 도메인 레이어에서 사용되기도 한다. 
    - 서비스는 서비스를 수행하는 객체 자신이 아니라 오퍼레이션이 수행되는 대상이나, 목적이 되는 객체와 관련이 있다.
    - 서비스는 이런 방식으로 많은 객체가 관계를 맺는 지점이 된다. 
  - 만약 오퍼레이션이 도메인에서 중요한 개념을 표현하고 있다면, 그것을 표현할 서비스를 생성해야한다. 
  - 서비스의 3가지 특징은 다음과 같다. 
    1. 서비스에 의해 수행되는 오퍼레이션은 일반적으로 엔티티 또는 값 객체에 속할 수 없는 도메인의 개념을 나타낸다. 
    2. 수행되는 오퍼레이션은 도메인의 다른 객체를 참조한다. 
    3. 오퍼레이션은 상태를 저장하지 않는다. 
  - 서비스를 만들 때, 
    - 도메인에서 주요 처리나 변경을 수행하는 작업을 발견했는데, 이것이 엔티티나 값 객체의 책임은 아니라고 한다면, 이것을 서비스로서 독립적인 인터페이스의 오퍼레이션으로 추가한다. 
    - 이 오퍼레이션의 이름을 유비쿼터스 언어의 일부로 만들어야 한다. 
    - 이때 서비스는 상태를 저장하지 않는다. 
  - 서비스를 사용할 때는 도메인 레이어를 분리시켜야 한다. 
  - 서비스가 속하는 레이어를 결정하는 것은 쉬운 일이 아니다. 
    - 만약 오퍼레이션이 개념적으로 애플리케이션 레이어에 속하는 일을 수행한다면 해당 서비스는 그 레이어에 존재해야한다. 
    - 만약 도메인 객체에 관한 것이고 엄밀하게 도메인과 연관되어 있으며 도메인에 필요한 것을 제공한다면 도메인 레이어에 속하도록 해야한다. 
- 모듈 
  - 모듈화란 관련된 개념과 작업을 조직화하여 복잡도를 감소시키는 기법이다. 
  - 대규모 모델이라도 모델 속에 있는 모듈간의 관계만 파악해도 큰 그림을 이해할 수 있다. 이렇듯 모듈은 복잡도를 관리하는데에 효율적이다. 
  - 모듈을 사용하는 또 다른 이유는 코드의 품질이다.
    - 코드의 품질을 높이기 위해서는 응집도가 높아야한다. 이 응집도에는 2가지 종류가 있다. 
      - 통신 응집도 : 통신 응집도는 모듈의 일부가 같은 데이터를 다룰 때 얻을 수 있다. 이 코드들은 관계가 견고하기 때문에 그룹핑하는 것이 당연하다.
      - 기능 응집도 : 기능 응집도는 모듈의 모든 부분이 잘 정의된 임무를 함께 수행하고 있을 때 얻어진다. 
  - 모듈은 다른 모듈이 접근할 수 있는 잘 정의된 인터페이스를 가져야 한다. 
  - 모듈이 잘 만들어지고 나면, 모듈 내부에는 변경이 많이 일어나는 반면에 모듈이 제공하는 내용 자체에는 변경되지 않는 경향을 보인다. 
