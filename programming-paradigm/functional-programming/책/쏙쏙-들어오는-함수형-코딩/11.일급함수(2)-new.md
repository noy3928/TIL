11장에서는 10장에서 다루었던 두가지 리팩터링 기법을 응용하는 방법에 대해서 더욱 구체적인 예시로 살펴본다. 그런 다음, 함수 본문을 콜백으로 드러내기에서 발생할 수 있는 또 다른 중복의 문제를 어떻게 해결할 수 있는지를 소개한다.


두 가지 리팩터링 기법을 응용하는 방법에 대해 설명하는 부분은 반복되는 내용이기 때문에, 특별히 요약-정리할 부분이 없다고 생각되었다.


## 함수 본문을 콜백으로 드러내기에서 발생한 중복의 문제를 해결하기 - function factory 

책에서는 예시를 설명하기 위해 로깅 동작을 소개한다. 특정한 함수의 동작에서 에러가 발생할 경우 에러 로깅을 하길 원한다고 할 때, 해당 동작을 함수 본문을 콜백으로 드러내기 기법을 이용해서, 조금 더 추상화된 함수로 뽑아낼 수 있다. 

하지만, 여기서 발생할 수 있는 문제점은 언제나 해당 함수를 호출할 때, 같이 호출해야한다는 것이다.

```
withLogging(eat)
withLogging(clean)
withLogging(running)
```

로깅 동작을 추상화해서 반복을 줄였다는 점에서는 좋지만, 또 다른 중복이 발생하고 있다.

이 부분을 해결하기 위해서는 function factory 기법을 이용할 수 있다. 이 기법은 특정한 동작을 하는 함수를 만들어내는 함수이다.

우리의 예시에서는 본래 함수의 동작에서, 로깅동작을 추가한 함수를 만들어내는 함수라고 보면 된다.

```js
const wrapLogging = (f) => (arg) => {
	try {
		f(arg);
	} catch(error) {
		logToSnapErrors(error);
	}
}
```

위의 함수를 보면, f함수를 인자로 받으면, arg라는 인자를 받았을 때, f 함수와 함께 호출하는 함수를 반환하고 있다. 





