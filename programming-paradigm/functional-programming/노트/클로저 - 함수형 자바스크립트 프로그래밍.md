
#클로저 

> 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수를 기억하는 함수다.

- 클로저가 기억하는 환경은 변수다. 
	- 변수의 값은 언제든지 변할 수 있다. 
	- '때'라는 표현때문에 생길 수 있는 오해 : 
		- 변수의 값이 변하지 않을 것이라는 오해.
- '환경'이라는 단어가 사용되는 이유는 참조가능한 변수의 범위가 바로 위 스코프만은 아니기 때문이다. 

> 클로저는 자신이 생성될 때의 스코프에서 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하여 유지시키는 함수다. 


```javascript
const a = 10;
const b = 20;

function f1(){
	return a + b;
}
f1()
```


- 이 f1함수는 클로저인가? 
	- 클로저가 아니다. 
	- 클로저라고 착각할 수 있는 지점 : 
		- 외부 변수를 참조하여 결과를 만든다. 
		- 상위 스코프의 변수를 사용하고 있으므로 강조했던 모든 조건을 충족함 
	- 클로저가 아닌 이유 : 
		- a와 b 변수가 f1에 의해서 사라지지 않는 상황이 아니기 때문이 f1은 클로저가 아니다. 
		- a와 b는 글로벌 스코프에서 선언된 변수다. 
			- 글로벌 스코프에서 선언된 변수는 해당 변수를 사용하는 함수가 있는지 없는지와 상관없이 유지된다. 


```javascript
function f4(){
	const a = 10;
	const b = 20;
	function f5(){
		return a + b;
	}
	return f5()
}
f4();
```


- 위 코드에는 클로저가 있을까?   
	- '있었다'가 정확한 대답이다. 
	- f4의 마지막 라인에서 f5를 호출하여 반환한다. 
		- 때문에 즉시 호출하면서 클로저가 생겼다가 f4가 실행되는 동안에만 있다가 사라진다. 



> 클로저는 자신이 생성되는 스코프의 실행 컨텍스트에서 만들어졌거나 알 수 있었던 변수 중 언젠가 자신이 실행될 때 사용할 변수들만 기억하는 함수이다. 클로저가 기억하는 변수의 값은 언제든지 남이나 자신에 의해 변경될 수 있다. 




## 클로저가 실용적인 상황 

- 이전 상황을 나중에 일어날 상황과 이어 나갈 때
- 함수로 함수를 만들거나 부분 적용을 할 때 


### 이전 상황을 나중에 일어날 상황과 이어 나갈 때 

- 이벤트 리스너로 함수를 넘기기 이전에 알 수 있던 상황들을 변수에 담아 클로저로 만들어 기억해 두면, 이벤트가 발생되어 클로저가 실행되었을 때 기억해 두었던 변수들로 이전 상황들을 이어갈 수 있다. 

```javascript
<div class="user-list"></div>

<script>
	const users = [
		{id : 1, name : 'HA', age : 25},
		{id : 2, name : 'PJ', age : 28},
		{id : 3, name : 'JE', age : 27}
	]

	$('.user-list').append(
		_.map(users, function(user){
			const button = $('<button>').text(user.name);
			button.click(function(){
				if(confirm(user.name + "님을 팔로잉 하시겠습니까?")) follow(user);
			})
			return button;
		}))

	function follow(user){
		$.post('/follow', {user_id : user.id}, function(){
			alert('이제' + user.name + "님의 소식을 보실 수 있습니다.")
		})
	}
</script>
```


- 버튼을 클릭하면 이전에 기억하고 있던 user 변수를 사용한다. 
	- user 변수는 button의 클릭 함수에 클로저로 등록되어있던 변수다. 