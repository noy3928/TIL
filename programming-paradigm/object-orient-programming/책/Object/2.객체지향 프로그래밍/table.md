# 01 영화 예매 시스템 이유

## 요구사항 살펴보기

- 미리 요구 사항을 살펴본다.
- 영화, 상영에 대한 개념을 구분하기
- 할인정책과 할인 조건에 대한 개념을 구분하기

<br>

# 02 객체지향 프로그래밍을 향해

## 협력, 객체, 클래스

- 객체지향하면 대부분의 사람들은 클래스를 떠올린다. 과연 이게 맞을까?
- 안타깝게도 틀렸다. 객체지향은 객체를 지향하는 것.
- 객체지향을 위해선 2가지에 집중해야한다.
  1. 어떤 객체들이 필요한지 먼저 고민한다.
     - 객체가 어떤 상태와 행동을 가지는지 생각해야 한다.
  2. 객체를 협력하는 공동체의 일원이라는 사실을 기억한다. 객체는 독립적인 존재가 아니다. 협력하는 존재다.
     - 이렇게 함으로써, 설계를 유연하고 확장 가능하게 만든다.
     - 협력하는 존재로 바라보는 것과 설계를 유연하고 확장가능하게 만드는 것은 어떤 관계가 있는 것일까?

<br>

요약 : 이 파트에서는 객체지향을 바라보기 위해서 주의해야 할 것을 말하고 있었다.

--- 

## 도메인 구조를 따르는 프로그램 구조

- 도메인 : 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야를 도메인이라고 부른다.
  - 영화 예매 시스템은 영화를 좀 더 쉽고 빠르게 예매하려는 사용자의 문제를 해결하려는 것. 그러면 영화 예매 시스템은 도메인?
- OOP가 강력한 이유 : 초기 단계부터 마지막 단계까지 객체라는 동일한 추상화 기법을 사용할 수 있다.
	- 요구사항과 프로그램을 같은 추상화 수준에서 바라볼 수 있다는 것이 이점이다. 이렇게 함으로써 복잡한 시스템을 단순화하여 설계하는 이점을 누릴 수 있다. 
		- 예를 들어서, 영화 예매 프로그램 이라는 큰 문제를 생각해 볼 때, 어떤 문제들을 해결하려고 하는지 고민을 해보면, 상영, 할인 정책, 할인조건과 같은 문제들이 해결되어야한다는 것을 생각해볼 수 있다. 이때 각각 상영, 할인 정책, 할인 조건들을 하나의 객체로 추상화시킬 수 있고, 이런 방식으로 실제 요구사항과 프로그램을 같은 수준에서 추상화 시킴으로써 복잡함을 극복할 수 있다는 이점이 있다. 
- 클래스의 이름은 도메인 개념의 이름과 동일하거나 유사하게 지어야 한다. 
- 클래스의 구조는 도메인의 구조와 유사한 형태를 띠어야 한다.
<br>

요약 : 도메인과 클래스의 관계를 설명하는 파트였다.

--- 


## 클래스 구현하기

- 클래스를 구현할 때, 주의할 점은 클래스의 경계를 구분 짓는 것이다. 경계를 구분짓는다는 것은 외부에 공개할 것과 내부에 감출 것을 구분한다는 말이다.
- 왜 구분해야하는가? : 경계의 명확성이 객체의 자율성을 보장한다.
  - 경계의 명확성과 객체의 자율성은 어떤 관계가 있는가? : 객체가 스스로 처리할 일은 내부에 감추어야 한다. 그렇게 함으로써 객체의 자율성을 보장할 수 있다.

### 자율적인 객체

1. 객체는 상태와 행동을 함께 가지는 복합적인 존재다.
2. 객체는 스스로 판단하고 행동하는 자율적인 존재다.

- 데이터와 기능을 객체 내부로 함께 묶는 것을 캡슐화라고 한다.
- 접근제어 메커니즘 : 외부에서 접근을 통제하는 메커니즘. private, protected, public 같은 접근 수정자를 제공.
- 접근을 통제하는 이유는 객체를 자율적인 존재로 만들기 위함이다. 객체가 외부의 간섭을 받는다면, 자율적인 존재가 될 수 없다.
- 캡슐화와 접근제어는 객체를 두 부분으로 나눈다.
  - 퍼블릭 인터페이스 : 외부에서 접근 가능한 부분
  - 구현 : 외부에서 접근 불가하고 내부에서만 접근 가능한 부분
  - 인터페이스와 구현의 분리라는 원칙은 훌륭한 객체 지향 프로그램을 만들기 위해 따라야하는 핵심 원칙이다.

### 프로그래머의 자유

- 프로그래머의 역할을 클래스 작성자와 클라이언트 프로그래머로 나누는 것이 유용하다. 
- 클라이언트의 목표 : 필요한 클래스들을 엮어서 어플을 빠르고 안정적으로 구축하는 것이다. 
- 클래스 작성자의 목표 : 클라이언트에게 필요한 부분만 공개하고 나머지는 숨긴다. 나머지를 숨김으로써 클라이언트에게 영향을 끼칠 것을 고민하지 않고도 내부 구현을 마음껏 바꿀 수 있다. 이것을 **구현 은닉**이라고 부른다.
- 객체를 외부와 내부로 구분하는 것의 효용성 : 
  - 클라이언트가 알아야 할 지식의 양이 줄어든다. 
  - 클래스 작성자는 자유럽게 구현을 변경할 수 있게 된다.
<br>
요약 : 클래스를 구현할 때 주의해야할 점에 대해서 설명하는 파트였다. 주의해야 할 점이란, 내부와 외부에 대한 경계를 명확히 구분짓는 것이다.

---

## 협력하는 객체들의 공동체

- 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현하는 것이다.
- 영화 예매를 위해서 각각의 인스턴스들은 서로의 메서드를 호출하며 상호작용한다.

<br>

요약 : 필요한 기능을 구현하며, 각각의 인스턴스가 서로의 메서드를 사용하는 상황을 보여준다. 이를 통해 협력이 중요함을 소개하고 있다. 

---


## 협력에 관한 짧은 이야기

- 요청과 응답
  - 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청할 수 있다.
  - 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답한다.
- 객체가 다른 객체와 상호작용을 할 수 있는 유일한 방법은 메시지를 전송하는 것 밖에 없다. (인터페이스)
- 메시지를 수신한 객체는 스스로의 결정에 따라 자율적으로 메시지를 처리한다. (메서드)
- 메시지와 메서드의 구분은 중요하다. 여기서부터 다형성의 개념이 등장한다.
  - 그리고 이런 다형성으로부터, 객체지향프로그래밍이 명성을 얻게되었다.
  - 다형성으로 말미암아, OOP는 유연하고 확장가능하며 재사용 가능한 설계를 할 수 있게 되었다.
- 객체는 메시지를 받고 어떻게 처리할지는 스스로 처리한다. 스스로 처리한다는 이 개념이 상당히 중요하다. 여기서부터 객체의 자율성이 나온다.
  - 아 객체가 자유로운 존재라고 말하는 것은 외부에서 간섭을 받지 않는 것을 넘어서, 메시지에 따라 어떻게 처리할지 스스로 정하는 것에도 있구나.
  - OOP에서 객체는 자유로운 존재다.
    - 외부의 간섭을 받지 않기 때문이다.
    - 메시지에 따라 상태를 어떻게 처리할지 스스로 결정하기 때문이다.

<br>

요약 : 메시지와 메서드의 구분을 이야기하고 있다. 이로부터 다형성의 개념에 대한 서두를 열고 있음을 알 수 있다.

---


# 03 할인 요금 구하기

## 할인 요금 계산을 위한 협력 시작하기

- 영화요금을 계산하는 메서드에는 이상한 점이 있다.
  - 어떤 할인 정책을 사용할 것인지 결정하는 코드가 존재하지 않는다.
- 이 코드에는 두 가지 개념이 숨어있다.
  - 상속
  - 다형성
- 그리고 이 두 가지 개념에는 추상화라는 원리가 숨어있다.
<br>

요약 : 상속과 다형성을 설명하기 위한 초석을 마련하고 있다.

---

## 할인 정책과 할인 조건

- 할인 정책은 금액 할인 정책과 비율 할인 정책으로 구분된다.

  - 두 클래스는 대부분의 코드가 유사하고 할인 요금을 계산하는 방식만 조금 다르다.
  - 때문에 공통된 코드를 보관할 장소가 필요하다.
  - 여기에서 부모 클래스의 개념이 등장한다.
    - 실제 어플에선 부모로부터 바로 인스턴스를 생성하지 않기 때문에 추상 클래스를 사용한다.

- 추상메서드의 등장
  - 부모 클래스에서 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에게 위임하는 디자인 패턴을 TEMPLATE METHOD패턴이라고 부른다.

<br>

요약 : 이 파트에서는 실제로 상속을 구현한 코드들을 설명하고 있다.

---
<br>

# 04 상속과 다형성

- 조건문도 없이 할인 정책을 결정할 수 있었던 이유는 상속과 다형성 덕분이다.

## 컴파일 시간 의존성과 실행 시간 의존성

- 의존성이 존재한다는 말 : 어떤 클래스가 다른 클래스에 접근할 수 있는 경로를 가지거나 해당 클래스의 객체의 메서드를 호출할 경우 두 클래스 사이에 의존성이 존재한다고 말한다.
- 문제 상황 :
  - Movie는 DiscountPolicy에 연결되어 있는 상황 (Movie는 DiscountPolicy가 필요하다는 말)
  - 문제는 DiscountPolicy가 아닌 인스턴스들이 필요하다는 것
  - 코드 수준에서 Movie는 amount나 percent어디에도 의존하고 있지 않다. 그러나 이 둘이 필요하다.
  - 이 둘이 실행 시점에 협력이 가능한 이유는 무엇인가?
    - Movie인스턴스를 생성할 때, 인자로 Amount or Percent의 인스턴스를 전달하면 된다.
    - 이렇게하면 Movie는 Amount 인스턴스에 의존하게 될 것이다.
- 코드 정리 : 
  - 코드상으로는 Movie는 DiscountPolicy에 의존한다. 
  - 그러나 실행 시점에는 Movie의 인스턴스는 AmountDiscountPolicy나 PercentDiscountPolicy의 인스턴스에 의존한다. 
- 코드의 의존성과 실행 시점의 의존성은 다를 수 있다. 
  - 장점 : 이렇게 코드와 실행 시점의 의존성이 다른 것은, 유연하고 재사용 가능하고, 확장 가능한 설계의 특징이다. 
  - 단점 : 코드를 이해하기 어려워진다. 
  - 트레이드오프 : 유연성과 가독성. 이 둘 사이의 트레이드 오프가 필요하다. 
- 나빠진 가독성의 사례 : 
  - Movie의 인스턴스가 어떤 객체에 의존하는지 확인. 
    - 코드만 살펴보는 것으로는 확인 불가. 
    - Movie를 생성하는 곳을 살펴봐야 함. 
    - 그래서 어떤 인자를 넣어주는지 확인해야 의존성이 확인가능해짐. 
  - 가독성이 나빠지면 디버깅도 어려워짐. 
- 트레이드 오프 :
  - 역시 트레이드오프가 필요함.

<br>

요약 : 코드와 실행시점에서의 의존성이 달라지는 상황. 이런 상황일 때, 설계의 유연성이 높아진다. 그러나 이렇게 유연성이 높아지면, 가독성이 떨어진다. 때문에 트레이드오프를 고려해야한다.

## 차이에 의한 프로그래밍

- 상속 :
  - 추가하려는 클래스가 기존의 클래스와 매우 비슷하다.
  - 그래서 기존의 클래스를 재사용하기로 했다.
  - 이것을 가능하게하는 것이 상속이다.
  - 상속을 이용하면 클래스 사이에 관계를 설정하는 것만으로 기존 클래스가 가지고 있는 모든 속성과 행동을 새로운 클래스에 포함시킬 수 있다.
- 차이에 의한 프로그래밍 :
  - 상속하고서, 부모와 차이가 있는 부분에 대해서만 추가해서 클래스를 만드는 방법을 말함.

<br>

요약 : 상속이 무엇인지에 대해서 설명하는 파트

## 상속과 인터페이스

- 상속이 가치 있는 이유 : 부모 클래스가 제공하는 인터페이스를 자식 클래스가 물려받기 때문.
  - 일반적인 오해 : 메서드나 인스턴스 변수를 재사용하는 것이 상속의 목적. 이는 잘못된 생각.
- 인터페이스 : 객체가 이해할 수 있는 모든 메시지 목록
- 상속을 하면 자식은 부모의 인터페이스를 물려받게 된다.
  - 자식은 부모가 수신할 수 있는 모든 메시지를 수신할 수 있게 된다.
  - 외부 객체 입장에선 자식을 부모와 동일한 타입으로 간주할 수 있게 된다.
- 메시지를 이해할 수 있는 것이 중요하다.
  - Movie는 협력 객체가 어떤 인스턴스인지 신경쓰지 않는다.
  - 본인이 보내는 메시지를 이해할 수 있는지 없는지만 신경쓴다.
  - 이게 부모 클래스인지, 자식 클래스인지, 자식 클래스 중에서 어떤 인스턴스인지는 중요하지 않다.
- 업캐스팅 : 자식 클래스가 부모 클래스를 대신하는 것
  - 다이어그램상에서 부모 클래스가 자식 클래스 위에 위치되기 때문에
  - 자식 클래스가 위에 위치한 부모 클래스로 자동적으로 타입 캐스팅 되는 것처럼 보이기 때문에 업캐스팅이라고 부름

<br>

요약 : 상속이 가치있는 일반적인 통념을 바로잡는 파트. 상속이 가치있는 이유는 인터페이스를 공유할 수 있게하기 때문이다.

## 다형성

- 메시지는 같지만, 클래스의 타입에 다른 메서드를 사용하는 상황에 대한 설명
- 동일한 메시지는 전송하지만 실제로 어떤 메서드가 실행될 것인지는 메시지를 수신하는 객체의 클래스가 무엇이냐에 따라 달라진다. 이것을 다형성이라고 한다.
- 다형성의 전제 : 컴파일 시간 의존성과 실행시간 의존성이 다를 수 있다.
- 다형성의 정의 : 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력을 말한다.
  - 따라서 협력에 참여하는 객체들은 모두 같은 메시지를 이해할 수 있어야 한다.
  - 다른 말로하면 인터페이스가 동일해야 한다는 것이다.
  - amount와 percent의 인터페이스가 같을 수 있었던 것은 부모 클래스로부터 상속을 받았기 때문이다.
- 여러 다형성 구현 방식 사이의 공통점 : 실행될 메서드를 컴파일 시점이 아닌 실행 시점에 결정한다는 공통점이 있다.
  - 메시지와 메서드를 실행 시점에 바인딩한다는 말이다.
  - 이것을 지연바인딩 or 동적 바인딩이라고 부른다.
- 다형성을 이야기 할 때 상속을 이야기하는 이유 : 다양한 클래스들이 동일한 인터페이스를 공유할 수 있게 하기 때문. 메시지와 메서드가 달라질 수 있는 이유가 된다.

<br>

요약 : 다형성이 무엇인지, 다형성과 상속은 어떤 관계가 있는지 설명해주는 파트. 다형성은 동일한 메시지에 다른 메서드로 응답할 수 있는 능력을 말하는 것이고, 그런 다형성이 가능하도록 해주는 방법이 상속임을 말하고 있었다.

## 인터페이스와 다형성

- 순수 인터페이스만 공유하고 싶을 때는 인터페이스라는 프로그래밍 요소를 이용하면 된다.

<br>

# 05 추상화와 유연성

## 추상화의 힘

- DiscountPolicy는 amount와 percent보다 더 추상적이다.
- DiscountPolicy나 DiscountCondition이 더 추상적인 이유 : 인터페이스에 초점을 맞추기 때문.
  - 이들의 자식들이 사용할 메시지를 정의한다.
  - 공통으로 가질 수 있는 인터페이스를 정의하며 구현의 일부를 자식 클래스가 결정할 수 있도록 결정권을 위임한다.
- 추상화의 2가지 장점 :
  1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술할 수 있다.
  2. 추상화를 이용하면 설계가 좀 더 유연해진다.
- 추상화를 이용하면 세부적인 내용을 무시한 채 상위 정책을 쉽고 간단하게 표현할 수 있다.
- 추상화를 이용해 상위 정책을 기술한다는 것 : 기본적인 어플리케이션의 협력 흐름을 기술한다는 것
  - 디자인 패턴이나 프레임워크 모두 추상화를 이용해 상위 정책을 정의하는 객체지향의 메커니즘을 활용하고 있다.

<br>

요약 : 추상화가 가지고 있는 2가지 장점이 핵심 내용이었다. 추상화를 활용하면 전체적인 협력 흐름을 서술할 수 있으며, 설계를 더 유연하게 만들 수 있다는 장점이 있다.

---

## 유연한 설계

- 조건문은 가능하면 사용하지 말 것 : 책임의 위치를 결정하기 위해 조건문을 사용하는 것은 협력의 설계 측면에서 대부분 좋지 않은 선택이다.
- 0원이라는 할인 요금을 계산할 책임을 Movie가 가지고 있었는데, 이것을 DiscountPolicy에게 옮겨야 한다.
  - 때문에 DiscountPolicy를 상속받는 NoneDiscountPolicy를 만들어야 한다.
  - 여기서 중요한 점은 DiscountPolicy를 수정하지 않고도 기능의 확장이 가능해졌다는 점이다.
- 추상화가 유연한 설계를 가능하게하는 이유 : 설계가 구체적인 상황에 결합되는 것을 방지하기 때문.
- 컨텍스트 독립성

<br>

요약 : 추상화를 통해 설계를 구현했더니, 기능의 확장이 쉬워졌다.

---

## 추상 클래스와 인터페이스 트레이드오프

- 모든 구현의 코드에는 트레이드오프가 존재한다.

## 코드 재사용

- 합성 : 다른 객체의 인스턴스를 자신의 인스턴스 변수로 포함해서 재사용하는 방법이다.
  - 코드 재사용을 위해서 상속을 사용하기도 하지만, 합성이 더 좋은 방법이다.
- 왜 상속보다 합성을 선호하는 것일까?

<br>

요약 : 합성이 코드 재사용을 위해서 더 선호되는 방법이라고 말한다. 그러나 이유는 설명해주지 않았다. 다음 파트에서 설명해주려는 것 같다.

## 상속

- 상속의 단점 :
  - 캡슐화를 위반한다. -> 부모의 구현이 자식에게 드러난다. 부모의 내부 구조를 잘 알아야 한다. 캡슐화가 약해진다.
    - 부모와 자식간에 강한 결합이 생긴다.
  - 설계를 유연하지 못하게 만든다. -> 부모의 구현이 자식에게 그대로 영향을 미치게 되기 때문에 문제가 된다.
- changeDiscountPolicy :
  - 인스턴스 변수로 연결한 기존 방법을 사용하면 실행 시점에 할인 정책을 간단하게 변경가능하다.
  - 이런 방법을 합성이라고 한다.

<br>

요약 : 상속이 가지고 있는 단점을 소개하는 파트였다. 그리고 합성에 대한 서문을 열고 있었다.

## 합성

- 상속의 문제를 해결하는 합성 :
  - 캡슐화 : 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하기 때문에 효과적으로 캡슐화할 수 있다.
  - 유연성 : 의존하는 인스턴스를 교체하는 것이 비교적 쉽다.
- 상속을 절대 사용하지 말라는 것은 아니다.
  - 상속과 합성을 같이 사용하는 것이 일반적이다.
  - 상속 : 다형성을 위해 인터페이스를 재사용하는 경우
  - 합성 : 코드를 재사용하는 경우
- 마무리 발언 :
  - 객체지향은 객체를 지향하는 것
  - 객체들 사이의 협력을 고려하는 것이 핵심

<br>

요약 : 합성이 어떻게 상속의 문제를 해결하는지 설명하고 있다. 그리고 상속과 합성을 어떤 경우에 사용해야하는지를 설명한다.


--- 

