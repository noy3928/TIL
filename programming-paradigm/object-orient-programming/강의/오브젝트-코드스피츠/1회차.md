

- 이 책은 진도를 빨리나갈만한 책이 아니다. 
- 이 강의는 책보다 조금 더 어려울 수도 있다. 
- 오늘은 이 책을 읽기 위한 기본적인 소양을 이야기할 것이다. 

<br>

## 철학에 대한 이야기

- 가치와 원칙
	- 이 두가지가 프로그래밍 철학을 이루는 두 기둥이된다. 
	- 패턴은 가치와 원칙이 반복될 때, 그것을 패턴이라고 부른다. 

### 가치 :
-  프로그래밍의 세계에서 가치에 대해서 이야기할 때, 결국 중요한 것은 비용적인 관점이다. 그렇다면 비용적인 관점에서 가치가 있는 코드는 무엇인가? 
	- 커뮤니케이션이 가능한 코드 
	- 간결한 코드 
	- 유연한 코드 (기능이 쉽게 추가될 수 있는 코드이다)

### 원칙 : 
- 원칙이란, 예외를 쉽게 찾을 수 있다는 점에서 비용의 효율을 추구하는 것이라고 할 수 있다. 

<br>

## 결국 객체지향이 지향하는 것은 무엇일까? 

- 비용을 줄이는 것이다. 다시 말하면, 생산성을 높이는 것이다. 조그만한 비용을 투자하고서도, 높은 생산성을 도출해낼 수 있게 되는 것. 이것을 위한 패러다임이 객체지향인 것이다. 
- 그렇다면 객체지향은 어떤 방식으로 이런 생산성을 높이고자 하는 것인가? 
	- 실제로 우리가 개발을 할 때, 새로운 코드를 추가하는데에 들어가는 비용은 2-30%밖에 되지 않는다. 나머지는 전부다 디버깅, 유지보수에 들어가는 비용이다. 
	- 유지보수에 들어가는 비용을 줄이는 것.
- 어떻게 그것을 하는가? 
	- 변화에 따른 격리를 명확하게 하는 것을 통해서 그것을 이루고자 하는 것이다. 
	- 이것을 위한 핵심 개념은 바로 "역할 모델"이다. 
		- 이 역할모델을 통해서 코드를 격리하는 것, 변경에 대한 대처를 하는 것이 객체지향의 핵심 개념이라고 할 수 있다. 
	- 만약 이 '역할모델'에 따른 코드의 분리를 할 수 있게 된다면, 그때서야 드디어 객체지향의 세계로 여러분이 입문하게 된 것이라고 할 수 있다. 


<br>

## 역할모델 : 
- 역할모델에 대해서 한번 이해를 해보자. 
- 이것을 이해하기 위해서는 먼저 추상화에 대해서 이해를 해야 한다. 



### 추상화 : 
- 추상화에도 또 3가지로 나뉘어질 수 있다. 
	- 일반화 : 다양한 현상에 대한 단 하나의 설명 공식을 만들어낸다던지, 단 하나의 원칙으로 풀어내는 것 
	- 연관화 : 이건 저친구것이니까 더 이상 신경안써, 책임을 넘기는 것. reference, dependence
	- 집단화 : 

- 또한 프로그래밍을 하면서 만날 수 있다는 추상화의 개념이 있다. 

- 데이터 추상화 : 
	- 모델링 : 특정 목표에 따라서 기억해야 할 핵심만 추린 것.  
	- 범주화 : 범위를 나누는 것. 특정 역할을 어떤 범위에서 사용할 것인가? 
		- 집에서 아빠라고 회사가서 아빠행새를 하면 안된다. 
	- 그룹화 : 
- 프로시저 추상화 : 
	- 메서드를 말하는 것이 아니다. 함수를 말하는 것. 
	- 어떤 함수냐? 어떤 데이터에 대한 처리 방법을 함수에게 시켰다고 가정했을 때 해당 함수를 우리는 프로시저라고 부를 수 있다. 
- 객체지향적 추상화 : 
	- 객체지향에서의 추상화는 거의 모든 종류의 추상화가 다 들어가있다. 
	- 장담하건데 굉장히 어렵다. 
	- 그러나 다시 한번 장담하건데, 이 오브젝트라는 책을 마스터하게 된다면, 모든 회사를 골라서 가게 될 것이다. 
		- 역할모델에 따른 설계의 격리를 효율적으로 할 수 있는 수준에 도달한다면. 

<br>

## 타이밍 : 

- 여러가지 타이밍에 대한 설명을 하고 있었다. 
	- 린트타임
	- 컴파일타임 
	- 런타임 
- 여기서 가장 강조하고 싶었던 타이밍은 런타임. 
	- 사람들은 가능하면 런타임에 에러를 발견하기 원하지 않는다. 왜냐하면 그것은 컨트롤하기 힘든 에러이기 때문이다. 
	- 때문에 컴파일타임, 린트타임에 최대한 에러를 발견할 수 있도록 노력하는 것이고 그 노력의 일환으로 린터나 타입스크립트 같은 것들이 도입된 것이다. 


## Pointer of Pointer 

- 이 파트에서는 참조에 의한 참조를 설명하고 있다. 
	- 해당 내용은 코어자바스크립트에서 레퍼런스타입의 불변성을 설명하던 내용과 거의 비슷한 내용이다. 
	- 메모리 상에서 특정 값을 참조하고 있는 값을 참조할 때 발생할 수 있는 일에 대한 내용을 다루고 있다. 
		- a에 "test"라는 값이 저장되어있다면, a는 test라는 값이 저장된 11이라는 메모리 주소를 가지고 있을 것이다. 만약 b가 a를 가리키도록 한다면 b는 11이라는 주소값을 가지고 있을 것이다. 그 상태에서, c와 d가 b와 같은 값을 가리키게하기 위해서 b를 가리키면 c와 d도 11을 가리킬 것이다. 그런데, b가 배신을 때려서 29를 가리킨다면, c와 d는 어떻게 되는가? c,d =b 라고 적혀있었지만, 현재로서는 서로 다른 값을 가리키고 있게 되는 것이 아닌가? 맞다. 서로 다른 값을 가리키게 된다. 이런 현상을 방지하기 위해서는 애초에 b가 레퍼런스타입이어야했다. b 자체가 레퍼런스타입이고, b의 레퍼런스를 다른 c와d도 참조하도록 만들어두었다면, b가 움직이는 값을 c와 d도 따라갔을 것이다. 
	- 직접 참조의 문제점을 다루는 것이다. 직접 참조를 했을 때 변경이 유연해질 수가 없다. 따라서 객체라는 레퍼런스타입을 사용하고자 하는것이 객체지향의 원리다. 객체를 사용할 때, 변경에 훨씬 더 유연하게 대처할 수 있게 되는 것이다. 이것이 동적 바인딩의 원리의 실체라고 할 수 있다. 
	- 이 개념으로부터 추상화된 인터페이스를 의존하는 개념도 도출되었다. 
	- 

---

## 내 생각과 정리 : 

- 오브젝트를 책으로만 읽다가, 이 책에 대해서 누군가 강의를 해주는 것을 듣고보니 너무 유익하다는 생각이 든다. 
	- 역할모델이라는 관점이 재미있었다. 
		- 생각해보니, 오브젝트 책은 객체는 자기의 일을 자기 스스로 처리하도록 만들어야하고, 그런 객체들이 모여서 협력을 하는 공동체를 우리는 객체지향적 프로그래밍이라 부를 수 있다고 했다. 
		- 여기서 자기의 일을 스스로 처리한다는 개념 자체가, 자신의 역할 모델을 이해하고 있다는 것이라고 할 수 있겠다. 객체는 자기에게 주어진 책임, 역할에 알맞는 일을 스스로 처리한다. 
		- 그리고 그것에 알맞게, 자신이 해야 할 일을 다른 이들이 하도록 만들지 않게 자신의 기능을 감추고 외부로부터 분리시켜야 한다. 
- 한 주에 한 강의씩만 들으려고 했는데, 아니 강의가 너무 재미있다. 강사가 오브젝트 책보다 더 깊은 내용을 다루게 될 것이라고 했는데, 그 말은 헛된 약속이 아니었다. 
