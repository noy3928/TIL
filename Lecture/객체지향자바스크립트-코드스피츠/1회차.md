
- 1회차 때 배우는 이론적인 내용이 이후 2-5강 동안에 활용될 것이다. 

- 어떤 패러다임을 사용할 것이냐는 판단 기준은 그렇게 중요하지 않다. 중요한 것은 다음과 같다. 
	- value context (값이라는 컨텍스트)
	- identifier context ()


- 값을 기반으로하는 프로그램은 값의 특징을 사용한다. 
	- 값이란 무엇일까? 
	- 메모리 주소가 무엇이냐는 신경쓰지 않고, 그 안에 들어있는 값이 같냐 다르냐. 이것에 대한 관점을 가지고 있는 것이 값 기반 프로그래밍이다.  
- 식별자 기반으로 하는 프로그래밍은 식별자를 통한 구별을 특징으로 한다. 
	- 무슨 말이냐?
	- 값이 같냐 다르냐는 신경쓰지 않는다. 해당 값이 들어가있는 주소가 무엇이냐. 그것이 중요하다. 주소가 다르면, 그 안에 들어가있는 값이 같아도 같은 것으로 취급하지 않겠다는 이야기다. 


- 객체지향은 철저하게 값 컨텍스트를 배제하는 프로그래밍이다. 
- 객체지향은 모든 상황에서 철저하게 객체만 사용하는 프로그래밍이다. 
	- 메서드가 되었든, 메서드의 인자가 되었든, 메서드의 반환값이 되었든 모든 것을 객체를 사용하는 방식으로 프로그래밍하는 방식 
	- 값을 사용하지 않는 프로그래밍 

- 값을 사용하는 컨텍스트에서의 특징 
	- 끝 없는 복사본 
		- 항상 복사본을 만들어낸다. 
	- 상태 변화에 안전 
		- 기존의 값에는 변화가 안생긴다는 점에서 안전하게 느껴질 수 있다. 
		- 그러나 관리 포인트가 생기는 것은 똑같다. 
	- 연산을 기반으로 로직을 전개 
		- 수학적 프로그래밍의 어려운 점은 복잡한 도메인의 연산을 수학적으로 표현해내는 것이 어렵다는 것이다. 
- 식별자를 사용하는 컨텍스트에서의 특징 
	- 하나의 원본 
	- 상태 변화를 내부에서 책임진다 
		- 내부 상태에 대해서 책임지는 객체를 만드는 것이 어렵다. 
	- 메시지를 기반으로 로직을 전개한다. 
		- 여기까지는 내가 했고, 그 다음건 모르겠어. 다른 애들한테 넘길께. 
			- 메시지를 통해서 다른 객체에게 책임을 위임하는 것 

- 값과 식별자 컨텍스트의 차이에 대한 이해 


## 다형성 

- 변신한다 
```javascript
const Worker = class{
	run(){
		console.log('working')
	}
	print(){
		this.run()
	}
}

const HardWorker = class extends Worker{
	run(){
		console.log('hardWorking')
	}
}

const worker = new HardWorker();
console.log(worker instanceof Worker); // 대체가능성
worker.print(); // 내적 동일성 

```
- 첫번째 질문 : 
	- HardWorker의 인스턴스는 Worker의 인스턴스이기도 할까? 
	- true이다. 
		- 자식은 부모를 대체할 수 있다 => 이것이 바로 다형성이다. 
		- Worker를 확장한 것이 HardWorker이다. 
			- HardWorkder는 Worker의 포괄적인 집합이다. 
			- 확장된 대상은 확장할 대상을 대체할 수 있는 것이 바로 다형성이다. 
				- 이것이 다형성의 핵심이다. 
			- 확장된 클래스는 대상 클래스를 대체할 수 있다. 
				- 이것을 `대체가능성` 이라고 부른다.
- 두번째 질문 : 
	- worker.print를 하면 어떤 일이 일어날까?
	- 우선 HardWorker라는 클래스에는 print라는 메서드가 존재하지 않는다. 
	- this.run을 실행하면 hardWorking이 출력된다. 
		- 이것은 업계에서 그렇게 하자고 정한 것이다. 태어났을 때의 인스턴스를 this로 유지하자
	- 결론적으로 다형성은 
		- 대체가능성 
		- 내적동일성
		- 이 2가지가 합쳐진 개념이 다형성인 것이다. 


- 다형성 : 
	- 대체가능성 : 확장된 객체는 원본으로 대체가능 
	- 내적 동일성 : 생성 시점의 타입이 내부에 일관성 있게 참조됨

- 이 다형성을 구현하는 방식은 다양하다. js는 프로토타입이라는 시스템을 통해서 이 다형성을 구현한다. 
	- 내적 일관성 
		- 프로토타입 체인에 대한 이야기 : 
			- 메서드를 찾다가 없으면 `__proto__`를 통해서 prototype을 찾아나선다. 가장 가까운 prototype에 찾는 메서드가 존재하면 해당 메서드를 이용한다. 
			- 이것을 통해서 내적 일관성을 달성하게 된다. 
	- 대체가능성 : (A instanceof B)
		- 이 Instanceof가 실행될 때, A의 `__proto__` 가 가리키고 있는 prototype의 constructor가 B의 생성자와 같은가? 이것을 확인한다. 
		- 안맞으면? 
			- 다시 prototype의 `_proto_` 속성을 확인해서 그 상위의 prototype을 확인하고, 그 prototype이 가지고 있는 contructor가 B와 같은지를 확인한다. 



## 객체의 본질적인 측면 


- 객체의 본질적인 측면 : 
	- 객체가 객체지향답다고 할 수 있는 객체, 객체지향에서 말하는 객체의 본질적인 측면은 무엇인가? 


```javascript
const EssentialObject = class{
	#name = "";
	#screen = null;
	constructor(name){
		this.#name = name;
	}
	camouflage(){
		this.#screen = (Math.random() * 10).toString(16).replace(".", "")
	}
	get name(){
		return this.#screen || this.#name;
	}
}
```

- 이 코드안에 객체지향의 본질적인 내용이 들어가있다. 
	- 먼저 `hide state` 라는 개념이 들어가있다. 
		- 속성이 private가 아니라면, 객체지향이 아니다. 
		- 이것을 객체라고 하려면 데이터 은닉을 하고 있는가? 라고 질문해보면 된다. 
		- 객체라고 말하기 위해서는 `상태를 외부에 보여주지 않는다` 가 무조건 성립되어야 한다. 
			- 객체 내부에 있는 값을 꺼내서 외부에서 사용할 수 있게 되면, 그때부터는 값 컨텍스트가 된다. 
	- `encapsulation`
		- 은닉과 캡슐화는 같은 개념이 아니다. 은닉은 데이터에 대해서 하는 것이고, 캡슐화는 메서드에 대해서 하는 것이다. 기능에 대해서 하는 것이다. 
		- 메서드가 내부에서 무슨 일이 일어나는지 외부에서는 알 면 안된다. 외부에서는 메서드를 그저 하나의 추상 인터페이스로 바라봐야 하는 것이다. 
		- 캡슐화의 책임 : 보다 기능을 더 잘 정리해서 외부에서 사용할 수 있게 만들어 줄 책임. 내부 구현을 드러내지 않을 책임이 캡슐화에게 있는 것이다. 


- 객체지향을 사용하기 어려운 이유는 타협하기 때문이다. 값 컨텍스트를 사용하려는 악한 마음. 


- 객체지향의 본질 : 
	- 기능의 캡슐화 `Encapsulation of Functionality`
	- 상태관리의 책임 `Maintenance of State`
		- 상태는 내부에서 관리해야 해. 상태 관리를 본인이 하지 않고, 외부가 하게 되면 그것은 객체가 아닌 것이다. 객체지향적이지 않은 상황이 되는 것이다. 
	- 객체지향이 어려운 이유는 모든 객체를 위 2가지를 만족시키면서 만들어줘야하기 때문에 어렵다. 


- 얼마나 빠르게 객체지향적 사고방식을 장착할 수 있느냐의 이야기 :
	- 연역적 사고과 귀납적 사고를 끊임없이 훈련해야 함. 
		- 추론능력을 키우는 것이 필수 
	- 자신의 주관을 빼고, 합리성을 추구하는 사고방식 
	- cs라는 영역은 이과의 분야중에서 유일하게 공리가 없는 영역이다. 
		- 수학조차도 0은 0이라고 정리하고 넘어간다. 
		- 이 영역은 패러다임의 shift가 없다. 
	- 컴퓨터 분야에서는 논리적 추론을 계속해서 이어나가는 것이 필요하다. 



- 객체지향에서 캡슐화와 상태관리의 책임을 본질로 보는 이유는 무엇인가? 
	- 이 2가지 만이 변화에 대한 해당 객체의 격리 구간을 만들어낼 수 있기 때문이다. 
	- 함수형이나, 객체지향이 궁극적으로 이루어내고 싶어하는 것은 변화에 대한 격리를 이룩해내는 것이다. 
		- 변화의 여파가 한 부분에 머물러 있도록 만드는 것. 이것이 궁극적인 지향점이다. 
		- 각 객체마다 변화에 대한 격리 구간을 만들어내기. 그러면 한 객체에서 변경이 생겨도 다른 객체로 변경사항이 퍼져나가지 않게 된다. 


## 알려진 기본 설계 요령 

### solid 원칙 

- 단일책임원칙 
	- 수정해야 하는 이유는 단 하나만 가진다. 피치 못하게 수정해야하는 이유는 이거 하나 뿐이야. 
		- 산탄총 수술. 객체가 하나의 변경이유를 가지지 못하면, 변경이 수 없이 전파되면서 지옥을 맛보게 된다. 
		- 산탄총 수술이 일어나는 이유는 srp를 지키지 않기 때문에. 
- 개방폐쇄원칙 
- 리스코프 치환 원칙 
	- 추상층의 정의가 너무 구체적이면 구상층의 구현에서 모순이 발생한다. 
		- 추상층(생물) - 숨을 쉰다, 다리로 이동한다. 
		- 구상층 
			- 사람 ok
			- 타조 Ok
			- 아메바 no
			- 독수리 no 
			- 고래 no
	- 이것이 리스코프 치환 원칙에 대한 이야기다. 
	- 업캐스팅이 안전하게 잘 되어야 하는데, 추상층을 잘못 정의내려버리면 추상층이 불가능해져 버린다.
- 인터페이스분리 1:00:44
	- 리스코프 치환원칙이 성립하지 않기 때문에하는 것이 무엇인가? 인터페이스 분리원칙이다. 
		- 자식 클래스가 부모 클래스에 대체될 수 없기 때문에 인터페이스를 분리해서, 대체가능하도록 만들어줘야한다. 
	- 특정 객체가 있다. 그리고 이 객체가 가지고 있는 메서드는 6개이다. 이 중 2가지는 A 모듈에 사용하고, 이 중 2가지는 B라는 모듈에, 2가지는 C라는 모듈에 사용한다. 
		- 낭비되는 메서드가 있는 상황. 
	- 분신을 만든다. 역할만큼 객체를 만들어서 사용하는 것이 인터페이스를 분리하지 않고 대처할 수 있는 첫번째 방법이다. 
		- 맹기환이라는 큰 객체에서, 분신을 만들어낸다. 그리고 각 모듈이 해당 분신을 상대하도록 만든다. 
		- 사장이라는 분신, 아빠라는 분신, 남편이라는 분신을 만든다. 
	- 아니면 애초에 각각의 인터페이스를 만드는 것이다. 사장이라는 인터페이스, 아빠라는 인터페이스, 남편이라는 인터페이스.
		- 그리고 해당 인터페이스에 알맞는 메서드를 오버라이딩하는 것이다. 
- 의존성 역전 원칙 
	- 의존성은 언제나 부모쪽으로 흘러야 한다. 그런데 코드를 보면, 하향식으로 이루어져있다. 
	- 만약 코드에 다운 캐스팅이 있다면 망한 것이다. 
	- 이것도 굉장히 어려운 스킬이다. 

> 고차원의 모듈은 저차원의 모듈에 의존하면 안된다. 이 두 모듈 모두 추상화된 것에 의존해야 한다. 

- 의존성 주입 (Dependency Injection)
- 제어역전 
- 의존성 부패방지(Hollywood Principle) 
	- 물어보지 말고 그냥 요청해라. 
	- 내가 필요하면 전화할께. 
	- 질의를 하면 격리를 빼먹게 된다. 
	- 이것을 지키고 있지 않으면, 캡슐화를 지키지 않고 있을 가능성이 높다. 
- Law of demeter 
	- 어떤 객체에 대한 지식을 알 때, 최소한의 지식만 알아야 한다. 
	- 최소한의 지식만 가지고 메서드나 객체를 만들어야 한다.
	- 최소한의 지식이란 인자로 넘어온 타입, 내부에서 생성한 객체의 타입, 원래 그 객체가 가지고 있던 필드의 타입 
		- 열차전복사고 (train wreck)
		- 원래 알아야하는 객체보다 더 많이 알게 된 상황. 



## 메시지(Message) 

- 객체지향에서 문제를 푸는 방법 : 
	- 메시지를 통해서 문제를 해결한다. 
	- 내가 해결할 수 없는 문제, 내가 책임질 필요가 없는 문제는 전문가에게 맡긴다. 
- SRP를 준수하는 객체망이 문제를 해결 : 
	- SRP를 준수하는 객체들은 자신이 할 수 있는 일이 한정적이다. 
		- 그들은 자신의 일에 전문가이다. 자신들의 책임이 되게 상세하게 분리될 것이다. 
	- 이렇게 되면 한번에 시스템이 해결될 수 없다. 
		- 때문에 각각이 협력을 해야한다. 책임을 다른 이들에게 위임하는 방식으로 이루어져야 한다. 
	- 설계는 언제나 트레이드오프를 따져보아야하는 것이다. 
	- 단일 책임을 준수하는 객체에게 책임 이상의 업무를 부여하면? 
		- 만능 객체가 되려한다 Or 다른 객체에게 의뢰한다. 
		- 다른 객체에게 의뢰하는 것이 정답 
		- 다른 객체에게 의뢰하는 것이 메시지를 보내는 것이다. 
		- 어떤 객체가 해야하는 일을 명확하게 정의내리고, 그 문제를 해결하는 전문가가 되도록 만든다. 
			- 그리고 그 전문가들이 협력하게 만든다. 
		1. 메시지 - 의뢰할 내용 
		2. 오퍼레이션 - 메시지를 수신할 객체가 제공하는 서비스
			1. 오퍼레이션은 실체가 아니다. 그것의 실체는 메서드이다. 
		3. 메서드 - 오퍼레이션이 연결될 실체 처리기 


## Dependency 

가장 중요한 격리의 문제이다. 
의존성이 심하면 심할 수록, 자신이 영향을 많이 받게 된다. 
의존되는 애들의 영향을 내가 그대로 받게 된다.  


- 설계의 문제점 : 
	- 의존성을 격리해야 하면서도, 다른 객체들과 소통해야한다. 이런 소통을 어떻게 적절하게 조율할 수 있는가? 이것이 문제다. 


### 의존성의 종류 

- 객체의 생명 주기 전체에 걸친 의존성 
	- 상속
		- 상속이 안좋은 이유는 부모와 자식간에 심한 결합도가 생기기 때문이다. 
		- 상속에 의한 의존성은 굉장히 강력하다.
	- 연관 
- 오퍼레이션 실행 시 임시적인 의존성 
	- 의존 
		- 런타임 의존성을 말하는 것 같다. 
		- 인자로 들어오는 객체에 대한 의존성 
		- 호출이 없으면 의존성이 안생기는 것 

- 의존성이 높으면 생기는 일 
	- 수정 여파의 규모가 증가한다. 
		- 의존성이 많아질 수록 수정할 것이 많아진다. 
	- 수정하기 어려운 구조가 생성된다. 
	- 순환 의존성 
		- a와 b사이에는 의존성이 없다. 근데 b가 c를 알고 있고, c가 a를 알고 있는 상황 
		- 의존성은 단계별로 끊지 않으면 순환 의존성에 의해서 모두가 한 가족이 되는 것이다. 
			- 하나 걸리면 단위테스트가 쫙 빨간색이 뜨게 된다. 

- 객체지향을 하는 이유는 의존성의 구간을 관리해서 변경을 격리시키는 것이다. 
	- 변화에 대한 격리를 하기 위한 것. 
	- 변화는 여기까지만 영향을 미치게 될 것이야. 


### Dependency Inversion 

- 어떤 경우에도 다운 캐스팅을 하지말 것 
- 항상 추상 인터페이스를 사용할 것 

```javascript
const Worker = class{
	run(){
		console.log("working")
	}
	print(){
		this.run();
	}
};
const HardWorker = class extends Workder{
	run(){
		console.log('hardWorking');
	}
}

const Manager = class{
	#workers;
	constructor(...workers){
		if(workers.every(w => w instanceof Worker)) this.#workers = workers;
		else throw "invalid workers";
	}
	doWork(){
		this.#workers.forEach(w => w.run())
	}
}
```

- 개방폐쇄원칙이 적용되면 자연스럽게 의존성 역전 원칙이 달성된다. 
	- 보통 동시에 실현된다. 


## Inversion of Control 

DIP 조차도 IC를 달성하기 위한 도구이다.
객체지향에서 가장 마지막으로 도달해야 할 지점은 바로 이곳이다. 

- 제어 역전을 배우는 것 


### 제어역전의 개념과 필요성 

1. control = flow control(흐름 제어)
2. 광의에서 흐름제어 = 프로그램 실행 통제 
3. 동기흐름제어, 비동기 흐름제어 

- if문이나, for문 과 같은 흐름제어. 
- 비동기 흐름제어. 
- 프로그램의 움직임의 흐름을 제어하는 것 
- 제어를 역전한다는 것은 무슨말일까? 
	- 역으로 그것을 대체하는 친구를 만들겠다는 것. 내가 그것을 하지 않고, 다른 애한테 시킬래. 

문제점 : 
- 흐름 제어는 상태와 결합하여 진행됨
- 상태 통제와 흐름제어 = 알고리즘 
- 변화에 취약하고 구현하기도 어려움 

대안 : 
1.제어를 추상화하고 
2.개별 제어의 차이점만 외부에서 주입받는다. 


- 현상으로부터 원리를 깨닫고, 원리를 가지고 현상에 다시 적용하면서 배우는 것. 
	- 이런 현상이 일어나는 것이 귀납적 사고와 연역적 사고가 한번에 일어나는 일이다. 
	- 추론 훈련을 해야만 cs를 잘할 수 있게 된다. 




```javascript
const Renderer = class{
	#base = null;
	constructor(baseElement){
		this.#base = baseElement;
	}

	set view(v){
		if(v instanceof View) this.#view = v;
		else throw `invalid view : ${v}`;
	}

	render(data){
		const base = this.#base, view = this.#view;
		if(!base || !view) throw "no base of view"
		let target = base.firstElementChild;
		do base.removeChild(target); while(target = target.nextElementSibling);
		// 기존의 base를 지워주는 작업 	
		base.appendChild(view.getElement(data))
		view.initAni();
		view.startAni();
	} 
}
```
- 이 레시피가 제어문이다. 
- 이제 모든 뷰를 만들어낼 때, 제어는 이 친구가 담당한다. 
	- 제어의 역전. 각 전문가들을 제어하는 역할을 스스로가 하지않고, 제어 레시피가 객 전문가들을 제어한다. 제어하는 대상을 다른 이에게 위임한 현상 
	- 모든 solid 원칙이 다 들어가야지, 제어역전이 가능해진다. 


```javascript
const renderer = new Renderer(document.body);
renderer.view = new class extends View{
	#el;
	getElement(data){
		this.#el = document.createElement('div');
		this.#el.innerHTML = `<h2>{data.title}</h2><p>${data.description}</p>`
		this.#el.style.cssText = "width : 100%;background;${data.background};"
		return this.#el
	}
	initAni(){
		const style = this.#el.style;
		style.marginLeft = "100%"
		style.transition = "all 0.3s";
	}
	startAni(){
		requestAnimationFrame(_ => this.#el.style.marginLeft = 0)
	}
}
```

- 3가지 메서드를 오버라이드 해주는 상황 
- 메서드에 대한 동작이나 책임은 각각의 class가 책임지고 있지만, 전체적인 흐름은 renderer가 제어하고 있다. 
- 실제 제어는 중앙에 있는 친구만 가져가게 된다. 

### 제어역전 실제 구현 

전략 패턴 & 템플릿 메서드 패턴 < 컴포지트 패턴 < 비지터 


---
## 강의를 들으면서 생기는 질문 : 

- 값 컨텍스트를 사용하거나, 식별자 컨텍스트를 사용하거나 둘 중 하나만 사용하는 방식을 강제하는 것이 좋다. 이것이 강사의 의견이다. 
	- 그렇게 생각하는 이유는 더 혼선이 생길 수 있기 때문이라는 것이다. 
	- 그런데 함수형 자바스크립트라는 책에서는 함수형과 객체지향을 적절히 섞어서 사용하는 것이 생산성의 최적점에 있다고 했었다. 이것과 상충되는 이야기인가? 
- "자식은 부모를 대체할 수 있다" 이것이 다형성이다. 라고 강사가 이야기 했다. 
	- 하지만 자식은 부모를 대체할 수 있다는 리스코프 치환 원칙이 아닌가? 
	- 리스코프 치환 원칙이 다형성의 전제조건이라는 것은 알고 있었지만, 그 원칙을 곧 다형성이라고 이야기할 수 있는 것일까? 
	- 내가 이해하고 있는 다형성은 "같은 메시지 다른 메서드"이다. 
	- 강의를 조금 더 듣다보니 이해가 되었다. 단순히 대체가능성을 놓고만 다형성을 이야기하려는 것은 아니었다. 
		- 강사가 말하려는 다형성은 대체가능성 + 내적동일성 이 두가지가 모두 만족해야만 가능한 것이다. 
		- 맞는 말인 것 같다. 내가 오브젝트 책으로부터 이해하게 된 "동일 메시지 다른 메서드"라는 개념은 또한 대체 가능성과 내적동일성이 만족되어야만 만들어질 수 있는 개념인 것이다. 
		- 다형성을 더 다채롭게 이해할 수 있게 된 것 같다. 
- 캡슐화와 데이터 은닉 
	- 강사는 데이터 은닉과 캡슐화를 다른 것으로 이야기하면서, 은닉은 데이터에 대해서 하는 것이고, 캡슐화는 메서드에 대해서 하는 것이라고 설명하고 있다. 
	- 그러나 나는 캡슐화를 데이터 은닉을 포괄한 개념으로 이해하고 있었다. 
		- 데이터 은닉은 그저 캡슐화의 한 기법일 뿐인 것이다. 
		- 캡슐화는 변하는 것과 변하지 않는 것을 구분해, 자주 변경되는 대상을 외부로부터 감추는 것이다. 
		- 메서드를 감추는 것을 캡슐화라고 한 것은 처음 듣는 이야기다. 
		- 오브젝트 책에서는 캡슐화의 목적. 지향점은 변경의 여파를 막는 것이라고 했다. 그런 관점에서 봤을 때, 잘 변하지 않는 대상만을 외부에 드러내려고 한다는 캡슐화의 정의가 알맞는 것 같다는 생각이든다. 하지만 이 강의에서는 왜 저렇게 정의를 내렸는지 조금 더 들어 볼 필요가 있을 것 같다. 


- 추가적으로 찾아봐야 할 개념 : 
	- 디미터 법칙 
	- 오퍼레이션 
































