
- 1회차 때 배우는 이론적인 내용이 이후 2-5강 동안에 활용될 것이다. 

- 어떤 패러다임을 사용할 것이냐는 판단 기준은 그렇게 중요하지 않다. 중요한 것은 다음과 같다. 
	- value context (값이라는 컨텍스트)
	- identifier context ()


- 값을 기반으로하는 프로그램은 값의 특징을 사용한다. 
	- 값이란 무엇일까? 
	- 메모리 주소가 무엇이냐는 신경쓰지 않고, 그 안에 들어있는 값이 같냐 다르냐. 이것에 대한 관점을 가지고 있는 것이 값 기반 프로그래밍이다.  
- 식별자 기반으로 하는 프로그래밍은 식별자를 통한 구별을 특징으로 한다. 
	- 무슨 말이냐?
	- 값이 같냐 다르냐는 신경쓰지 않는다. 해당 값이 들어가있는 주소가 무엇이냐. 그것이 중요하다. 주소가 다르면, 그 안에 들어가있는 값이 같아도 같은 것으로 취급하지 않겠다는 이야기다. 


- 객체지향은 철저하게 값 컨텍스트를 배제하는 프로그래밍이다. 
- 객체지향은 모든 상황에서 철저하게 객체만 사용하는 프로그래밍이다. 
	- 메서드가 되었든, 메서드의 인자가 되었든, 메서드의 반환값이 되었든 모든 것을 객체를 사용하는 방식으로 프로그래밍하는 방식 
	- 값을 사용하지 않는 프로그래밍 

- 값을 사용하는 컨텍스트에서의 특징 
	- 끝 없는 복사본 
		- 항상 복사본을 만들어낸다. 
	- 상태 변화에 안전 
		- 기존의 값에는 변화가 안생긴다는 점에서 안전하게 느껴질 수 있다. 
		- 그러나 관리 포인트가 생기는 것은 똑같다. 
	- 연산을 기반으로 로직을 전개 
		- 수학적 프로그래밍의 어려운 점은 복잡한 도메인의 연산을 수학적으로 표현해내는 것이 어렵다는 것이다. 
- 식별자를 사용하는 컨텍스트에서의 특징 
	- 하나의 원본 
	- 상태 변화를 내부에서 책임진다 
		- 내부 상태에 대해서 책임지는 객체를 만드는 것이 어렵다. 
	- 메시지를 기반으로 로직을 전개한다. 
		- 여기까지는 내가 했고, 그 다음건 모르겠어. 다른 애들한테 넘길께. 
			- 메시지를 통해서 다른 객체에게 책임을 위임하는 것 

- 값과 식별자 컨텍스트의 차이에 대한 이해 


## 다형성 

- 변신한다 
```javascript
const Worker = class{
	run(){
		console.log('working')
	}
	print(){
		this.run()
	}
}

const HardWorker = class extends Worker{
	run(){
		console.log('hardWorking')
	}
}

const worker = new HardWorker();
console.log(worker instanceof Worker); // 대체가능성
worker.print(); // 내적 동일성 

```
- 첫번째 질문 : 
	- HardWorker의 인스턴스는 Worker의 인스턴스이기도 할까? 
	- true이다. 
		- 자식은 부모를 대체할 수 있다 => 이것이 바로 다형성이다. 
		- Worker를 확장한 것이 HardWorker이다. 
			- HardWorkder는 Worker의 포괄적인 집합이다. 
			- 확장된 대상은 확장할 대상을 대체할 수 있는 것이 바로 다형성이다. 
				- 이것이 다형성의 핵심이다. 
			- 확장된 클래스는 대상 클래스를 대체할 수 있다. 
				- 이것을 `대체가능성` 이라고 부른다.
- 두번째 질문 : 
	- worker.print를 하면 어떤 일이 일어날까?
	- 우선 HardWorker라는 클래스에는 print라는 메서드가 존재하지 않는다. 
	- this.run을 실행하면 hardWorking이 출력된다. 
		- 이것은 업계에서 그렇게 하자고 정한 것이다. 태어났을 때의 인스턴스를 this로 유지하자
	- 결론적으로 다형성은 
		- 대체가능성 
		- 내적동일성
		- 이 2가지가 합쳐진 개념이 다형성인 것이다. 


- 다형성 : 
	- 대체가능성 : 확장된 객체는 원본으로 대체가능 
	- 내적 동일성 : 생성 시점의 타입이 내부에 일관성 있게 참조됨

- 이 다형성을 구현하는 방식은 다양하다. js는 프로토타입이라는 시스템을 통해서 이 다형성을 구현한다. 
	- 내적 일관성 
		- 프로토타입 체인에 대한 이야기 : 
			- 메서드를 찾다가 없으면 `__proto__`를 통해서 prototype을 찾아나선다. 가장 가까운 prototype에 찾는 메서드가 존재하면 해당 메서드를 이용한다. 
			- 이것을 통해서 내적 일관성을 달성하게 된다. 
	- 대체가능성 : (A instanceof B)
		- 이 Instanceof가 실행될 때, A의 `__proto__` 가 가리키고 있는 prototype의 constructor가 B의 생성자와 같은가? 이것을 확인한다. 
		- 안맞으면? 
			- 다시 prototype의 `_proto_` 속성을 확인해서 그 상위의 prototype을 확인하고, 그 prototype이 가지고 있는 contructor가 B와 같은지를 확인한다. 


- 객체의 본질적인 측면 : 
	- 객체가 객체지향답다고 할 수 있는 객체, 객체지향에서 말하는 객체의 본질적인 측면은 무엇인가? 


```javascript
const EssentialObject = class{
	#name = "";
	#screen = null;
	constructor(name){
		this.#name = name;
	}
	camouflage(){
		this.#screen = (Math.random() * 10).toString(16).replace(".", "")
	}
	get name(){
		return this.#screen || this.#name;
	}
}
```

- 이 코드안에 객체지향의 본질적인 내용이 들어가있다. 
	- 먼저 `hide state` 라는 개념이 들어가있다. 
		- 속성이 private가 아니라면, 객체지향이 아니다. 
		- 이것을 객체라고 하려면 데이터 은닉을 하고 있는가? 라고 질문해보면 된다. 
		- 객체라고 말하기 위해서는 `상태를 외부에 보여주지 않는다` 가 무조건 성립되어야 한다. 
			- 객체 내부에 있는 값을 꺼내서 외부에서 사용할 수 있게 되면, 그때부터는 값 컨텍스트가 된다. 
	- `encapsulation`
		- 은닉과 캡슐화는 같은 개념이 아니다. 은닉은 데이터에 대해서 하는 것이고, 캡슐화는 메서드에 대해서 하는 것이다. 기능에 대해서 하는 것이다. 
		- 메서드가 내부에서 무슨 일이 일어나는지 외부에서는 알 면 안된다. 외부에서는 메서드를 그저 하나의 추상 인터페이스로 바라봐야 하는 것이다. 
		- 캡슐화의 책임 : 보다 기능을 더 잘 정리해서 외부에서 사용할 수 있게 만들어 줄 책임. 내부 구현을 드러내지 않을 책임이 캡슐화에게 있는 것이다. 


- 객체지향을 사용하기 어려운 이유는 타협하기 때문이다. 값 컨텍스트를 사용하려는 악한 마음. 


- 객체지향의 본질 : 
	- 기능의 캡슐화 `Encapsulation of Functionality`
	- 



---
## 강의를 들으면서 생기는 질문 : 

- 값 컨텍스트를 사용하거나, 식별자 컨텍스트를 사용하거나 둘 중 하나만 사용하는 방식을 강제하는 것이 좋다. 이것이 강사의 의견이다. 
	- 그렇게 생각하는 이유는 더 혼선이 생길 수 있기 때문이라는 것이다. 
	- 그런데 함수형 자바스크립트라는 책에서는 함수형과 객체지향을 적절히 섞어서 사용하는 것이 생산성의 최적점에 있다고 했었다. 이것과 상충되는 이야기인가? 
- "자식은 부모를 대체할 수 있다" 이것이 다형성이다. 라고 강사가 이야기 했다. 
	- 하지만 자식은 부모를 대체할 수 있다는 리스코프 치환 원칙이 아닌가? 
	- 리스코프 치환 원칙이 다형성의 전제조건이라는 것은 알고 있었지만, 그 원칙을 곧 다형성이라고 이야기할 수 있는 것일까? 
	- 내가 이해하고 있는 다형성은 "같은 메시지 다른 메서드"이다. 
	- 강의를 조금 더 듣다보니 이해가 되었다. 단순히 대체가능성을 놓고만 다형성을 이야기하려는 것은 아니었다. 
		- 강사가 말하려는 다형성은 대체가능성 + 내적동일성 이 두가지가 모두 만족해야만 가능한 것이다. 
		- 맞는 말인 것 같다. 내가 오브젝트 책으로부터 이해하게 된 "동일 메시지 다른 메서드"라는 개념은 또한 대체 가능성과 내적동일성이 만족되어야만 만들어질 수 있는 개념인 것이다. 
		- 다형성을 더 다채롭게 이해할 수 있게 된 것 같다. 
- 캡슐화와 데이터 은닉 
	- 강사는 데이터 은닉과 캡슐화를 다른 것으로 이야기하면서, 은닉은 데이터에 대해서 하는 것이고, 캡슐화는 메서드에 대해서 하는 것이라고 설명하고 있다. 
	- 그러나 나는 캡슐화를 데이터 은닉을 포괄한 개념으로 이해하고 있었다. 
		- 데이터 은닉은 그저 캡슐화의 한 기법일 뿐인 것이다. 
		- 캡슐화는 변하는 것과 변하지 않는 것을 구분해, 자주 변경되는 대상을 외부로부터 감추는 것이다. 
		- 메서드를 감추는 것을 캡슐화라고 한 것은 처음 듣는 이야기다. 
		- 오브젝트 책에서는 캡슐화의 목적. 지향점은 변경의 여파를 막는 것이라고 했다. 그런 관점에서 봤을 때, 잘 변하지 않는 대상만을 외부에 드러내려고 한다는 캡슐화의 정의가 알맞는 것 같다는 생각이든다. 하지만 이 강의에서는 왜 저렇게 정의를 내렸는지 조금 더 들어 볼 필요가 있을 것 같다. 
	



































