
- 오늘은 Mvvm 시스템을 만들어보겠다. 


## MVVM 


### MVC 

model view controller 

![[스크린샷 2022-12-17 오후 4.33.38.png]]

- 모델을 컨트롤러가 가지고 와서, 뷰가 소비할 수 있는 형식으로 데이터를 가공해서 컨트롤러가 가져다 준다. 
	- 컨트롤러는 모델도 알고 뷰도 알고있다. 
	- 그리고 뷰도 어떤 모델을 갱신해야하는지, 모델도 알고 있다. 

- 하지만 뷰와 모델은 서로 변경의 이유가 다르다. 
	- 그런 상황에서 이 둘이 의존성이 있는 상황이다. 
	- 이것이 가장 큰 문제를 일으킨다. 



- 서버에서 MVC가 괜찮은 이유 : 
	- 서버에서는 단방향으로 흐름이 끊겨버린다. 
	- 컨트롤러에서 모델을 가져와서 데이터를 뷰에 알맞게 가공한 다음에 던져버린다. 그리고 모델은 뷰에 대한 의존성을 가지고 있지 않게 된다. 



- 또 다른 MVC 모델이 있다. 
![[스크린샷 2022-12-17 오후 4.37.45.png]]

- 이런 상황에서는 뷰와 모델에 대한 의존성을 컨트롤러가 가지고 있다. 
- 의존성이 제거되지도 않으면서, 컨트롤러에 대한 의존성이 굉장히 높아진다. 
- mvc 자체에서는 컨트롤러에 대한 의존성을 낮출 수 없다. 


### MVP [[Model-View-Presenter 패턴]]

![[스크린샷 2022-12-17 오후 4.40.46.png]]

- 이건 4세대 언어가 나왔을 때 출현되었다. 
- 뷰에 대한 모델의 의존성을 완전히 없애주는 패턴 
- 뷰가 모델을 아는게 문제야? 그럼 모델을 아예 모르게 만들어줄께 
	- MVC를 탈출하기 위한 패턴 이었다. 약간 극단적인 방식으로 
- 단점 : 게터 세터를 하나하나씩 만들어줘야한다. 그렇게 해야만 모델에 대한 의존성을 없앨 수 있다. 
	- 뷰 쪽에서 많은 게터 세터를 만들어줘야한다는 것이 단점. 
	- 뷰 컴포넌트가 무거위지는 단점 
	- 때문에 가볍에 뭔가 만들기에는 부담스럽다. 
	- 때문에 : 
		- 프레임워크가 제공해주면 하는데, 직접 만들기에는 부담스럽다. 


### MVVM [[Model View ViewModel 패턴]]


- view-model은 view를 대신하는 객체. 
- 바인드라는 친구가 진짜 뷰와 뷰모델 사이의 의존성을 없애버렸다. 
	- 현재 뷰는 뷰모델을 모르는 상황이다. 모든 것은 바인드 덕분. 이것이 가장 핵심이다. 
- 현재 그림은 단방향 바인딩의 모습이다. 
- viewmodel의 모든 속성을 바인드가 관찰하고 있다. 그래야 뷰모델의 변경이 뷰에 반영될 수 있다. 
- 뷰모델의 데이터는 모델로부터 공급받는다. 
- 옵저버가 어렵다. 그래서 옵저버 대신에 call을 사용할 것 이다. 약간 다른 방법. 
	- 뷰 모델이 바인더를 알고 있는 방법. 바인더가 뷰 모델을 알고 있는 상황. 
	- 이렇게 해서 뷰 모델이 바인더에게 직접 알려주는 방법. 나 속성이 변경되었어. 
- 이 모델의 목적 : 
	- 뷰와 뷰모델을 모르게 하는 것. 


## TypeCheck 

```javascript
const type = (target, type) => {
	if(typeof type == 'string'){
		if(typeof target != type) throw `invalid type ${target} : ${type}`;
	}else if(!(target instanceof type)) throw `invalid type ${target} : ${type}`;
	return target;
}
```

이 타킷이 그 타입이 아니라면