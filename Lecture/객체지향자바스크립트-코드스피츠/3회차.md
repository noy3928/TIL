# 3회차 

- 오늘은 컴포지션과 옵버저, 템플릿 메서드 패턴을 배워볼 것이다. 사실 이런 개념들을 쉬운 개념이 아니다. 어려운 개념이다. 
	- 실제로 써보면 굉장히 어려운 개념이다. 
- 지난시간에 우리가 만들어봤던 것은 옵저버블하지 않았다. 모델이 변경되면 자동으로 뷰가 변경되는 방식이 아니었다. 


## 전략

- 이 단어를 고유명사로 인식해야한다. 
	- 이 단어는 어떤 고유명사일까? 여기에 대체할 수 있는 의미는 무엇일까? 
	- 도메인, 지식. 과 같은 개념들이라고 할 수 있다. 
	- 내가 프로그램을 짰을 때, 어떤 문제를 해결하기 위한 핵심적인 지식을 말하는 것이다. 


```javascript
const Binder = class{
	#item = new Set;
	add(v, _ = type(v,BinderItem)){// 동적 언어의 스킬을 사용할 것
		this.#items.add(v);
	} 
	render(viewmodel, _ = type(viewmodel, ViewModel)){
		this.#items.forEach(item => {
		const vm = type(viewmodel[item.viewmodel], ViewModel), el = item.el;

// --------------------------------------- 여기까지 위 아래로 코드의 부분을 분리할 수 있다. 

		Object.entries(vm.styles).forEach(([k,v]) => el.style[k] = v);
		Object.entries(vm.attributes).forEach(([k,v]) => el.setAttribute(k,v));
		Object.entries(vm.properties).forEach(([k,v]) => el[k] = v);
		Object.entries(vm.events).forEach(([k,v]) => el["on" + k] => e => v.call);
		})
	}
}
```
- 이건 지난시간에 봤던 Binder 코드이다. 
- 이 코드는 사실 하나의 덩어리로 보일 수도 있겠지만, 사실은 그렇지 않다. 분명히 분리할 수 있는 부분이 존재한다. 

![[스크린샷 2022-12-28 오후 1.53.59.png]]
- 두 부분 : 
	- 바인더의 필드, 필드의 구조 ( Structure )
	- 필드에 대해서 루프를 돌고 있는 부분 ( Control )
- 위 부분들은 "전략"에 해당하는 부분이 아니다. 그저 구조와 관련된 부분일 뿐이다. 


![[스크린샷 2022-12-28 오후 1.55.13.png]]
- 그에 반하여 이 부분. 이 부분이야 말로, 전략과 관련된 문제이다. 
	- 특정 도메인을 해결하기 위한 알고리즘, 전략. 


- 그래서 때문에 우리는 이 Binder(바인더) 부분을 두 부분으로 나눠서 이해할 수 있다. 
	- 구조에 해당하는 부분
	- 전략에 해당하는 부분


- 전략은 무작정 구조와 분리되어서 작동할 수가 없다. 객체지향에서 객체란 자기만의 상태를 가지고, 바깥에 행위를 표현한다. 때문에 상태와 행위가 완전히 분리될 수 없다. 
	- 언제나 전략을 강구해놓으면, 특정 구조에 대한 전략일 수 밖에 없다는 점
	- 때문에 우리가 주목해야할 것은 특정한 자료구조는 특정한 전략에 매핑된다는 사실이다. 

- 이런 내용들을 배움으로써, 하고자 하는 것은 여러분들이 작성한 코드에서 어떻게 전략에 해당하는 부분과 구조에 해당하는 부분을 분리해 낼 것인가에 대한 이야기다. 이런 발상법을 연구하고 있는 중이다. 
- 때문에 객체지향에서는 이 부분을 컴포지션이라는 것을 통해서 해결한다. 
	- 컴포지션이란 코드를 객체로 바꾸는 것이다. 코드를 수정하게 되면, 모든 부분이 수정되게 된다. 때문에 코드를 수정하지 않고, 코드의 부분을 객체로 바꾸고, 객체의 내용을 수정하는 방식으로 바꾸는 것이다. 
- 전략을 도출해내는 데에 성공했다면, 
	- 전략이 코드의 구조와 어떤 방식으로 매핑되어있는지 잘 생각해보고, 
	- 그 다음 그 코드 부분을 어떻게 한다? 객체로 바꾸어줘야 한다. (컴포지션을 적용해줘야한다.)
	- 하지만 임의의 객체로 바꾸면 위의 코드와 일반화된 관계를 맺을 수가 없게 된다. 
		- 때문에 우리는 객체를 도출할 때, 인터페이스의 형식으로 도출해내야 한다. 형으로 도출해야지만, 그 형의 규격에 알맞게 협력하는 객체들이 반응할 수 있게 해주어야 한다. 
		- 주어진 객체가 어떤 방식의 객체인지를 협력하는 객체가 알아야 한다. 그렇게 아는 것을 뭐라고 부른다? 타입이라고 부른다. 그래서 우리는 타입을 정의해야 한다. 
- 의존성 : 
	- 이제 코드 부분을 객체로 바꾸게 되면, 이제 바인더 클래스 내부에는 해당 객체에 대한 의존성이 생기게 된다. 해당 객체에 대한 의존성이 생기게 되는 것이다. 바인더는 이제 "전략" 객체에 대한 의존성이 생기게 된다. 
	- 객체지향에서 의존성이 발생하는 이유 : 
		- 단순히 위임했기 때문이 아니다. 전략에 해당하는 부분을 다른 객체에게 위임하고 싶은데, 그 객체에게 위임하고나면, 그것을 의존할 수 밖에 없게 되기 때문이다. 
		- 이렇게 자연스럽게 객체 의존성이 생기게 된다. 
	- 이제 내부에서는 특정 형에 대한 의존성만 생기게 만들고, 특정 구체적인 객체에 대한 의존성을 없애도록 만들어야 한다. 
		- 이렇게 하는 것을 의존성 주입이라고 한다. (Dependency injection) 
- 이제 우리는 코드로 작성되어있는 것을 일반화된 객체로 바꾸려고 한다. 
	- 이제 우리는 여기서 연역적 추리를 해야한다. 
	- 연역적 추론 : 다양한 구상화로부터 원리가 되는 추상화를 도출해내는 것
		- 그러면 우리가 해야하는 것은 전략에 해당하는 내용들을 관찰한 다음, 공통점을 뽑아내면 되는 것이다. 

- 그래서 해당 공통점들을 뽑아내어서, 전략에 해당하는 클래스를 작성해보자. 

```javascript
const Processor = class{
	process(vm, el, k, v, _0 = type(vm, ViewModel), _1 = type(el, HTMLElement), _2 = type(k, "string")){
		this._process(vm, el, k, v); // Template method
	}
	_process(vm, el, k, v){throw "override";}
}
```
- 이 컴포지션(코드를 객체화하는 것)은 부모와 자식 사이에서 일어나는 것이다. 
- 따라서 우리는 의존성 주입을 2가지 측면에서 바라볼 수 있다. 
	- 외부에서 의존성을 주입하는 것. 
	- 자식과의 Injection을 성립시키는 것  
		- 이렇게 자식에서 메서드에 위임하는 방식을 Template method라고 한다. 
	- 우리는 외부에서 의존성을 주입하는 방식으로 할 수도 있고, 내부에서 자식에게 위임하는 방식으로도 할 수 있다.  
- Template method : 
	- 외부에서 바라봤을 때는 그냥 process에 불과하다.
	- 그런데, 내부에서는 자식쪽으로 의존하고 있는 injection에 의존하고 있다. 그래서 이렇게 자식쪽의 메서드에 해당하는 부분을 Hook이라고 부른다. 
	- 이 친구는 무조건 추상 클래스를 가정하고 있다. 이 부분을 구상클래스로 사용할 수 없다. 


- 알고리즘은 항상 구조와 관련이 있다. 
	- 때문에 현재까지의 template method를 들여봤을 때, 단점이 되는 부분은 해당 메서드에는 어떤 구조와 매핑되어 사용될 것인지에 대한 힌트가 없다는 것이다. 
	- 그래서 아래와 같은 방식으로 새롭게 구현한다. 
		- 카테고리를 받아오는 방식으로 구현 

```javascript
const Processor = class{
	cat;
	constructor(cat){
		this.cat = cat;
		Object.freeze(this);
	}
	process(vm, el, k, v, _0 = type(vm, ViewModel), _1 = type(el, HTMLElement), _2 = type(k, "string")){
		this._process(vm, el, k, v); // Template method
	}
	_process(vm, el, k, v){throw "override";}
}

new(class extends Processor{
	_process(vm, el, k, v){el.style[k] = v;}
})("styles")

new(class extends Processor{
	_process(vm, el, k, v){el[k] = v;}
})("properties")

new(class extends Processor{
	_process(vm, el, k, v){el.setAttribute(k, v);}
})("properties")

new(class extends Processor{
	_process(vm, el, k, v){el["on" + k] = e => v.call(el, e, vm);}
})("properties")
```

- 익명 클래스를 만든 이유 : 
	- 인스턴스를 여러개 생성하지 않기 위해서 [19:00]
		- 근데 왜 인스턴스를 여러개 생성하지 않으려고 하는 것일까? 


이제 다시 프로세서를 개조해보자. 

```javascript
const Binder = class{
	#item = new Set;
	#processors = {};
	add(v, _ = type(v,BinderItem)){// 동적 언어의 스킬을 사용할 것
		this.#items.add(v);
	} 
	addProcessor(v, _0=type(v, Processor)){
		this.#processors[v.cat] = v;
	}
	render(viewmodel, _ = type(viewmodel, ViewModel)){
		const processores = Object.entries(this.#processors);
		this.#items.forEach(item => {
		const vm = type(viewmodel[item.viewmodel], ViewModel), el = item.el;
		processors.forEach(([pk, processor]) => {
			Object.entries(vm[pk]).forEach(([k, v]) => {
				processor.process(vm, el, k, v)
			})
		})
		})
	}
}
```

- processor를 Set로 잡지 않은 이유 : [21 : 00]
	- v.cat이라는 카테고리당 하나의 프로세서만 장착하게 하기 위한 것 



--- 

## 강의를 들으면서 생겼던 질문 : 

- 왜 바인더 클래스에서 구조에 해당하는 부분과 전략에 해당하는 부분을 분리시켰는가? 
	- 변경에 대한 격리를 위해서. 전략에 해당하는 내용은 따로 객체로 만들고, 해당 전략의 변경 사항은 따로 놀 수 있게, 변경 사항을 격리시킬 수 있게 하기 위해서 그렇게 따로 분리해놓는다. 
- [[hook이란 무엇인가?]] 
- [[template method란 무엇인가?]] 
- 객체지향은 숙련하는 수 밖에 없다. 
	- 코드로 계속해서 쳐보면서 숙련해야한다. 