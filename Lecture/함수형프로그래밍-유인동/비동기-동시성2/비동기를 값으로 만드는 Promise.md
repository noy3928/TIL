### 날짜 : 2022-11-14 18:01
### 주제 : 

---- 

### 메모 : 
>Promise가 가지는 결정적 차이점은 비동기를 일급 값으로 다룬다는 점이다. Promise는 Promise라는 클래스를 통해서 만들어진 인스턴스를 반환한다. 그 값은 대기, 성공, 실패를 다루는 일급 값으로 이루어져있다.  대기되어있는, 성공된, 실패된 어떤 컨텍스트가 아니라 하나의 값으로 다룬다는 점이 결정적인 차이가 된다. 이 점을 중요하게 이해할 필요가 있다. 


```javascript
function add10(a, callback){}

const a = add10(5, res => {
	add10(res, res => {
		add10(res, res => {
			log(res);
		})
	})
})

function add20(a){
	return new Promise(resolve => setTimeout(() => resolve(a + 20), 100));
}

const b = add20(5)
	.then(add20)
	.then(add20)
	.then(log)
```

- 콜백 같은 경우는 컨텍스트가 남고, undefined가 그 자리에 남게 된다. 
- 하지만 프로미스를 사용하면, 아직 값이 도착하지 않았음에도 그 자리에 promise가 반환된다. 
	- promise가 리턴되기 때문에 그 이후에 내가 원하는 일들을 다룰 수 있다는 점에서 굉장히 큰 차이가 있다. 
		- then을 이용해서 내가 원하는 일들을 할 수가 있다. 
		- then을 사용하면 그 자리에 한번 더 promise가 반환되게 된다. 
		- 비동기로 일어난 상황에 대해서 값으로 다룰 수 있다는 점. 
			- 미래에 도착할 어떤 값을 하나의 값으로 다룰 수 있다는 점이 굉장히 특이한 점이라고 할 수 있다. 
			- 이렇게 값으로 다루어진다는 것은 이것이 일급이라는 이야기다. 
			- 일급이라는 것은 어떤 변수에 할당 될 수 있고, 어떤 함수에 전달될 수 있고, 전달된 값들을 통해서 어떤 일들을 계속해서 이어나갈 수 있다는 것이다. 이 점이 가장 중요한 차이가 된다. 



### 내 생각과 정리 : 
- 첫번째 강의에서는 콜백 패턴와 promise를 비교하여 보여주고 있다. 
	- 흔히 알 수 있듯이 콜백지옥의 현상을 보여주면서 비교한다. 

 - 아... 이제서야 모나드가 실패하는 경우의 값을 다루는 하나의 추상이라고 했던 것이 이해가 된다. 단순히 콜백 코드로만 비동기 상황을 대하면 그것은 undefined 말고는 정의될 방법이 없다. undefined로 되면 도대체 이게 어떤 값이 될지, 어떤 일이 일어나고 있는지를 이해할 수 없다. 그러나 Promise객체를 이용하면, 미래에 도착하게 될 값 또한 하나의 래퍼에 감싸고, 그것 또한 하나의 추상으로 승격시켜서 우리가 그 값을 다룰 수 있도록 만들어준다. 
[[3분 모나드]]
[[모나드란 무엇인가? - Naver D2]]
[[JS개발자는 아직도 모나드를 모르겠어요]]


### 출처(참고문헌) : 


### Link : 
