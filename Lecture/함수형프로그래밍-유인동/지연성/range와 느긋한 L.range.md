### 날짜 : 2022-11-13 00:27
### 주제 : #함수형프로그래밍 #유인동 #지연성 

---- 

### 메모 : 

```javascript
const add = (a, b) => a + b;

const range = l => {
	let i = -1;
	let res = [];
	
	while(++i < l){
		res.push(i);
	}
	return res;
}
```

- 느긋한 range를 보자 

```javascript
const L = {};

L.range = function *(l){
	let i = -1;
	while(++i < l){
		yield i;
	}
}

const list = L.range(4);
log(reduce(add, list));
```

- 이터레이터는 그 내부의 값이 하나 실행될 때마다, 그때서야 평가가 실행된다. 
- 제네레이터를 활용해서 반환받은 list의 경우는 reduce를 통해서 배열에 들어가기 전까지는 배열이 아니다. 이 값이 평가되기 전까지는 어떤 형태로 존재하던지 상관없는 것이다. 

```function test(name, time, f){
	console.time(name);
	console.ti
}
```


### 내 생각과 정리 : 
- 함수형에서는 지연성. 느긋한 평가. 이런 개념들이 중요하게 다루어지는 것 같다. 
- 함수형에서 지연성이 중요한 이유는 무엇일까? 
	- 우선 커리를 생각해봤을 때, 커리의 경우에는 왜 지연된 방식으로 함수를 다루고자 하는 것일까? 왜 평가를 지연시키는 것일까? 커리의 경우는 특정값을 미리 담아놓은 상태에서 마지막 인자를 받는 시점에 평가가 실행됨으로써, 필요한 값들을 미리 넣어둘 수 있다. 이렇게 함으로써 재사용성을 높일 수 있다는 장점이 있다. 
	- 지금 보고 있는 제너레이터의 경우에도 지연성을 가지고 있다. 이 제네레이터의 지연성은 어떤 목적을 가지고 있는 것일까? 그러니까 이터레이터의 지연성 말이다. 


### 출처(참고문헌) : 


### Link : 
