> https://blog.isquaredsoftware.com/2021/01/context-redux-differences/


React Context는 "상태 관리" 도구가 아니며 Redux를 대체하지 않는다.

- 2021년 1월 18일에 작성된 이 포스트는 "React Context vs Redux"라는 주제에 대한 오해를 해소하기 위한 목적으로 작성되었다. React 커뮤니티 내에서 "Context vs Redux"는 가장 논란이 많은 주제 중 하나이다. 그러나 대부분의 혼란은 이 두 도구의 목적과 사용 사례에 대한 이해 부족에서 비롯된다. 나는 이미 Redux와 Context에 대한 여러 질문에 대답했으며(예: Redux - Not Dead Yet!, React, Redux, and Context Behavior, A (Mostly) Complete Guide to React Rendering Behavior, and When (and when not) to Reach for Redux), 그럼에도 불구하고 혼란은 더욱 심해지고 있다.

- 이 주제에 대한 질문이 많은 만큼, 나는 이 게시물을 해당 질문들에 대한 명확한 대답으로 제시한다. Context와 Redux가 실제로 무엇이고 어떻게 사용되어야 하는지, 그들의 차이점은 무엇이며 언제 사용해야 하는지에 대해 설명하겠다.

- TL;DL : Context와 Redux는 같은 도구가 아니다. 이들은 서로 다른 기능을 수행하며, 서로 다른 목적으로 사용된다.
- Context는 "상태 관리" 도구가 아니다. Context는 의존성 주입의 한 형태이다. 이는 전달 메커니즘이며, 어떤 "상태 관리"도 사용자의 코드와 useState/useReducer를 통해 사용자에 의해 수행된다.
- Context와 useReducer는 Redux를 대체하는 것이 아니다. 이들은 유사한 점과 겹치는 부분이 있지만, 기능적인 차이점이 있다.
- Context를 언제 사용해야 할까? React 컴포넌트 트리의 일부에 액세스할 수 있는 값을 가지고 있고, 해당 값을 props를 통해 각 수준의 컴포넌트를 거치지 않고 전달하고자 할 때 사용한다.
- Context와 useReducer를 언제 사용해야 할까? 특정 섹션의 복잡한 React 컴포넌트 상태 관리가 필요할 때 사용한다.

- Redux는 언제 사용해야 할까? Redux는 다음과 같은 경우에 가장 유용하다:
	- 많은 곳에서 필요한 대량의 애플리케이션 상태가 있는 경우
	- 앱 상태가 시간이 지남에 따라 자주 업데이트되는 경우
	- 상태를 업데이트하는 로직이 복잡한 경우
	- 중간 또는 대형 규모의 코드베이스를 가진 경우
	- 부수 효과 관리, 지속성 및 데이터 직렬화와 같은 고급 기능이 필요한 경우

- React Context와 Redux는 모두 React 생태계에서 상태 관리 도구로 사용될 수 있다. 그러나 그들은 서로 다른 목적과 기능을 가지고 있으며, 특정 프로젝트의 요구 사항에 따라 선택되어야 한다.

- 마지막으로, React 생태계는 끊임없이 발전하고 있으며, 상태 관리를 위한 대안적인 솔루션을 제공하는 새로운 라이브러리와 패턴이 나오기도 한다. 항상 최신 개발 동향을 따라가고, 특정 프로젝트 요구 사항에 가장 적합한 도구를 선택하는 것이 좋다.



----


## Context와 Redux의 이해

어떤 도구를 올바르게 사용하기 위해서는 다음을 명확히 이해하는 것이 중요합니다.

1. 해당 도구의 목적
2. 어떤 문제를 해결하려고 하는지
3. 언제와 왜 원래 만들어졌는지

또한, 현재 애플리케이션에서 해결하려는 문제를 명확히 이해하고, 당신의 문제를 가장 잘 해결하는 도구를 선택하는 것이 중요합니다. 다른 사람이 사용하라고 말하거나 인기가 있는 도구를 선택하는 것이 아니라, 이 특정한 상황에서 당신에게 가장 적합한 도구를 선택해야 합니다.

"Context vs Redux"에 대한 혼란은 이러한 도구가 실제로 무엇을 하는지와 어떤 문제를 해결하는지에 대한 이해의 부족에서 비롯됩니다. 따라서, 이 도구를 언제 사용해야 하는지 알기 위해선 먼저 그들이 무엇을 하고 어떤 문제를 해결하는지 명확히 정의해야 합니다.


## React Context는 무엇인가요?

먼저, React 문서에서 Context에 대한 실제 설명을 살펴보겠습니다.

Context는 매번 수동으로 props를 각 레벨에서 전달하지 않고도 컴포넌트 트리를 통해 데이터를 전달하는 방법을 제공합니다.

일반적인 React 애플리케이션에서 데이터는 상위에서 하위로 (부모에서 자식으로) props를 통해 전달되지만, 이는 애플리케이션 내 많은 컴포넌트에서 필요한 특정 유형의 props (예: 로캘 환경 설정, UI 테마)에 대해서는 불편할 수 있습니다. Context는 트리의 모든 레벨을 통해 명시적으로 prop을 전달하지 않고도 이러한 값들을 컴포넌트간에 공유하는 방법을 제공합니다.

여기서 주목할 점은 "값을 관리한다"라고 말하지 않고 "값을 전달하고 공유한다"라고 언급한다는 것입니다.

현재의 React Context API (React.createContext())는 React 16.3에서 처음으로 출시되었습니다. 이는 초기 버전의 React부터 사용 가능했던 레거시 컨텍스트 API를 대체하였으나, 주요한 설계 결함이 있었습니다. 레거시 컨텍스트의 주요 문제점은 컨텍스트를 통해 전달된 값의 업데이트가 shouldComponentUpdate를 통해 렌더링을 건너뛰는 경우 "차단"될 수 있다는 것입니다. 많은 컴포넌트가 성능 최적화를 위해 shouldComponentUpdate에 의존하기 때문에 이러한 문제로 인해 레거시 컨텍스트는 일반 데이터 전달에 쓸모없게 되었습니다. createContext()는 이러한 문제를 해결하기 위해 설계되었으며, 가운데 컴포넌트가 렌더링을 건너뛰어도 값의 업데이트가 자식 컴포넌트에서 볼 수 있도록 합니다.

### Context 사용하기
앱에서 React Context를 사용하기 위해서 몇 가지 단계가 필요합니다:

먼저, const MyContext = React.createContext()를 호출하여 컨텍스트 객체 인스턴스를 생성합니다.
부모 컴포넌트에서 <MyContext.Provider value={someValue}>를 렌더링합니다. 이렇게 하면 컨텍스트에 하나의 데이터가 들어갑니다. 그 값은 문자열, 숫자, 객체, 배열, 클래스 인스턴스, 이벤

트 이밋터 등 아무 것이나 될 수 있습니다.
그런 다음, 해당 제공자로 중첩된 모든 컴포넌트에서 const theContextValue = useContext(MyContext)를 호출합니다.
부모 컴포넌트가 다시 렌더링되고, 제공자의 값으로 새로운 참조를 전달할 때마다 해당 컨텍스트를 읽는 모든 컴포넌트는 다시 렌더링됩니다.

대부분의 경우, 컨텍스트의 값은 React 컴포넌트 상태에서 나오는 것입니다. 다음과 같은 방식으로 작성됩니다:

```js
function ParentComponent() {
  const [counter, setCounter] = useState(0);

  // 값을 및 설정자를 포함하는 객체 생성
  const contextValue = {counter, setCounter};

  return (
    <MyContext.Provider value={contextValue}>
      <SomeChildComponent />
    </MyContext.Provider>
  )
}
```

그런 다음 자식 컴포넌트에서 useContext를 호출하여 값을 읽을 수 있습니다:
```js

function NestedChildComponent() {
  const { counter, setCounter } = useContext(MyContext);

  // 카운터 값과 설정자를 사용하여 작업 수행
}
```

### Context의 목적과 사용 사례
이를 통해 Context가 사실상 아무것도 "관리"하지 않는다는 것을 알 수 있습니다. 대신, 파이프나 웜홀과 같습니다. <MyContext.Provider>를 사용하여 파이프의 상단에 무언가를 넣으면 (무엇이든 될 수 있음), 그 하나의 것이 파이프를 따라 내려가서 다른 컴포넌트에서 useContext(MyProvider)로 요청할 때까지 나옵니다.

따라서, Context를 사용하는 주요 목적은 "prop drilling"을 피하는 것입니다. 이 값을 명시적으로 각 컴포넌트 트리의 모든 레벨을 통해 props로 전달하는 대신, <MyContext.Provider>로 중첩된 모든 컴포넌트는 필요에 따라 useContext(MyContext)를 사용하여 값을 가져올 수 있습니다. 이는 코드를 간소화시키는데 도움이 됩니다. 추가적인 prop 전달 로직을 작성할 필요가 없기 때문입니다.

개념적으로, 이는 "의존성 주입"의 한 형태입니다. 자식 컴포넌트가 특정 유형의 값을 필요로 한다는 것을 알고 있지만, 해당 값을 자체적으로 생성하거나 설정하지 않습니다. 대신, 런타임에 어떤 부모 컴포넌트가 그 값을 전달할 것으로 가정합니다.

## Redux란 무엇일까

리덕스(Redux)는 어플리케이션 상태를 관리하고 업데이트하기 위한 패턴과 라이브러리입니다. "액션"이라 불리는 이벤트를 사용하여 상태를 업데이트합니다. 리덕스는 어플리케이션 전체에서 사용해야 하는 상태를 위한 중앙 저장소 역할을 하며, 상태가 예측 가능한 방식으로만 업데이트될 수 있도록 규칙을 제공합니다.

리덕스는 여러 부분에서 필요한 "전역" 상태를 관리하는 데 도움을 줍니다.

리덕스에서 제공하는 패턴과 도구를 사용하면, 어플리케이션의 상태가 언제, 어디서, 왜, 어떻게 업데이트되는지 이해하기 쉬워지며, 상태 변경이 발생할 때 어플리케이션 로직이 어떻게 동작할지 예측할 수 있습니다.

이 설명에는 다음과 같은 내용이 포함되어 있습니다:

- "상태 관리"를 명확히 언급합니다.
- 리덕스의 목적은 상태가 어떻게 시간에 따라 변경되는지 이해하는 데 도움을 주는 것입니다.

역사적으로, 리덕스는 원래 "플럭스(Flux) 아키텍처"의 구현으로 만들어졌습니다. 플럭스 아키텍처는 페이스북에서 2014년에 React가 나온 후 제안된 패턴이었습니다. 이 발표 이후로 커뮤니티에서는 플럭스 개념에 다양한 접근 방식을 적용한 수십 개의 라이브러리가 만들어졌습니다. 리덕스는 2015년에 등장하여 "플럭스 전쟁(Flux Wars)"에서 가장 우수한 설계를 제공하고, 사람들이 해결하려고 시도한 문제와 가장 잘 맞아 React와 훌륭하게 동작하는 것으로 인해 승리했습니다.

리덕스의 아키텍처적 특징은 가능한 한 많은 코드를 예측 가능한 "리듀서" 함수로 작성하고, "어떤 이벤트가 발생했는지"와 "그 이벤트가 발생했을 때 상태가 어떻게 업데이트되는지"를 분리하는 데에 함수형 프로그래밍 원칙을 강조합니다. 리덕스는 또한

 미들웨어를 사용하여 리덕스 저장소의 기능을 확장하고, 부수 효과를 처리하는 데에도 사용됩니다.

리덕스는 리덕스 개발 도구(Redux Devtools)도 제공하며, 이를 통해 어플리케이션에서 발생한 액션과 상태 변경의 이력을 시간에 따라 확인할 수 있습니다.


