> https://blog.isquaredsoftware.com/2021/01/context-redux-differences/


React Context는 "상태 관리" 도구가 아니며 Redux를 대체하지 않는다.

- 2021년 1월 18일에 작성된 이 포스트는 "React Context vs Redux"라는 주제에 대한 오해를 해소하기 위한 목적으로 작성되었다. React 커뮤니티 내에서 "Context vs Redux"는 가장 논란이 많은 주제 중 하나이다. 그러나 대부분의 혼란은 이 두 도구의 목적과 사용 사례에 대한 이해 부족에서 비롯된다. 나는 이미 Redux와 Context에 대한 여러 질문에 대답했으며(예: Redux - Not Dead Yet!, React, Redux, and Context Behavior, A (Mostly) Complete Guide to React Rendering Behavior, and When (and when not) to Reach for Redux), 그럼에도 불구하고 혼란은 더욱 심해지고 있다.

- 이 주제에 대한 질문이 많은 만큼, 나는 이 게시물을 해당 질문들에 대한 명확한 대답으로 제시한다. Context와 Redux가 실제로 무엇이고 어떻게 사용되어야 하는지, 그들의 차이점은 무엇이며 언제 사용해야 하는지에 대해 설명하겠다.

- TL;DL : Context와 Redux는 같은 도구가 아니다. 이들은 서로 다른 기능을 수행하며, 서로 다른 목적으로 사용된다.
- Context는 "상태 관리" 도구가 아니다. Context는 의존성 주입의 한 형태이다. 이는 전달 메커니즘이며, 어떤 "상태 관리"도 사용자의 코드와 useState/useReducer를 통해 사용자에 의해 수행된다.
- Context와 useReducer는 Redux를 대체하는 것이 아니다. 이들은 유사한 점과 겹치는 부분이 있지만, 기능적인 차이점이 있다.
- Context를 언제 사용해야 할까? React 컴포넌트 트리의 일부에 액세스할 수 있는 값을 가지고 있고, 해당 값을 props를 통해 각 수준의 컴포넌트를 거치지 않고 전달하고자 할 때 사용한다.
- Context와 useReducer를 언제 사용해야 할까? 특정 섹션의 복잡한 React 컴포넌트 상태 관리가 필요할 때 사용한다.

- Redux는 언제 사용해야 할까? Redux는 다음과 같은 경우에 가장 유용하다:
	- 많은 곳에서 필요한 대량의 애플리케이션 상태가 있는 경우
	- 앱 상태가 시간이 지남에 따라 자주 업데이트되는 경우
	- 상태를 업데이트하는 로직이 복잡한 경우
	- 중간 또는 대형 규모의 코드베이스를 가진 경우
	- 부수 효과 관리, 지속성 및 데이터 직렬화와 같은 고급 기능이 필요한 경우

- React Context와 Redux는 모두 React 생태계에서 상태 관리 도구로 사용될 수 있다. 그러나 그들은 서로 다른 목적과 기능을 가지고 있으며, 특정 프로젝트의 요구 사항에 따라 선택되어야 한다.

- 마지막으로, React 생태계는 끊임없이 발전하고 있으며, 상태 관리를 위한 대안적인 솔루션을 제공하는 새로운 라이브러리와 패턴이 나오기도 한다. 항상 최신 개발 동향을 따라가고, 특정 프로젝트 요구 사항에 가장 적합한 도구를 선택하는 것이 좋다.



----


## Context와 Redux의 이해

어떤 도구를 올바르게 사용하기 위해서는 다음을 명확히 이해하는 것이 중요합니다.

1. 해당 도구의 목적
2. 어떤 문제를 해결하려고 하는지
3. 언제와 왜 원래 만들어졌는지

또한, 현재 애플리케이션에서 해결하려는 문제를 명확히 이해하고, 당신의 문제를 가장 잘 해결하는 도구를 선택하는 것이 중요합니다. 다른 사람이 사용하라고 말하거나 인기가 있는 도구를 선택하는 것이 아니라, 이 특정한 상황에서 당신에게 가장 적합한 도구를 선택해야 합니다.

"Context vs Redux"에 대한 혼란은 이러한 도구가 실제로 무엇을 하는지와 어떤 문제를 해결하는지에 대한 이해의 부족에서 비롯됩니다. 따라서, 이 도구를 언제 사용해야 하는지 알기 위해선 먼저 그들이 무엇을 하고 어떤 문제를 해결하는지 명확히 정의해야 합니다.


## React Context는 무엇인가요?

먼저, React 문서에서 Context에 대한 실제 설명을 살펴보겠습니다.

> Context는 매번 수동으로 props를 각 레벨에서 전달하지 않고도 컴포넌트 트리를 통해 데이터를 전달하는 방법을 제공합니다.

일반적인 React 애플리케이션에서 데이터는 상위에서 하위로 (부모에서 자식으로) props를 통해 전달되지만, 이는 애플리케이션 내 많은 컴포넌트에서 필요한 특정 유형의 props (예: 로캘 환경 설정, UI 테마)에 대해서는 불편할 수 있습니다. Context는 트리의 모든 레벨을 통해 명시적으로 prop을 전달하지 않고도 이러한 값들을 컴포넌트간에 공유하는 방법을 제공합니다.

여기서 주목할 점은 "값을 관리한다"라고 말하지 않고 "값을 전달하고 공유한다"라고 언급한다는 것입니다.

현재의 React Context API (React.createContext())는 React 16.3에서 처음으로 출시되었습니다. 이는 초기 버전의 React부터 사용 가능했던 레거시 컨텍스트 API를 대체하였으나, 주요한 설계 결함이 있었습니다. 레거시 컨텍스트의 주요 문제점은 컨텍스트를 통해 전달된 값의 업데이트가 shouldComponentUpdate를 통해 렌더링을 건너뛰는 경우 "차단"될 수 있다는 것입니다. 많은 컴포넌트가 성능 최적화를 위해 shouldComponentUpdate에 의존하기 때문에 이러한 문제로 인해 레거시 컨텍스트는 일반 데이터 전달에 쓸모없게 되었습니다. createContext()는 이러한 문제를 해결하기 위해 설계되었으며, 가운데 컴포넌트가 렌더링을 건너뛰어도 값의 업데이트가 자식 컴포넌트에서 볼 수 있도록 합니다.

### Context 사용하기
앱에서 React Context를 사용하기 위해서 몇 가지 단계가 필요합니다:

먼저, const MyContext = React.createContext()를 호출하여 컨텍스트 객체 인스턴스를 생성합니다.
부모 컴포넌트에서 <MyContext.Provider value={someValue}>를 렌더링합니다. 이렇게 하면 컨텍스트에 하나의 데이터가 들어갑니다. 그 값은 문자열, 숫자, 객체, 배열, 클래스 인스턴스, 이벤트 이밋터 등 아무 것이나 될 수 있습니다.
그런 다음, 해당 제공자로 중첩된 모든 컴포넌트에서 const theContextValue = useContext(MyContext)를 호출합니다.
부모 컴포넌트가 다시 렌더링되고, 제공자의 값으로 새로운 참조를 전달할 때마다 해당 컨텍스트를 읽는 모든 컴포넌트는 다시 렌더링됩니다.

대부분의 경우, 컨텍스트의 값은 React 컴포넌트 상태에서 나오는 것입니다. 다음과 같은 방식으로 작성됩니다:

```js
function ParentComponent() {
  const [counter, setCounter] = useState(0);

  // 값을 및 설정자를 포함하는 객체 생성
  const contextValue = {counter, setCounter};

  return (
    <MyContext.Provider value={contextValue}>
      <SomeChildComponent />
    </MyContext.Provider>
  )
}
```

그런 다음 자식 컴포넌트에서 useContext를 호출하여 값을 읽을 수 있습니다:
```js

function NestedChildComponent() {
  const { counter, setCounter } = useContext(MyContext);

  // 카운터 값과 설정자를 사용하여 작업 수행
}
```

### Context의 목적과 사용 사례
이를 통해 Context가 사실상 아무것도 "관리"하지 않는다는 것을 알 수 있습니다. 대신, 파이프나 웜홀과 같습니다. <MyContext.Provider>를 사용하여 파이프의 상단에 무언가를 넣으면 (무엇이든 될 수 있음), 그 하나의 것이 파이프를 따라 내려가서 다른 컴포넌트에서 useContext(MyProvider)로 요청할 때까지 나옵니다.

> 따라서, Context를 사용하는 주요 목적은 "prop drilling"을 피하는 것입니다. 

이 값을 명시적으로 각 컴포넌트 트리의 모든 레벨을 통해 props로 전달하는 대신, <MyContext.Provider>로 중첩된 모든 컴포넌트는 필요에 따라 useContext(MyContext)를 사용하여 값을 가져올 수 있습니다. 이는 코드를 간소화시키는데 도움이 됩니다. 추가적인 prop 전달 로직을 작성할 필요가 없기 때문입니다.

개념적으로, 이는 "의존성 주입"의 한 형태입니다. 자식 컴포넌트가 특정 유형의 값을 필요로 한다는 것을 알고 있지만, 해당 값을 자체적으로 생성하거나 설정하지 않습니다. 대신, 런타임에 어떤 부모 컴포넌트가 그 값을 전달할 것으로 가정합니다.

## Redux란 무엇일까

리덕스(Redux)는 어플리케이션 상태를 관리하고 업데이트하기 위한 패턴과 라이브러리입니다. "액션"이라 불리는 이벤트를 사용하여 상태를 업데이트합니다. 리덕스는 어플리케이션 전체에서 사용해야 하는 상태를 위한 중앙 저장소 역할을 하며, 상태가 예측 가능한 방식으로만 업데이트될 수 있도록 규칙을 제공합니다.

리덕스는 여러 부분에서 필요한 "전역" 상태를 관리하는 데 도움을 줍니다.

리덕스에서 제공하는 패턴과 도구를 사용하면, 어플리케이션의 상태가 언제, 어디서, 왜, 어떻게 업데이트되는지 이해하기 쉬워지며, 상태 변경이 발생할 때 어플리케이션 로직이 어떻게 동작할지 예측할 수 있습니다.

이 설명에는 다음과 같은 내용이 포함되어 있습니다:

- "상태 관리"를 명확히 언급합니다.
- 리덕스의 목적은 상태가 어떻게 시간에 따라 변경되는지 이해하는 데 도움을 주는 것입니다.

역사적으로, 리덕스는 원래 "플럭스(Flux) 아키텍처"의 구현으로 만들어졌습니다. 플럭스 아키텍처는 페이스북에서 2014년에 React가 나온 후 제안된 패턴이었습니다. 이 발표 이후로 커뮤니티에서는 플럭스 개념에 다양한 접근 방식을 적용한 수십 개의 라이브러리가 만들어졌습니다. 리덕스는 2015년에 등장하여 "플럭스 전쟁(Flux Wars)"에서 가장 우수한 설계를 제공하고, 사람들이 해결하려고 시도한 문제와 가장 잘 맞아 React와 훌륭하게 동작하는 것으로 인해 승리했습니다.

리덕스의 아키텍처적 특징은 가능한 한 많은 코드를 예측 가능한 "리듀서" 함수로 작성하고, "어떤 이벤트가 발생했는지"와 "그 이벤트가 발생했을 때 상태가 어떻게 업데이트되는지"를 분리하는 데에 함수형 프로그래밍 원칙을 강조합니다. 리덕스는 또한

 미들웨어를 사용하여 리덕스 저장소의 기능을 확장하고, 부수 효과를 처리하는 데에도 사용됩니다.

리덕스는 리덕스 개발 도구(Redux Devtools)도 제공하며, 이를 통해 어플리케이션에서 발생한 액션과 상태 변경의 이력을 시간에 따라 확인할 수 있습니다.

### 리액트와 리덕스 

리덕스(Redux) 자체는 UI에 구애받지 않습니다. 리액트(React), 뷰(Vue), 앵귤러(Angular), 바닐라 JS 등 어떤 UI 레이어와도 함께 사용할 수 있으며, 아예 UI 없이도 사용할 수 있습니다.

그렇지만 리덕스는 주로 리액트와 함께 사용됩니다. 리액트-리덕스(React-Redux)는 공식적인 UI 바인딩 레이어로서, 리액트 컴포넌트가 리덕스 스토어와 상호작용할 수 있도록 해줍니다. 이는 리덕스 상태 값을 읽고 액션을 디스패치할 수 있도록 합니다. 따라서 대부분의 사람들이 "리덕스"라고 언급할 때는 "리덕스 스토어와 리액트-리덕스 라이브러리를 함께 사용하는 것"을 의미합니다.

리액트-리덕스는 어플리케이션 내의 모든 리액트 컴포넌트가 리덕스 스토어와 상호작용할 수 있도록 합니다. 이는 내부적으로 컨텍스트(Context)를 사용하기 때문에 가능합니다. 그러나 중요한 점은 리액트-리덕스가 컨텍스트를 통해 리덕스 스토어 인스턴스를 전달한다는 것입니다. 현재 상태 값을 직접 전달하는 것이 아니라는 점에 주목해야 합니다. 이는 위에서 언급한 의존성 주입(Dependency Injection)의 한 예입니다. 리덕스와 연결된 리액트 컴포넌트가 리덕스 스토어와 통신해야 한다는 것은 알지만, 컴포넌트를 정의할 때 어떤 리덕스 스토어를 사용할 지는 알거나 신경쓰지 않습니다. 실제 리덕스 스토어는 리액트-리덕스의 `<Provider>` 컴포넌트를 사용하여 런타임에 트리에 주입됩니다.

이로 인해 리액트-리덕스는 컨텍스트를 내부적으로 사용하기 때문에 프롭 드릴링(Prop Drilling)을 피하는 데에도 사용될 수 있습니다. `<MyContext.Provider>` 에 새로운 값을 명시적으로 넣는 대신 데이터를 리덕스 스토어에 넣고 어디서든 접근할 수 있습니다.


### 리덕스의 목적과 사용 사례

리덕스를 사용하는 주요 이유는 Redux 문서의 설명에서 잘 나타나 있습니다.

리덕스가 제공하는 패턴과 도구는 애플리케이션의 상태가 언제, 어디서, 왜, 어떻게 업데이트되는지, 그리고 상태 변경이 발생할 때 애플리케이션 로직이 어떻게 작동하는지 이해하기 쉽게 만들어 줍니다.

리덕스를 사용하는 추가적인 이유도 있습니다. "프롭 드릴링(Prop Drilling)을 피하는" 것이 그 중 하나입니다. React의 레거시 컨텍스트가 제대로 동작하지 않았기 때문에 많은 사람들이 초기에 리덕스를 선택하여 프롭 드릴링을 피할 수 있었습니다.

리덕스를 사용하는 다른 유효한 이유는 다음과 같습니다:

UI 레이어와 완전히 분리된 상태 관리 로직을 작성하고 싶은 경우
AngularJS에서 React로 이관되는 애플리케이션과 같은 다른 UI 레이어간에 상태 관리 로직을 공유하고자 하는 경우
리덕스 미들웨어의 강력한 기능을 활용하여 액션이 디스패치될 때 추가적인 로직을 추가하고 싶은 경우
리덕스 상태의 일부를 지속시키고자 하는 경우
개발자가 재생할 수 있는 버그 리포트를 활성화하는 경우
개발 중에 로직과 UI를 더 빠르게 디버깅할 수 있는 경우
Dan Abramov는 2016년에 게시한 "You Might Not Need Redux"라는 글에서 이러한 사용 사례를 나열했습니다.


## Context가 "상태 관리"가 아닌 이유

"상태(State)"는 애플리케이션의 동작을 설명하는 모든 데이터를 의미합니다. 우리는 "서버 상태", "통신 상태", "위치 상태"와 같은 카테고리로 나눌 수 있지만, 중요한 점은 데이터가 저장되고, 읽혀지고, 업데이트되고, 사용된다는 것입니다.

XState 라이브러리의 저자이자 상태 머신 전문가인 David Khourshid는 다음과 같이 말했습니다.

> "상태 관리(State management)란 상태가 시간에 따라 어떻게 변화하는지를 관리하는 것입니다."

이를 바탕으로 우리는 "상태 관리"가 다음과 같은 방법들을 갖추는 것을 의미한다고 말할 수 있습니다:

- 초기 값을 저장하는 방법
- 현재 값을 읽어오는 방법
- 값을 업데이트하는 방법
- 일반적으로 현재 값이 변경되었을 때 알림을 받을 수 있는 방법도 존재합니다.

React의 useState와 useReducer 훅은 상태 관리의 좋은 예입니다. 이 두 가지 훅을 사용하면 다음과 같은 작업을 할 수 있습니다:

- 훅을 호출하여 초기 값을 저장
- 훅을 호출하여 현재 값을 읽어옴
- 제공된 setState 또는 dispatch 함수를 호출하여 값을 업데이트
- 컴포넌트가 다시 렌더링되면 값이 업데이트되었음을 알 수 있음

마찬가지로 Redux와 MobX도 명확하게 상태 관리 도구입니다.

- Redux는 root reducer를 호출하여 초기 값을 저장하고, store.getState()를 사용하여 현재 값을 읽고, store.dispatch(action)를 사용하여 값을 업데이트하며, store.subscribe(listener)를 통해 업데이트를 알립니다.
- MobX는 상태 클래스의 필드 값을 할당하여 초기 값을 저장하고, 해당 필드에 접근하여 현재 값을 읽으며, 필드에 할당하여 값을 업데이트하며, autorun() 및 computed()를 통해 변경 사항을 알립니다.

React-Query, SWR, Apollo, Urql과 같은 서버 캐싱 도구들도 "상태 관리"의 정의에 부합한다고 말할 수 있습니다. 이들은 가져온 데이터를 기반으로 초기 값을 저장하고, 훅을 통해 현재 값을 반환하며, "서버 뮤테이션"을 통해 업데이트를 허용하고, 컴포넌트를 다시 렌더링하여 변경 사항을 알립니다.

React Context는 이러한 기준을 충족하지 않습니다. 따라서 Context는 "상태 관리" 도구가 아닙니다! 이전에 말한대로, Context 자체는 아무 것도 "저장"하지 않습니다. <MyContext.Provider>를 렌더링하는 부모 컴포넌트가 어떤 값을 컨텍스트로 전달할지 결정하는 것은 부모 컴포넌트의 역할이며, 일반적으로 React 컴포넌트의 상태를 기반으로 값을 전달합니다. 실제 "상태 관리"는 useState/useReducer 훅을 사용하여 진행됩니다.

David Khourshid는 다음과 같이 말했습니다.

> Context는 상태(이미 어딘가에 존재하는)가 다른 컴포넌트와 공유되는 방법입니다. Context는 상태 관리와 거의 관련이 없습니다.

혹은 최근의 트윗에서 다음과 같이 언급되었습니다.

> Context는 추상화된 상태보다는 숨겨진 프롭스와 비슷합니다.

다음과 같이 생각해보세요. 우리는 정확히 같은 useState/useReducer 코드를 작성했지만 데이터와 업데이트 함수를 컴포넌트 트리를 통해 프롭 드릴링하는 방식으로 작성할 수도 있습니다. 전반적으로 앱의 동작은 동일하게 유지될 것입니다. Context가 하는 일은 우리에게 프롭 드릴링을 건너뛰게 해주는 것뿐입니다.

### Context와 React+Redux 비교

Context와 React+Redux의 실제 기능을 살펴보겠습니다:

Context

- 어떤 데이터도 저장하거나 "관리"하지 않음
- React 컴포넌트 내에서만 동작
- 하나의 값만 전달하며, 이 값은 어떤 것이든 될 수 있음 (원시 값, 객체, 클래스 등)
- 전달된 단일 값을 읽을 수 있음
- 프롭 드릴링을 피하기 위해 사용할 수 있음
- React DevTools에서 Provider 및 Consumer 컴포넌트의 현재 컨텍스트 값을 표시하지만, 이 값이 어떻게 변경되었는지의 이력은 표시되지 않음
- 컨텍스트 값이 변경되면 소비하는 컴포넌트를 업데이트하지만, 업데이트를 건너뛸 수 있는 방법은 없음
- 부수 효과를 위한 기능이 포함되어 있지 않으며, 오로지 컴포넌트 렌더링에 사용됨

React+Redux

- 하나의 값을 저장하고 관리함 (일반적으로 객체 형태)
- React 컴포넌트 외부를 포함한 모든 UI와 함께 동작함
- 하나의 값을 읽을 수 있음
- 프롭 드릴링을 피하기 위해 사용할 수 있음
- 액션을 디스패치하고 리듀서를 실행하여 값을 업데이트할 수 있음
- 디스패치된 모든 액션과 상태 변경 이력을 보여주는 DevTools를 제공함
- 미들웨어를 사용하여 앱 코드에서 부수 효과를 발생시킬 수 있음
- 컴포넌트는 스토어 업데이트에 구독하고, 스토어 상태의 특정 부분을 추출하며, 해당 값이 변경될 때만 다시 렌더링됨

따라서 이들은 명백히 서로 다른 기능을 가진 매우 다른 도구입니다. 실제로 이들 사이의 중첩은 "프롭 드릴링을 피하기 위해 사용할 수 있다" 정도뿐입니다.

## Context와 useReducer

"Context vs Redux" 토론에서의 문제 중 하나는 사람들이 실제로 "useReducer를 사용하여 상태를 관리하고, 그 값을 전달하기 위해 Context를 사용하고 있다"는 것을 자세히 언급하지 않고 그냥 "Context를 사용하고 있다"고만 말한다는 점입니다. 이는 혼돈의 주요 원인이 되며, Context가 "상태를 관리한다"는 생각을 계속 유지시키는 불행한 상황입니다.

그러므로, 특히 Context + useReducer 조합에 대해 이야기해봅시다. 맞습니다, Context + useReducer는 Redux + React-Redux와 매우 유사합니다. 두 가지 모두 다음과 같은 특징을 갖고 있습니다:

- 저장된 값
- 리듀서 함수
- 액션 디스패치
- 값을 전달하고 중첩된 컴포넌트에서 해당 값을 읽을 수 있는 방법

그러나 Context + useReducer와 Redux + React-Redux의 기능 및 동작에는 여전히 매우 중요한 차이점이 있습니다. 제 포스트 "React, Redux, and Context Behavior"와 "A (Mostly) Complete Guide to React Rendering Behavior"에서 핵심 포인트를 다루었습니다. 여기서 요약하면 다음과 같습니다:

Context + useReducer는 Context를 통해 현재 상태 값을 전달하는 방식을 사용합니다. React-Redux는 Context를 통해 현재 Redux 스토어 인스턴스를 전달합니다.
이는 useReducer가 새로운 상태 값을 생성할 때, 해당 컨텍스트에 구독된 모든 컴포넌트가 강제로 다시 렌더링되게 됩니다. 이는 데이터의 크기, 해당 데이터에 구독하는 컴포넌트 수 및 그들이 얼마나 자주 다시 렌더링되는지에 따라 성능 문제를 야기할 수 있습니다. React-Redux에서는 컴포넌트가 스토어 상태의 특정 부분에 구독하고, 해당 값이 변경될 때만 다시 렌더링될 수 있습니다.
또한, 몇 가지 중요한 차이점이 더 있습니다:

Context + useReducer는 React 기능이므로 React 외부에서는 사용할 수 없습니다. Redux 스토어는 어떤 UI에도 독립적이므로 React와 별도로 사용할 수 있습니다.
React DevTools는 현재 컨텍스트 값을 볼 수 있지만, 이력적인 값이나 변경 내역은 표시되지 않습니다. Redux DevTools는 디스패치된 모든 액션, 각 액션의 내용, 각 액션 처리 후 존재하는 상태 및 시간별 상태 간 차이를 볼 수 있습니다.
useReducer에는 미들웨어가 없습니다. useReducer와 useEffect를 조합하여 일부 부수 효과적인 작업을 수행할 수 있지만, 이들은 Redux 미들웨어의 기능과 능력에 비해 매우 제한적입니다.
Context에 대한 사용 용도에 대해 Sebastian Markbage(React 핵심 팀 아키텍트)가 말한 내용을 다시 언급해보면:

개인적으로 저의 요약은, 새로운 context는 저빈도 불확실한 업데이트(예: locale/테마)에 사용할 준비가 되었습니다. 이전 context와 마찬가지로 정적인 값에 사용하기에 좋습니다. 즉, 정적인 값으로 사용하고, 업데이트를 구독을 통해 전파하는 방식으로 사용할 수 있습니다. 모든 Flux와 유사한 상태 전파를 대체하기 위해 사용할 준비는 되지 않았습니다.

다양한 분리된 상태 청크에 대해 여러 개의 별도 Context를 설정하는 것을 권장하는 게시물이 많이 있습니다. 이는 불필요한 재렌더링을 줄이고 관심사를 범위로 지정하기 위해 제안됩니다. 그 중 일부는 자체적인 "컨텍스트 선택기 컴포넌트"를 추가하도록 권장하며, 이는 React.memo(), useMemo(), 그리고 세심한 분할을 통해 데이터와 업데이트 함수를 위한 두 개의 별도 컨텍스트를 생성하는 방식입니다. 그렇습니다, 이 방식으로 코드를 작성하는 것도 가능하지만, 그 순간부터는 단순히 React-Redux를 잘못 재구성하고 있는 것입니다.

따라서, Context + useReducer가 Redux + React-Redux와 어느 정도 유사하게 보일지라도... 이들은 완전히 동일하거나 Redux를 완전히 대체할 수 있는 것은 아닙니다!


--- 

## 요약 

- context와 redux는 서로 다른 도구이다. 
- context를 상태관리 도구로 착각할 수 있지만, context는 상태관리 도구가 아니다. 그 어떤 것도 관리하지 않는 것이 context다. context는 그저 값을 전달하는 전달자, 파이프, 웜홀과 같은 역할을 할 뿐이다. 
- context의 주 목적은 prop drilling을 피하는 것이다. 
- context가 상태관리 도구가 되기 위해서는 useReducer와 조합되는 방식으로 사용되어야만 상태관리 도구라고 부를 수 있다. 
- redux는 상태를 예측 가능하게 관리하기 위한 도구다. 
- 상태란 시간에 따라 변경하는 데이터를 말한다. 
- 상태 관리는 시간에 따라 변경하는 데이터를 예측가능한 방식으로 업데이트하기 위해서 관리하기 위한 도구이다. 
- 이 상태 관리가 반드시 갖춰야만하는 조건이 4가지 있다. 
	- 상태의 초기값을 설정해야한다. 
	- 상태를 읽어올 수 있어야 한다. 
	- 상태를 업데이트 할 수 있어야 한다. 
	- 상태가 변경되었을 때 listen할 수 있어야 한다. 
- 위 조건에 따르면 context는 상태관리 도구가 아니라고 할 수 있다. 