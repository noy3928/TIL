## 5.1 조건부 타입 

### extends와 제네릭을 활용한 조건부 타입 

```ts
interface Bank {
    financialCode : string;
    companyName : string;
    name : string;
    fullName : string;
}

interface Card {
    financialCode : string;
    companyName : string;
    name : string;
    appCardType?: string;
}

type PayMethod<T> = T extends "card" ? Card : Bank;
type CardPayMethodType = PayMethod<"card">;
type BankPayMethodType = PayMethod<"bank">;
```

### infer 키워드를 활용한 조건부 타입 


```ts
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;
```

- UnpackPromise 타입은 제네릭으로 T를 받아 T가 Promise로 래핑된 경우라면 K를 반환하고, 그렇지 않은 경우에는 any를 반환한다. Promise<inter K>는 Promise의 반환값을 추론해 해당 값의 타입을 K로 한다는 의미다. 
    
  ```ts
  const promises = [Promise.resolve("1"), Promise.resolve(2)];
  type Expected = UnpackPromise<typeof promises>; // string | number
  ```


## 5.4 불변 객체 타입으로 활용하기

```ts
const colors = {
    red : "red",
    blue : "blue",
    green : "green"
} 

const theme = {
    colors : {
        ...colors 
    },
    ...
}

type ColorType = typeof keyof theme.colors;
type BackgroundColor = typeof keyof theme.colors;
type FontSizeType = typeof keyof theme.fontSize;

interface Props {
    color? : ColorType;
    backgroundColor? : BackgroundColor;
    onClick? : () => void;
}

const Button = ({color, backgroundColor} : Props) => {
    return (
        <ButtonWrap style={{color, backgroundColor}}>버튼</button>
    )
}

const ButtonWrap = styled.button<Omit<Props, "onClick">>`
    color : ${({color}) => color};
    background-color : ${({backgroundColor}) => backgroundColor};
`
```






