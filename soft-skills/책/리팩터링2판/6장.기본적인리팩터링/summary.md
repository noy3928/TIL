## 6.1 함수 추출하기

- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
- 독립된 함수로 묶는 기준 : '목적과 구현을 분리'하는 방식.
  - 코드를 보고 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다.
- 이름은 '어떻게'가 아닌 '무엇을'하는지를 드러내야한다.

<br>

## 6.2 함수 인라인하기

- 함수 본문이 이름만큼 명확한 경우에만 사용한다.

<br>

## 6.3 변수 추출하기

- 표현식이 너무 복잡해서 이해하기 어려울 때는 표현식의 일부분을 꺼내서 이름을 붙인다.
- 디버깅에도 도움이 된다. 중단점을 지정할 수 있게 때문.
- 객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다. (p. 177)

<br>

## 6.4 변수 인라인하기

- 변수 이름이 원래 표현식과 다를 바 없을 때는 그 변수를 제거한다.

<br>

## 6.5 함수 선언 바꾸기

- 함수는 시스템 구성요소를 조립하는 연결부 역할을 한다. 이 연결부를 잘 정의하면 시스템에 새로운 부분을 추가하기가 쉬워지는 반면, 잘못 정의하면 지속적인 방해 요인으로 작용하여 소프트웨어 동작을 파악하기 어려워지고, 새로운 기능을 추가하기도 어려워진다.
- 이런 연결부에서 가장 중요한 것은 함수의 이름이다.
  - 좋은 이름을 짓는 꿀팀 : 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다보면 주석이 멋진 이름으로 바뀌어 되돌아온다.
- 매개변수도 중요하다. 매개변수는 외부세계와 어우러지는 방식을 정의한다. 이것을 통해 함수가 사용될 때의 문맥을 설정한다.

<br>

## 6.6 변수 캡슐화하기

- 리팩터링시 데이터는 함수보다 다루기가 까다롭다. 왜냐하면 참조하는 모든 부분을 한번에 바꿔야할 뿐더러, 유효범위가 넓어지면 참조하는 부분을 찾기가 어려워지기 때문이다.
- 때문에 데이터로의 접근을 독점하는 함수를 만든다. 이것을 통해 함수 재구성이라는 조금 더 쉬운 작업으로 옮길 수 있다.
- 그리고 이렇게 캡슐화가 되고 나면, 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.
- 데이터에 대한 결합도를 낮추는 것은 중요하다. (데이터에 대한 의존성이 유지보수성을 심히 떨어뜨리기 때문이다.)

<br>

## 6.7 변수 이름 바꾸기

- 변수의 존재 이유를 살펴보고, 그에 걸맞는 이름을 짓는다.

<br>

## 6.8 매개변수 객체 만들기

- 데이터 뭉치를 데이터 구조로 묶으면 데이터 사이의 관계가 명확해진다.

<br>

## 6.9 여러 함수를 클래스로 묶기

- 클래스는 데이터와 함수를 하나의 공유 환경으로 묶은 후, 다른 프로그램 요소와 어우러질 수 있도록 그중 일부를 외부에 제공한다.
- 클래스로 묶으면 함수들이 공유하는 공통 환경을 더 명확하게 표현할 수 있다. 그리고 각 함수에 전달되는 인수를 줄여서 객체 안에서의 함수 호출을 간결하게 만들 수 있다.

<br>

## 6.10 여러 함수를 변환 함수로 묶기

<br>

## 6.11 단계 쪼개기

- 한 함수에서 두 가지 일을 하고 있을 땐, 그 함수를 쪼개어 각각의 역할을 수행하는 함수를 만든다.
- 동작을 연이은 두 단계로 쪼갠다.
  - 각 단계는 자신만의 문제에 집중하기 때문에 나머지 단계에 관해서는 자세히 몰라도 이해할 수 있다.
