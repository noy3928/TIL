## 6.1 함수 추출하기

- 코드 조각을 찾아 무슨 일을 하는지 파악한 다음, 독립된 함수로 추출하고 목적에 맞는 이름을 붙인다.
- 독립된 함수로 묶는 기준 : '목적과 구현을 분리'하는 방식.
  - 코드를 보고 무슨 일을 하는지 파악하는 데 한참이 걸린다면 그 부분을 함수로 추출한 뒤 '무슨 일'에 걸맞는 이름을 짓는다.
- 이름은 '어떻게'가 아닌 '무엇을'하는지를 드러내야한다.

<br>

## 6.2 함수 인라인하기

- 함수 본문이 이름만큼 명확한 경우에만 사용한다.

<br>

## 6.3 변수 추출하기

- 표현식이 너무 복잡해서 이해하기 어려울 때는 표현식의 일부분을 꺼내서 이름을 붙인다.
- 디버깅에도 도움이 된다. 중단점을 지정할 수 있게 때문.
- 객체는 특정 로직과 데이터를 외부와 공유하려 할 때 공유할 정보를 설명해주는 적당한 크기의 문맥이 되어준다. (p. 177)

<br>

## 6.4 변수 인라인하기

- 변수 이름이 원래 표현식과 다를 바 없을 때는 그 변수를 제거한다.

<br>

## 6.5 함수 선언 바꾸기

- 함수는 시스템 구성요소를 조립하는 연결부 역할을 한다. 이 연결부를 잘 정의하면 시스템에 새로운 부분을 추가하기가 쉬워지는 반면, 잘못 정의하면 지속적인 방해 요인으로 작용하여 소프트웨어 동작을 파악하기 어려워지고, 새로운 기능을 추가하기도 어려워진다.
- 이런 연결부에서 가장 중요한 것은 함수의 이름이다.
  - 좋은 이름을 짓는 꿀팀 : 주석을 이용해 함수의 목적을 설명해보는 것이다. 그러다보면 주석이 멋진 이름으로 바뀌어 되돌아온다.
- 매개변수도 중요하다. 매개변수는 외부세계와 어우러지는 방식을 정의한다. 이것을 통해 함수가 사용될 때의 문맥을 설정한다.

<br>

## 6.6 변수 캡슐화하기

- 리팩터링시 데이터는 함수보다 다루기가 까다롭다. 왜냐하면 참조하는 모든 부분을 한번에 바꿔야할 뿐더러, 유효범위가 넓어지면 참조하는 부분을 찾기가 어려워지기 때문이다.
- 때문에 데이터로의 접근을 독점하는 함수를 만든다. 이것을 통해 함수 재구성이라는 조금 더 쉬운 작업으로 옮길 수 있다.
- 그리고 이렇게 캡슐화가 되고 나면, 데이터 변경 전 검증이나 변경 후 추가 로직을 쉽게 끼워 넣을 수 있다.
