# 1장 - 리팩터링: 첫 번째 예시

- 1장에서는 실제 예제 코드를 가지고, 리팩터링을 통해 코드가 개선되어가는 과정을 보여주고 있다.
- 코드를 개선하는 3가지 과정.
- 리팩터링의 목적.
- 간결함과 명확함이 충돌하는 경우.

## 코드를 개선하는 3가지 과정.

### 1. 하나의 큰 일을 감당하고 있던 함수를 작은 단위의 책임을 가진 함수로 잘게 나눈다.

하나의 함수 안에서 여러가지 역할을 감당하고 있는 코드를 보면, 한 눈에 무슨 일을 하고 있는지 파악하기가 힘들어진다. 심지어, 여러 일을 감당하고 있기 때문에 함수의 이름을 짓는 것조차 어렵다. 이런 함수는 코드를 읽는 사람에게 혼란을 준다. 이런 함수를 작은 단위의 책임을 가진 함수로 잘게 나누면, 함수의 이름을 짓는 것도 쉬워지고, 코드를 읽는 사람에게도 혼란을 주지 않는다.
이런 내용은 프론트엔드에서 컴포넌트를 작성할 때도 적용되는 내용이라고 생각한다. 2가지 측면으로 접근해볼 수 있는데, 명확히 하나의 ui를 감당하고자 하는지, ui의 역할과 비즈니스로직에 대한 부분이 분리되어있는지가 기준된다. 여러 ui를 하나의 컴포넌트 안에서 다 감당하고자 하면, 이 또한 가독성을 떨어뜨리는 요인이 된다. 또한 ui와 비즈니스 로직이 분리되어있지 않으면, 점점 컴포넌트 안쪽의 코드가 지저분해지고, 테스트하는 것 또한 어려운 코드가 되어버린다.

### 2. 전체 흐름 속에서 단계를 나누어 코드를 분리한다.

- 책에서는 2가지 단계로 나누어 코드를 분리했다. 계산 코드와 출력 코드를 분리하는 모습을 볼 수 있었다. 이렇게 함수가 하고 있는 일들을 잘 살펴본 다음, 추상화할 수 있는 범주가 있다면 그것을 범주화하는 것은 가독성을 매우 높여준다. 그리고, 이 함수가 하는 동작이 어떻게 이루어지고 있는지 파악하기 쉬워진다.
- 책의 6장 11절에 단계 쪼개기에 대한 더 자세한 설명이 있다. 단계를 분리하는 이유는 두 대상을 동시에 다루는 모듈이 있으면, 사고가 복잡해지기 때문이다. 코드를 수정할 때, 하나의 대상에만 집중할 수 있게 만들기 위해서 단계를 분리하는 것이다. 단계를 분리하기 위해서 선제되어야 하는 것이, 작은 일을 감당하는 작은 함수를 여러개로 만드는 것이다. 그리고 이 함수들을 호출하는 함수를 만들어서 단계를 분리하는 것이다.
- 프론트엔드에서도 당장에 떠오르는 단계가 있다면, 비즈니스 로직과 ui를 분리하는 것이다. 그리고 비즈니스 로직에서도 서버의 데이터를 가져오는 부분과, ui에서 내려줄 데이터를 가공하는 부분을 분리할 수 있다. 만약 이렇게 3단계로 구분한다면, 문제가 생기는 일이 있을 때, 각 단계에 대한 코드만 쳐다보면 된다. 만약 서버에서 데이터 구조를 바꿔서 문제가 생겼다면, 데이터를 가공하는 부분만 살펴보면 된다. ui에서의 코드는 수정할 부분이 없으며, 서버에서 데이터를 가져오는 부분도 살펴볼 필요가 없다.

### 3. 다형성을 통해서 if문이 사용되는 부분을 제거한다.

## 리팩터링의 목적은 무엇인가.

- 리팩터링은 결국 좋은 코드를 만들어내기 위함이다. 그렇다면 좋은 코드란 무엇인가?
  - 책은 "얼마나 수정하기 쉬운가"를 기준으로 놓는다고 대답하고 있다.
  - 내 생각 : 나 또한 이런 생각에 동의하는 편이다. 객체지향이나 함수형 프로그래밍과 같은 프로그래밍 패러다임을 공부하는 이유도 결국에는 유지보수성을 높이기 위함이다. 유지보수성이 높다는 것은, 어제의 기능을 수행하기 쉽고, 새로운 기능이 추가되기도 쉬운 설계를 가진다는 것을 의미한다. 나는 대체로 리팩터링을 할 때, 객체지향과 함수형의 여러 기법을 통해 놓고 코드를 고치곤 했다. 이런 행위를 할 때, 유념했던 것은 결국 이런 개선을 통해 '더 수정하기 쉬운 코드가 되었는가'라는 기준을 가지고 되돌아보곤 했다. 책을 읽으면서 다시 한번, 결국 코드를 개선하는 행위는 '더 수정하기 쉬운 코드'를 지향한다는 것을 깨달았다.

## 간결함 vs 명확함

책에서는 간결함과 명확함이 충돌하는 경우가 있다면, 명확함을 추구할 것을 이야기하고 있다.

> 코드는 명확해야 한다. 코드를 수정해야 할 상황이 되면 고쳐야 할 곳을 쉽게 찾을 수 있고 오류 없이 빠르게 수정할 수 있어야 한다

결국 좋은 코드란 수정하기 쉬운 코드이다. 하지만, 현재 코드가 하고 있는 일이 무엇인지 파악하기가 어려워질 때, 그러니까 명확성이 떨어질 때는 코드를 수정하는 것이 어려워진다. 그렇기 때문에, 간결함과 명확함이 충돌한다면, 명확함을 추구하는 것이 좋다.
