# 3. 코드에서 나는 악취

- 이 장에서는 코드에서 악취가 나는 여러 사례를 소개한다.

## 3.1 기이한 이름

- 함수, 모듈, 클래스 등은 그 이름만 보고도 각각이 무슨 일을 하고 어떻게 사용해야하는지 명확히 알 수 있어야 한다.
- 만약 마땅한 이름이 떠오르지 않는다면 설계에 더 근본적인 문제가 숨어 있을 가능성이 높다. 그래서 혼란스러운 이름을 잘 정리하다보면 코드가 훨씬 간결해질 때가 많다.

## 3.2 중복 코드

- 중복 코드는 코드를 수정할 때마다 여러 곳을 수정해야 하기 때문에 유지보수성이 떨어진다.

## 3.3 긴 함수

- 오랜 기간 잘 활용되는 프로그램들은 하나같이 짧은 함수로 구성되어있다.
- 간접호출의 효과, 즉 코드를 이해하고, 공유하고 선택하기 쉬워진다는 장점은 함수를 짧게 구성할 때 나오는 것이다.
- 적극적으로 함수를 쪼개야 한다.
- 주석을 달아야할 부분이 생긴다면, 함수로 만든다.
- 함수의 이름은 동작방식이 아닌, 의도가 드러나게 짓는다.
  - 함수의 이름에 코드의 목적을 드러내야 한다. 여기서 핵심은 함수의 길이가 아닌, 함수의 목적과 구현 코드의 괴리가 얼마나 큰가이다. 즉, 무엇을 하는지를 코드가 잘 설명해주지 못할수록 함수로 만드는 게 유리하다.

## 3.4 긴 매개변수 목록

- 매개변수가 많으면 함수를 이해하기 어렵다.

## 3.5 전역 데이터

- 전역 데이터는 모든 함수가 참조하고 변경할 수 있기 때문에 위험하다. 이것으로 인해 발생한 문제는 원인을 파악하는 것도 매우 힘들다.
- 대표적인 리팩터링 기법은 변수 캡슐화하기이다. 다른 코드에서 오염시킬 가능성이 보일 때마다 이 기법을 적용한다.

## 3.6 가변 데이터

- 함수형 프로그래밍에서는 데이터는 절대 변하지 않고, 데이터를 변경하려면 반드시 변경하려는 값에 해당하는 복사본을 만들어서 반환한다는 개념을 기본으로 삼고 있다.

## 3.7 뒤엉킨 변경

- 하나의 모듈을 수정할 때 다른 모듈도 수정해야 한다면, 뒤엉킨 변경이라고 한다.
- 코드를 수정할 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 수정할 수 있기를 바란다.

## 3.8 산탄총 수술

- 변경햘 부분이 코드 전반에 퍼져 있다면 찾기도 어렵고 꼭 수정해야 할 곳을 지나치기 쉽다.

## 3.9 기능 편애

- 하나의 모듈이 너무 다른 모듈에 의존하면 기능 편애가 발생한다.
- 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대로 늘리고 영역 사이에 이뤄지는 상호작용은 최소로 줄인다.

## 3.10 데이터 뭉치

- 데이터 뭉치인지 판별하려면 값 하나를 삭제해보자. 그랬을 때 나머지 데이터만으로는 의미가 없다면 객체로 환생하길 갈망하는 데이터 뭉치라는 뜻이다.

## 3.11 기본형 집착

- 기본형 집착은 기본형 변수를 객체로 바꾸거나, 컬렉션을 캡슐화하는 등의 리팩터링을 통해 해결할 수 있다.

## 3.12 반복되는 switch문

- switch문은 다형성을 이용해 제거할 수 있다.

## 3.13 반복문

- 반복문을 파이프라인으로 바꿔 해결할 수 있다.

## 3.14 성의 없는 요소

- 성의 없는 요소는 코드를 읽는 사람이 당연하게 여기는 부분을 의미한다.

## 3.15 추측성 일반화

- 추측성 일반화는 미래를 대비해 코드를 작성하는 것이다.
- 추측성 일반화는 코드를 복잡하게 만들고, 불필요한 기능을 추가하고, 미래에 필요할 것 같은 기능을 미리 추가해놓는다.
- 미래를 대비해 작성한 부분을 실제로 사용하게 되면 다행이지만, 그렇지 않다면 당장 지워버리자.
