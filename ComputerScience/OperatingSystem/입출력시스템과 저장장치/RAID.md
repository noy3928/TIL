# RAID

데이터를 저장장치에 저장할 때는 반드시 백업이 필요하다.  
그러나 이것을 수동으로 하면 번거롭다.  
RAID(Redundant Array of Independent Disks)는 자동으로 백업을 하고 장애가 발생하면 이를 복구하는 시스템으로 '레이드'라고 읽는다.

#### 레이드의 원리 :

하나의 원본 디스크와 같은 크기의 백업 디스크에 같은 내용을 동시에 저장하고, 하나의 디스크가 고장 났을 때 다른 디스크를 사용하여 데이터를 복구하는 것이다.  
이러한 방식은 2개의 디스크에 거울처럼 똑같은 내용을 저장한다는 의미에서 미러링이라고 한다.

#### 레이드와 입출력 속도 향상 - 스트라이핑 :

레이드에는 여러 디스크에 데이터를 동시에 저장하여 데이터의 입출력 속도를 높이는 방식도 있다.  
예를 들어, A,B,C,D 라는 4개의 데이터를 저장한다면 디스크가 1개 일 때는 작업을 네번 해야하지만  
디스크가 4개일 때는 각각의 디스크에 1개씩 4개의 데이터를 동시에 저장하여 입출력 속도를 높일 수 있다.  
데이터를 여러 조각으로 나누어 보내기 때문에 이러한 방식을 스트라이핑이라고 한다.

## RAID 0 (스트라이핑)

RAID0은 병렬로 연결된 여러 개의 디스크에 데이터를 동시에 입출력할 수 있도록 구성된다.  
RAID0에서는 4개의 데이터가 주어진다면, 동시에 저장한다.  
때문에 일반 시스템보다 이론적으로는 입출력 속도가 4배 빠르다.  
<br>

## RAID 1 (미러링)

RAID1 에서는 하나의 데이터를 2개의 디스크에 나누어 저장하여 장애 시 백업 디스크로 활용한다.  
RAID1은 같은 크기의 디스크를 최소 2개 이상 필요로 하며 짝수 개의 디스크로 구성된다.

### 단점 :

- 저장하는 데이터와 같은 크기의 디스크가 하나 더 필요하기 때문에 비용이 증가한다.
- 같은 내용을 2번 저장하기 때문에 속도가 느려질 수 있다.  
  <br>

## RAID 2

RAID2에서는 오류를 검출하는 기능이 없는 디스크에 대해 오류교정코드를 따로 관리하고,  
오류가 발생하면 이 코드를 이용하여 디스크를 복구한다.

- 오류검출코드 : 오류가 발생했는지 확인할 수 있는 코드로, 패리티 비트가 대표적인 예다.
- 오류교정코드 : 오류가 발생했는지 확인하는 동시에 오류를 교정할 수 있는 코드로, 허밍 코드가 대표적인 예다.

#### RAID2에서의 저장단위 :

하드디스크의 데이터 저장 단위는 블록이다.  
그러나 RAID2에서는 비트 단위로 저장된다.

이렇게 비트 단위로 저장하는 이유는 각 비트의 오류 교정 코드를 구성하여 나중에 비트 단위로 복구하기 위해서이다.  
비트별로 만들어진 오류 교정 코드는 별도의 디스크에 저장되며, 장애 발생 시 이 코드를 이용하여 데이터를 복구한다.

## RAID 3

RAID3 과 RAID4는 패리티 비트를 사용한다.

#### 패리티 비트의 복구원리 :

패리티 비트에는 짝수 패리티 비트와 홀수 패리티 비트가 있다.  
짝수 패리티 비트는 1의 총수를 짝수로 만드는 것, 홀수는 1의 총수를 홀수로 만드는 것이다.  
4개의 디스크가 있고, 별도의 디스크에 1개의 짝수 패리티 비트를 보관했다고 가정해보자.  
이때 세번째 디스크에 장애가 생겨서 복구해야한다면 짝수 패리티 비트와 나머지 디스크의 1의 개수를 근거로  
세 번째 디스크 값을 알 수 있다. 즉 짝수 패리티 비트이므로 그 값은 1이 된다.

#### RAID3의 저장단위 :

섹터로 저장한다.  
일반적으로 디스크는 섹터 단위로 읽기 때문에 어떤 섹터에 오류가 있는지 없는지를 알 수 있다.  
따라서 오류 검출에 사용하는 패리티 비트를 여러 섹터끼리 묶어서 구성하면 오류가 없는 섹터를 이용하여  
오류가 있는 섹터의 데이터를 복원할 수 있는데 이를 N-way 패리티 비트방식이라고 부른다.

일반적으로 오류 검출 코드의 크키가 오류 정정 코드보다 작기 때문에 RAID 3에 추가되는 디스크 양은 4개의 디스크당 1개 정도이다.

<br>

## RAID 4

RAID4는 RAID3과 같은 방식이지만 처리하는 데이터 단위가 블록으로 되어있다.

#### RAID3의 한계 :

RAID3에서는 데이터를 모든 디스크의 섹터에 나누어 저장하는 방식으로 패리티 비트를 구성한다.  
이 경우 데이터를 읽거나 쓸 때 패리티 비트를 구성하기 위해 모든 디스크가 동시에 동작해야한다는 단점이 있다.

#### RAID3의 한계 극복 -> RAID 4 :

RAID4에서는 데이터를 하나의 디스크에 블록 단위로 저장하고 패리티 비트를 블록과 연결하여 구성한다.  
따라서 데이터가 저장되는 디스크와 패리티 비트가 저장되는 디스크만 동작한다는 것이 장점이다.

<br>

## RAID 5

#### RAID4를 이용하지 않는 이유 :

데이터의 병목 현상 때문.  
RAID4에서는 모든 패리티 비트가 하나의 디스크에 저장되기 때문에 입출력이 일어날 때마다  
패리티 비트 디스크에 데이터가 저장되어 병목 현상이 발생한다.

#### RAID5의 사용이유 :

RAID4와 같은 방법을 사용하지만 병목 현상을 해결했다.  
RAID5에서는 RAID4의 패리티 비트를 여러 디스크에 분산하여 구성한다.  
RAID5는 패리티 비트를 여러 디스크에 분산하여 보관함으로써 패리티 비트 디스크의 병목 현상을 완화한다.

또한 복구가 어려운 문제도 해결한다.  
데이터 A의 패리티 비트를 데이터 A가 없는 5번 디스크에,  
데이터 B의 패리티 비트를 데이터 B가 없는 4번 디스크에 보관한다.  
따라서 한 디스크에 장애가 발생하면 다른 디스크에 있는 패리티 비트를 이용하여 데이터를 복구할 수 있다.

<br>

## RAID 6

RAID6은 RAID5와 같은 방식이지만 패리티 비트가 2개다.

#### RAID5의 한계 :

RAID5는 한 개의 디스크에 장애가 발생했을 때는 복구가 가능하지만 디스크 2개에 동시에 장애가 발생했을 때는 복구가 불가능하다.

#### RAID6를 이용하는 이유 :

RAID6은 이러한 문제를 해결하기 위해 패리티 비트 2개를 구성하여 분산한다.  
RAID6는 디스크 2개의 장애를 복구할 수 있다.

#### 단점 :

- 계산량이 많다.
- 추가 디스크가 필요하다.

<br>

## RAID 10

RAID 시스템은 하드디스크의 가격이 내려가면서 추가되는 디스크의 수보다  
빠른 입출력과 복구에 중점을 두었다.  
그 결과 빠른 입출력이 장점이 RAID 0과 복구 기능을 가진 RAID1을 결합한 RAID10이 등장하게 되었다.

RAID10은 1 + 0 을 의미한다.  
미러링 기능을 가진 RAID1과 빠른 데이터 전송이 가능한 RAID0을 결합한 형태다.

### RAID 0 + 1과 RAID 10 의 차이 :

RAID0+1의 경우 4개의 디스크를 2개씩 묶어 RAID0으로 구성하고,  
RAID0으로 묶인 디스크를 RAID1로 다시 묶는다.

그러나 RAID10에서는 4개의 디스크를 2개씩 묶어 RAID1로 구성하고,  
RAID1로 묶인 디스크를 다시 RAID0으로 묶는다.

- RAID0+1은 장애가 발생했을 때 복구하기 위해 모든 디스크를 중단해야 하지만 RAID10은 일부 디스크만 중단하여 복구할 수 있다는 것이다.

<br>

## RAID 50 과 RAID60

RAID 50 과 RAID60 은 마찬가지로 RAID를 0으로 묶어 성능을 높이는 방식이다.  
RAID50에서는 RAID5로 묶은 두 쌍을 다시 RAID0으로 묶어 사용하고,  
RAID60에서는 RAID6으로 묶은 두 쌍을 다시 RAID0으로 묶어 사용한다.
