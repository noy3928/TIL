# 순차적 트랜잭션의 문제 - 지연

커넥션 관리가 제대로 이루어지지 않으면 TCP의 성능이 매우 안좋아질 수 있다.  
이미지를 3개 보여줘야하는 페이지가 있다. 그러면 트랜잭션은 총 4번이 이루어진다.  
첫번째는 html을 받기 위함이고, 나머지는 이미지를 받기 위함이다.  
각 트랜잭션이 새로운 커넥션을 필요로 한다면, 커넥션을 맺는데 발생하는 지연과 함께 느린 시작 지연이 발생할 것이다.  
이렇게 이미지를 받아오는데, 속도가 느리다면 사용자 경험이 좋지 않을 것이다.  
이를 해결하기 위한 기술들이 있다.

1. 병렬 커넥션
2. 지속커넥션
3. 파이프라인 커넥션
4. 다중 커넥션

<br>

## 병렬 커넥션

HTTP는 클라이언트가 여러 개의 커넥션을 맺음으로써 여러 개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 해준다.  
각 커넥션의 지연 시간을 겹치게 한다면 총 지연시간을 줄일 수 있을 것이다.  
클라이언트의 인터넷 대역폭을 한 개의 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는데에 남은 대역폭을 사용할 수 있을 것이다.

☀︎ 대역폭 : 일정한 시간 내에 데이터 연결을 통과할 수 있는 정보량의 척도다.

### 항상 병렬커넥션이 더 빠른 것은 아니다.

대역폭이 좁은 경우에는 병렬 커넥션이 이점이 되지 못한다.  
대부분의 시간을 데이터를 전송하는데에만 사용하게 될 것이다.  
여러 개의 객체를 병렬로 내려받는 경우, 이 제한된 대역폭 내에서 각 객체가 전송받는 것은 느리기 때문에  
성능상의 장점은 거의 없어진다.

이것의 문제점은 클라이언트가 100개의 커넥션을 맺고,
가상 유저 100명이 있다면, 서버 입장에서는 10000개의 커넥션을 맺어야하는 것이다.  
이런 상황은 성능을 크게 떨어뜨릴 수 있다.

### 병렬 커넥션이 더 빠르게 '느껴질 수'도 있다.

화면에 여러 개의 객체가 동시에 보이면서 내려받고 있기 때문에 더 빠르게 보일 수도 있다.

[출처 : HTTP 완벽가이드]

<br>

## 지속커넥션

HTTP/1.1을 지원하는 기기는 처리가 완료된 후에도 TCP 커넥션을 유지하여 앞으로 있을 HTTP 요청에 재사용할 수 있다.  
처리가 완료된 후에도 계속 연결된 상태로 있는 TCP커넥션을 지속 커넥션이라고 부른다.  
비지속 커넥션은 각 처리가 끝날 때마다 커넥션을 끊는다.  
지속 커넥션은 클라이언트나 서버가 끊기 전까지는 유지한다.

### 지속 커넥션의 장점

1)커넥션을 맺기 위산 사전작업과 지연을 줄여준다.  
2)튜닝된 커넥션을 유지한다. - 패킷을 수 차례 성공적으로 전송한 결과로 한 번에 다수의 패킷을 전송할 수 있는 권한을 얻은 상태의 커넥션을 의미한다.  
3)커넥션의 수를 줄여준다.

주의점 :
연결된 상태의 수많은 커넥션이 쌓이게 될 것이다.

가장 효과적인 방법 : 병렬 + 지속  
오늘날의 애플리케이션은 적은 수의 병렬 커넥션만을 맺고 그것을 지속한다.

### HTTP/1.0+의 Keep-Alive 커넥션 및 동작

keep-alive의 장점은 하나의 지속적인 커넥션으로만 처리함으로써 작업 시간이 단축된다.

동작방식 :  
1)클라이언트는 커넥션을 유지하기 위해서 요청에 Connection:Keep-Alive 헤더를 포함시킨다.  
2)이 요청을 받은 서버는 그 다음 요청에도 이 커넥션을 통해 받고자 한다면, 응답 메시지에 같은 헤더를 포함시켜 응답한다.  
3)응답에 Connection:Keep-Alive 헤더가 없으면 응답 메시지가 전송된 이후 커넥션을 끊을 것이라 추정한다.

### Keep-Alive와 멍청한 프락시

문제는 프락시에서 시작된다. 프락시는 Connection 헤더를 이해하지 못해서 해당 헤더들을 삭제하지 않고 요청 그대로를 다음 프락시에 전달한다.  
오래되고 단순한 수많은 프락시들이 Connection 헤더에 대한 처리 없이 요청을 그대로 전달한다.  
예시 상황을 보자.

1.keep-alive헤더와 함께 메시지를 보내고, 커넥션 유지를 요청한다. 클라이언트는 커넥션을 유지하자는 요청이 받아들여졌는지 확인하기 위해 응답을 기다린다.  
2.프락시는 Connection 헤더의 내용을 이해하지 못한다. 프락시는 Keep-alive가 뭔지 모르기 때문에 다음 서버에 그대로 전달한다. 하지만 connection 헤더는 홉별 헤더이다. (이것은 오직 한 개의 전송 링크에만 적용되며 다음 서버로 전달되어서는 안 된다. 여기서부터 문제가 시작된다.)  
3.HTTP요청이 서버에 도착한다. 웹서버가 프락시로부터 keep-alive 헤더를 받으면, 웹서버는 프락시가 커넥션을 유지하자고 요청하는 것으로 잘못판단한다. 여기서 문제가 시작된다.  
4.멍청한 프락시는 서버로부터 받은 keep-alive헤더를 포함하고 있는 응답 메시지를 클라이언트에게 전달한다. 클라이언트는 이 헤더를 통해 프락시가 커넥션을 유지하는 것에 동의했다고 추정한다. 이 시점에 클라이언트와 서버는 커넥션을 유지하고 있다고 생각하지만, 정작 프락시는 Keep-alive를 이해하지 못한다.  
5.프락시는 keep-alive를 모르지만, 받은 데이터를 그대로 클라이언트에게 전달하고 서버가 커넥션을 끊기를 기다린다. 하지만 서버는 프락시가 커넥션 지속 요청을 한 것으로 알고 있기에 끊지 않는다. 따라서 프락시는 계속 커넥션이 끊어지기를 기다리게 된다.  
6.클라이언트가 응답 메시지를 받으면, 다음 요청을 보내기 시작한다. 커넥션이 유지되고 있는 프락시에 그 요청을 보낸다. 프락시는 같은 커넥션 상에서 다른 요청이 오는 경우는 예상하지 못하기 때문에 그 요청은 프락시로부터 무시되고 브라우저는 아무런 응답없이 로드중이라는 표시만 나오게 된다.  
7.이런 잘못된 통신 때문에, 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다리게 된다.
